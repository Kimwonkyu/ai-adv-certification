# 📘 [학습 노트] 교재 1. Python 기초 (Ultimate Deep Dive)

이 교재는 파이썬의 핵심 문법부터 메타프로그래밍, 메모리 관리, 동시성 구조까지 모든 고난도 문항을 대비할 수 있도록 구성되었습니다.

---

## 1. 파이썬의 철학과 구조
파이썬은 "모든 것이 객체(Object)"인 일관된 구조를 가집니다.

### 🐍 핵심 설계 철학
- **Duck Typing**: "만약 어떤 새가 오리처럼 걷고 오리처럼 꽥꽥거린다면, 그 새를 오리라고 부를 수 있다." 즉, 객체의 타입보다 객체가 어떤 메서드나 속성을 가졌는지가 중요합니다.
- **Protocol (Static Duck Typing)**: `typing.Protocol`을 통해 런타임이 아닌 정적 검사 시점에서도 오리 타이핑을 보장할 수 있습니다.
- **EAFP (Easier to Ask for Forgiveness than Permission)**: 일단 실행하고 예외를 처리하는 방식(`try-except`)을 권장합니다. (반대: LBYL - Look Before You Leap)

---

## 2. 메타프로그래밍: 클래스를 만드는 클래스
파이썬의 클래스는 그 자체로 객체이며, 이 객체를 만드는 틀이 바로 **메타클래스(Metaclass)**입니다.

### 🏗 Metaclass와 `type`
- **`type`**: 모든 클래스의 기본 메타클래스이며, 동시에 자기 자신(`type`)을 인스턴스로 가집니다.
- **클래스 생성 과정**:
    1.  `__new__`: 클래스 객체를 메모리에 할당 (Metaclass 수준).
    2.  `__init__`: 생성된 클래스 객체를 초기화.
- **목적**: 클래스가 정의되는 시점에 속성을 검증하거나, 메서드를 동적으로 추가하는 등 **클래스 팩토리(Class Factory)** 역할을 수행합니다.

### 📜 Descriptor Protocol (속성 제어 엔진)
객체의 속성에 접근할 때(`obj.attr`)의 동작을 정의하는 프로토콜입니다.
- **Data Descriptor**: `__set__` 또는 `__delete__`를 구현한 클래스.
- **Non-data Descriptor**: `__get__`만 구현한 클래스 (예: 일반 메서드).
- **접근 우선순위 (매우 중요)**:
    1.  **Data Descriptor** (인스턴스 딕셔너리보다 빠름)
    2.  인스턴스 딕셔너리 (`obj.__dict__`)
    3.  **Non-data Descriptor**
    4.  클래스 딕셔너리

---

## 3. 상속과 MRO (Method Resolution Order)
다중 상속 시 메서드를 찾는 순서를 결정하는 규칙입니다.

### 🔢 C3 Linearization 알고리즘
- 파이썬 2.3부터 도입된 알고리즘으로, 다중 상속의 모순(다이아몬드 상속 문제)을 해결합니다.
- **규칙**: 자식 클래스는 부모보다 먼저 조회되며, 여러 부모가 있을 경우 선언된 순서대로 조회됩니다.
- `ClassName.mro()` 또는 `ClassName.__mro__`를 통해 확인 가능합니다.
- **`super()`**: 단순 부모 클래스 호출이 아니라, MRO 상의 **다음(next)** 클래스를 호출하는 메커니즘입니다.

---

## 4. 메모리 관리와 성능 최적화
파이썬 인터프리터(CPython)의 내부 동작 원리입니다.

### 🔒 GIL (Global Interpreter Lock)
- **정의**: 한 번에 하나의 스레드만 파이썬 바이트코드를 실행할 수 있도록 제한하는 뮤텍스(Mutex)입니다.
- **이유**: CPython의 메모리 관리(Reference Counting)가 Thread-safe하지 않기 때문입니다.
- **영향**:
    - **I/O Bound**: 대기 시간이 길어 GIL을 해제하므로 멀티스레딩 효과가 큼.
    - **CPU Bound**: 작업을 교대할 때 GIL을 획득/해제하는 오버헤드 때문에 싱글스레드보다 느려질 수 있음.
    - **해결**: `multiprocessing` 모듈을 사용하여 프로세스별 독립된 인터프리터와 GIL을 소유하게 함.

### 📦 메모리 절약: `__slots__`
- 클래스에 `__slots__`를 정의하면, 각 인스턴스는 `__dict__` (가변 딕셔너리)를 생성하지 않고 고정된 메모리 공간만 사용합니다.
- 수백만 개의 객체를 생성할 때 메모리 사용량을 비약적으로 줄일 수 있습니다.

### ♻ 가비지 컬렉션 (GC)
- **Reference Counting**: 참조 횟수가 0이 되면 즉시 해제. (기본 메커니즘)
- **Generational GC**: 순환 참조(Circular Reference)를 해결하기 위해 0, 1, 2세대로 나누어 관리. 오래 살아남은 객체일수록 드물게 검사합니다.

---

## 5. 동시성 제어: Asyncio와 제너레이터
### 🧊 Generator와 Iterator
- **Iterable**: `__iter__`를 가진 객체.
- **Iterator**: `__next__`를 통해 상태를 유지하며 순회하는 객체.
- **Generator**: `yield`를 사용하여 실행을 일시 중단하고 값을 반환하는 함수. 호출될 때마다 이전 상태를 복구합니다.

### ⚡ Asyncio (비동기 I/O)
- **Event Loop**: 하나의 스레드 내에서 여러 작업을 스케줄링하는 엔진입니다.
- **Coroutine**: `async def`로 정의되며, `await`를 통해 I/O 작업 동안 제어권을 이벤트 루프에 넘깁니다.
- **구동 원리**: 작업이 멈춘 동안(Blocking) 다른 코루틴을 실행하여 단일 스레드에서도 높은 동시성을 확보합니다.

---

## 6. 고급 파이썬 기법
### 🎭 Decorator (데코레이터)
- 클로저(Closure)를 활용하여 함수의 기능을 확장하는 문법 설탕(Syntactic Sugar)입니다.
- `functools.wraps`를 사용하면 데코레이팅된 함수의 메타데이터(이름, docstring 등)를 보존할 수 있습니다.

### 🧪 Context Manager (`with` 문)
- `__enter__`와 `__exit__` 메서드를 구현하여 자원의 획득과 해제를 안전하게 보장합니다.
- 예: 파일 핸들러, DB 연결, 락(Lock) 획득.

---

## 7. 자료구조 심화
- **List**: Dynamic Array 구조. 삽입/삭제($O(n)$)는 느리지만 인덱스 접근($O(1)$)은 빠름.
- **Dict**: Hash Table 구조. 키 조회 평균 $O(1)$. 파이썬 3.7+부터 입력 순서가 보장됨.
- **Set**: 중복을 허용하지 않는 Hash Table. 집합 연산에 최적화.

이상의 내용을 숙지하면 Python 기초 단원의 모든 hard 난이도 문항(메타클래스, GIL, Descriptor 등)을 완벽히 해결할 수 있습니다.