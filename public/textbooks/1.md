# 📘 [학습 노트] 교재 1. Python 기초 (Foundation to Ultimate Deep Dive)

이 교재는 파이썬의 핵심 철학부터 입문 수준의 문법, 그리고 메타프로그래밍과 메모리 관리 등 최상위 지식까지 720개 전 문항을 완벽히 커버하도록 집필되었습니다.

---

## 1. 파이썬의 철학과 환경 설정
### 🐍 설계 철학
- **Duck Typing**: 객체의 실제 타입보다 그 객체가 수행할 수 있는 메서드와 속성이 중요합니다.
- **EAFP (Easier to Ask for Forgiveness than Permission)**: 먼저 실행하고 예외를 처리하는 방식을 선호합니다. (`try-except`)
- **First-class Object**: 파이썬의 모든 것(함수, 클래스 포함)은 객체이며, 변수에 할당하거나 인자로 전달할 수 있습니다.

### 🛠 실무 환경 설정
- **PEP 8**: 파이썬 공식 스타일 가이드 (4칸 들여쓰기, `snake_case` 권장).
- **가상환경**: 프로젝트별 독립된 환경 보장을 위해 `venv` 또는 `conda` 사용.
- **`if __name__ == "__main__":`**: 모듈이 임포트될 때와 직접 실행될 때를 구분하는 필수 구조입니다.

---

## 2. 자료형과 메모리 관리 매커니즘
### 📦 Mutable(가변) vs Immutable(불변)
- **Immutable**: `int`, `float`, `str`, `tuple`, `bool`. 값을 수정하면 새로운 메모리 공간에 객체가 생성됩니다.
- **Mutable**: `list`, `dict`, `set`. 기존 메모리 주소를 유지한 채 내부 내용을 수정할 수 있습니다.

```python
# Immutable: ID가 바뀜 (새 객체 생성)
s = "A"
print(id(s))
s += "B"
print(id(s))

# Mutable: ID가 동일 (원본 수정)
l = [1]
print(id(l))
l.append(2)
print(id(l))
```

### 🧬 효율적 자료구조 (High Performance)
- **List**: 다이내믹 어레이 구조. 인덱스 $O(1)$, 중간 삽입/삭제 $O(n)$.
- **Dict**: 해시 테이블 기반. 조회 평균 $O(1)$. 3.7+ 버전부터 입력 순서가 유지됩니다.
- **Set**: 중복 없는 해시 테이블. 집합 연산($\cap, \cup$)에 최적화.

---

## 3. 제어문과 함수 스코프
### 🔄 고급 제어 기법
- **Walrus Operator (`:=`)**: "할당 및 반환"을 동시에 수행하여 코드 길이를 줄입니다.
- **List Comprehension**: `[x**2 for x in data if x > 0]`와 같이 가독성과 성능을 동시에 잡는 문법입니다.
- **Generator**: `yield`를 사용해 객체 전체를 메모리에 올리지 않고 필요할 때마다 값을 생성(Lazy Evaluation)합니다.

### 🌐 스코프 (LEGB 규칙)
변수를 찾는 순서는 **L**ocal(지역) → **E**nclosing(상위 함수) → **G**lobal(전역) → **B**uilt-in(내장) 순입니다. 부모 스코프 변수를 수정하려면 `global` 또는 `nonlocal` 선언이 필요합니다.

---

## 4. 메타프로그래밍: 클래스를 만드는 엔진
### 🏗 Metaclass와 `type`
- **Metaclass**: 클래스 객체를 생성하는 클래스입니다. 모든 클래스의 부모(Metaclass)는 `type`입니다.
- **동작**: 클래스 정의 시점에 `__new__`가 호출되어 메모리를 할당하고, `__init__`이 클래스 객체를 초기화합니다.

### 📜 Descriptor Protocol
속성 접근(`obj.attr`)의 우선순위를 결정하는 핵심 프로토콜입니다.
- **Data Descriptor**: `__set__`이나 `__delete__`가 구현된 경우. 인스턴스 딕셔너리(`__dict__`)보다 우선순위가 높습니다.
- **Non-data Descriptor**: `__get__`만 구현된 경우(예: 일반 메서드). 우선순위가 낮습니다.

---

## 5. 다중 상속과 MRO (C3 알고리즘)
- **C3 Linearization**: 다중 상속 시 메서드 충돌을 방지하기 위한 선형화 규칙입니다.
- **`super()`**: 단순한 부모가 아니라, MRO(Method Resolution Order) 상의 **다음(next)** 클래스를 찾아 실행합니다. 다이아몬드 상속 구조에서 중복 호출을 방지하는 핵심 장치입니다.

---

## 6. 하이엔드 성능 최적화 (Internal)
### 🔒 GIL (Global Interpreter Lock)
- 한 번에 하나의 스레드만 파이썬 바이트코드를 실행하게 잠그는 뮤텍스입니다.
- **I/O Bound**: 대기 시간에 GIL을 해제하여 멀티스레딩이 효과적입니다.
- **CPU Bound**: 멀티프로세싱(`multiprocessing`)을 통해 프로세스별 독립된 GIL을 가져야 성능이 개선됩니다.

### 📦 메모리 절약과 GC
- **`__slots__`**: 클래스 인스턴스에 `__dict__` 생성을 억제하여 고정된 메모리 슬롯만 사용하게 합니다. 수백만 개 객체 생성 시 메모리를 획기적으로 아낍니다.
- **Generational GC**: 순환 참조 문제를 해결하기 위해 세대별(0~2세대) 가비지 컬렉션을 수행합니다.

---

## 7. 동시성과 고급 프로그래밍
- **Asyncio**: 이벤트 루프 기반 비동기 프로그래밍. `async def`와 `await`를 통해 단일 스레드에서도 수천 개의 동시 연결을 처리합니다.
- **Decorator**: 함수의 기능을 확장하는 클로저 패턴. `functools.wraps`를 사용하여 원래 함수의 메타데이터를 보존해야 합니다.
- **Context Manager**: `with` 문을 구현하는 `__enter__`, `__exit__`. 자원 해제를 보장하는 안전한 방식입니다.

이상의 내용을 완벽히 이해하면 Python 기초 단원의 모든 난이도 문항을 풀 수 있습니다.