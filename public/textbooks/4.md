# 📘 [대백과] 교재 4. 프롬프트 엔지니어링 (The Prompt Engineering Encyclopedia)

이 교재는 단순히 모델에게 말을 거는 법을 넘어, 결과를 구조적으로 제어하고 시스템을 방어하며 어플리케이션에 통합하는 **120개 문항**의 모든 정답 근거를 다룹니다.

---

## 1. 프롬프트 제어의 심리학 (Control & Psychology)
### 🎭 페르소나와 지시 전략
- **Persona Injection**: "당신은 20년 차 시니어 개발자입니다"와 같이 역할을 부여하면, 모델이 해당 도메인의 전문 어휘와 사고방식을 채택합니다. 동적으로 사용자 데이터를 주입하는 **Dynamic Persona**는 개인화 경험의 핵심입니다.
- **Sandwich Defense**: 사용자 입력 앞뒤로 지시사항을 배치하여 악의적 주입(Injection)을 무력화하는 기법입니다. (지시 + 데이터 + 지시)
- **Descriptive Prompting**: "그림을 그리듯 상세히 묘사해줘"라고 하면 토큰 생성 확률 분포가 구체적인 형용사 쪽으로 이동합니다.

### 🔢 제약 조건 설정 (Constraints)
- **Numerical Constraints**: "3가지 근거를 대라"와 같이 수치적 제약을 주면 모델이 할루시네이션을 멈추고 논리를 구조화하려는 경향이 강해집니다.
- **Negative Constraints**: "하지 말 것"을 명시하는 것보다 "할 것"을 명시하는 것이 훨씬 효과적입니다. 부정 명령은 모델의 주의를 오히려 그 단어에 집중시킵니다.

---

## 2. 고급 추론과 최적화 (Advanced Reasoning)
### 🧠 Chain-of-Thought (CoT) 심화
- **High Temperature Risk**: CoT를 쓸 때 온도를 높게($>1.0$) 잡으면, 논리 단계 중 하나만 삐끗해도 뒤따르는 모든 추론이 붕괴되는 **Error Cascade**가 발생합니다. CoT는 **Greedy Search ($T \approx 0$)**와 궁합이 맞습니다.
- **Tree of Thoughts (ToT)**: 하나의 경로가 아니라 여러 가지 가능성을 가지치기하듯 탐색하고 평가(Evaluate)하여 최약을 선택하는 기법입니다.

### 🔄 자기 교정 (Self-Correction)
- **Self-Evaluation**: 답변 생성 후 "0~10점으로 스스로 채점해봐"라고 시키고, 점수가 낮으면 다시 생성하게 합니다.
- **Chain-of-Verification (CoVe)**: 생성된 팩트를 검증하는 질문을 스스로 만들고 답변하여 모순을 찾아냅니다.
- **Self-Healing**: 도구 사용 중 에러가 발생하면, 에러 메시지를 다시 프롬프트에 넣어 모델이 스스로 인자를 수정하고 재시도하게 만드는 루프입니다.

---

## 3. 구조화된 출력 (Structured Output)
### 📄 JSON과 Pydantic
LLM을 시스템 파이프라인에 넣으려면 자연어가 아닌 구조화된 데이터가 필요합니다.
- **Pydantic**: 파이썬의 타입 힌트를 이용하여 데이터 스키마를 정의합니다. `Field(description="...")`를 통해 각 필드의 의미를 모델에게 전달합니다.
- **Output Parsers**:
    - `JsonOutputParser`: 모델의 출력을 `dict`로 변환합니다. `get_format_instructions()` 메서드로 프롬프트에 JSON 스키마 지침을 자동 삽입할 수 있습니다.

---

## 4. LangChain 구현 (Implementation)
### 🔗 LCEL (LangChain Expression Language) 기본
- **`chain = prompt | model | parser`**: 유닉스 파이프라인철머 연결합니다.
- **`invoke(input_dict)`**: 체인을 동기적으로 실행합니다. 입력은 주로 딕셔너리 형태입니다.
- **`ainvoke`**: `await chain.ainvoke(...)`로 비동기 실행합니다. 대량 요청 처리에 필수입니다.

### 🧬 고급 Runnable 객체
- **`RunnablePassthrough.assign`**: 기존 입력 데이터를 유지하면서 새로운 키-값(예: 검색 결과, 분석 결과)을 추가하여 다음 단계로 넘깁니다.
- **`RunnableParallel`**: 여러 체인을 동시에 실행하여 결과를 하나의 딕셔너리로 병합합니다. (`batch` 아님)
- **`partial`**: 프롬프트 템플릿의 일부 변수(예: 페르소나, 날짜)를 미리 고정하여 재사용 가능한 함수처럼 만듭니다.

---

## 5. 보안과 운영 (Security & Ops)
### ⚔️ 공격과 방어
- **Prompt Injection**: "이전 지시 무시해" 등의 공격. 입력값을 XML 태그(`<user_input>`)로 감싸 격리하거나, **Guardrails** 라이브러리를 통해 입출력을 필터링하여 방어합니다.
- **Hint Overload**: 프롬프트에 너무 많은 예시나 지침을 넣으면 모델의 성능이 오히려 떨어지는 현상입니다.
- **Unlearning**: "잊어버려"라는 지시는 완벽하지 않습니다. 모델의 가중치에 각인된 정보는 삭제하기 어렵습니다.

### ⚙️ PromptOps
- **버전 관리**: 프롬프트도 코드처럼 Git으로 관리하고 CI/CD 테스트를 통과해야 배포되도록 파이프라인을 구축합니다.
- **Prompt Caching**: 동일한 입력에 대한 결과를 캐싱하여 API 비용과 지연 시간을 절약합니다.

이 교재는 프롬프트 엔지니어링 단원의 120개 문항을 완벽히 커버합니다.