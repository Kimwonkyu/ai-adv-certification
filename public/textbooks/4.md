# 📘 [학습 노트] 교재 4. 프롬프트 엔지니어링 (Logic & Security)

이 교재는 결과물을 정교하게 제어하기 위한 추론 유도 기법부터 에이전트 설계, 그리고 상용 서비스 수준의 프롬프트 보안 전략을 다룹니다.

---

## 1. 프롬프트 엔지니어링의 수리적 배경
단순한 '말재주'가 아닌, 모델의 어텐션(Attention)을 특정 정보에 집중시키고 자기회귀적 생성 경로를 논리적으로 유도하는 과정입니다.

### 🧠 추론 유도 기법 (Reasoning Strategies)
- **CoT (Chain-of-Thought)**: 
    - **Zero-shot CoT**: "단계별로 생각해보자"라는 트리거 문구만으로 모델의 잠재적 추론 능력을 활성화합니다.
    - **Few-shot CoT**: 정답뿐만 아니라 '풀이 과정'이 포함된 예시를 제공하여 정답률을 극적으로 높입니다.
- **Self-Consistency (자기 일관성)**: 동일한 문제에 대해 여러 추론 경로를 생성하게 하여, 다수결(Majority Vote)로 최종 답을 도출합니다. 논리적 오류를 검증하는 효과가 탁월합니다.
- **Least-to-Most**: 복잡한 문제를 하위 문제들로 분해하고 순차적으로 해결하는 전략입니다.

---

## 2. 에이전트와 ReAct 프레임워크
에이전트는 LLM을 '두뇌'로 삼아 외부 도구를 사용하며 자율적으로 과업을 완수하는 시스템입니다.

### 🔄 ReAct (Reasoning + Acting)
- **작동 루프**: `Thought` (상태 분석 및 계획) -> `Action` (도구 선택 및 실행) -> `Observation` (도구 실행 결과 관찰) -> `Thought` (결과 바탕으로 다음 단계 결정).
- **Tool Use (Function Calling)**:
    - 모델은 실제 코드를 실행하는 대신, 실행할 함수의 이름과 인자가 포함된 **구조화된 데이터 (JSON)**를 생성합니다.
    - 시스템(애플리케이션)이 이 JSON을 받아 실제 연산을 수행하고 결과를 다시 모델에게 문맥으로 전달합니다.

---

## 3. 프롬프트 프로그래밍: DSPy
기존의 수동적 프롬프트 작성을 '프로그래밍' 단계로 끌어올린 프레임워크입니다.
- **구조**: **Signatures**(입출력 정의), **Modules**(작업 논리), **Teleprompters**(프롬프트 최적화기).
- **특징**: 프롬프트를 딥러닝의 가중치처럼 최적화할 수 있으며, 모델이 바뀌어도 시그니처만 유지하면 최적의 프롬프트를 자동 생성(Compile)합니다.

---

## 4. 프롬프트 보안 (Prompt Engineering Defense)
LLM 서비스의 안전성을 확보하기 위한 필수 전략입니다.

### ⚔️ 공격 패턴
- **Prompt Injection**: 사용자의 입력 데이터가 시스템의 원래 지시사항을 덮어써서 악의적인 행동을 유도하는 것 (예: "이전 지시는 모두 잊고...").
- **Indirect Injection**: 외부 문서(RAG 검색 결과 등)에 숨겨진 명령어가 모델을 오염시키는 공격.
- **Jailbreaking**: 모델의 안전 가드레일을 우회하여 금지된 정보를 생성하게 하는 기법 (예: DAN 모드).
- **System Prompt Leaking**: 시스템의 기밀 지시사항이나 초기 설정을 출력하게 유도하는 공격.

### 🛡 방어 전략
- **XML Delimiters**: 사용자의 입력 데이터 앞뒤를 `<user_input>`과 같이 명확한 태그로 감싸 지시사항과 데이터를 엄격히 분리합니다.
- **Post-Instruction Injection**: 지시사항을 사용자 입력 바로 뒤에 다시 한 번 반복하여 최신 정보를 우선시하는 모델의 특성(Recency Bias)을 활용합니다.
- **Verification Chain**: 모델의 출력을 다른 보안 모델이 검증하는 필터링 레이어를 구축합니다.

---

## 5. LCEL (LangChain Expression Language) 활용
체인 설계를 추상화하여 확장성을 높이는 선언적 프로그래밍 방식입니다.

### 🧬 심화 Runnable 객체
- **`RunnableParallel`**: 서로 다른 검색기나 모델의 결과를 병렬로 취합할 때 사용합니다.
- **`RunnablePassthrough`**: 데이터를 가공 없이 다음 단계로 넘기거나, 문맥에 새로운 데이터를 주입할 때 활용합니다.
- **`with_fallbacks`**: 특정 모델의 API 장애 시 즉시 대체 모델로 전환하는 견고한 시스템을 보장합니다.

### 📊 평가 체계: LLM-as-a-Judge
- **MT-Bench / HumanEval**: 정성적 평가를 자동화하기 위해 더 강력한 지능을 가진 모델(예: GPT-4o)을 심판(Judge)으로 세워 답변의 논리성, 안전성, 정확성을 수치화합니다.