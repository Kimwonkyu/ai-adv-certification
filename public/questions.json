[
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1001",
    "question": "파이썬이 '인터프리터 언어'라는 특징에 대한 설명으로 옳은 것은?",
    "options": [
      "소스 코드를 한 줄씩 읽어 즉시 실행한다.",
      "전체 코드를 기계어로 먼저 변환한 후 실행한다.",
      "C++보다 실행 속도가 월등히 빠르다.",
      "컴파일 시점에 모든 문법 오류를 잡아낸다.",
      "웹 브라우저에서만 동작하는 전용 언어이다."
    ],
    "answer": "소스 코드를 한 줄씩 읽어 즉시 실행한다.",
    "why": "인터프리터 언어는 컴파일 단계 없이 소스 코드를 한 줄씩 해석하며 즉시 실행하는 특징이 있습니다.",
    "hint": "한 줄씩 실행"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1002",
    "question": "파이썬의 '동적 타이핑(Dynamic Typing)'에 대한 설명으로 올바른 것은?",
    "options": [
      "변수 선언 시 자료형(int, str 등)을 명시하지 않아도 된다.",
      "변수 선언 후에 자료형을 절대 바꿀 수 없다.",
      "Java나 C 언어와 동일하게 변수 타입을 고정한다.",
      "프로그램 실행 전에 변수 타입을 모두 확정한다.",
      "메모리를 수동으로 할당하고 해제해야 한다."
    ],
    "answer": "변수 선언 시 자료형(int, str 등)을 명시하지 않아도 된다.",
    "why": "파이썬은 실행 중에 할당되는 값에 따라 변수의 타입이 결정되는 동적 타이핑을 지원합니다.",
    "hint": "자료형 선언 유무"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1003",
    "question": "파이썬의 장점으로 보기 어려운 것은?",
    "options": [
      "간결하고 가독성이 높은 문법을 제공한다.",
      "AI, 데이터 분석 등 방대한 라이브러리를 보유하고 있다.",
      "기계어에 가까워 저수준 시스템 제어에 최적화되어 있다.",
      "다양한 운영체제에서 동일한 코드를 실행할 수 있다.",
      "커뮤니티가 활성화되어 있어 정보를 얻기 쉽다."
    ],
    "answer": "기계어에 가까워 저수준 시스템 제어에 최적화되어 있다.",
    "why": "파이썬은 고수준 언어로 생산성이 높지만, 하드웨어 제어와 같은 저수준 제어에는 C/C++가 더 적합합니다.",
    "hint": "고수준 vs 저수준"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1004",
    "question": "VS Code(Visual Studio Code)를 파이썬 개발에 사용할 때의 특징으로 적절한 것은?",
    "options": [
      "파이썬 전용으로만 개발된 도구이다.",
      "확장 기능(Extension)을 통해 파이썬 개발 편의성을 높일 수 있다.",
      "유료 결제를 해야만 정상적인 사용이 가능하다.",
      "코드 편집 기능만 있고 디버깅 기능은 지원하지 않는다.",
      "반드시 관리자 권한으로만 실행해야 코드가 작성된다."
    ],
    "answer": "확장 기능(Extension)을 통해 파이썬 개발 편의성을 높일 수 있다.",
    "why": "VS Code는 다양한 확장 프로그램을 설치하여 파이썬 린팅, 디버깅, 포맷팅 기능을 강화할 수 있습니다.",
    "hint": "확장성"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1005",
    "question": "Jupyter Notebook(.ipynb) 파일의 주요 특징이 아닌 것은?",
    "options": [
      "코드와 실행 결과, 텍스트(Markdown)를 한 서류에 담을 수 있다.",
      "데이터 분석 및 학습 기록용으로 널리 쓰인다.",
      "전체 코드를 한꺼번에 컴파일해야만 결과를 볼 수 있다.",
      "셀(Cell) 단위로 코드를 실행할 수 있다.",
      "웹 브라우저 환경에서 시각적으로 편리하게 사용 가능하다."
    ],
    "answer": "전체 코드를 한꺼번에 컴파일해야만 결과를 볼 수 있다.",
    "why": "쥬피터 노트북은 인터랙티브한 환경으로, 코드를 셀 단위로 나누어 부분 실행이 가능합니다.",
    "hint": "셀 단위 실행"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1006",
    "question": "파이썬의 '강력한 생태계'와 관련된 라이브러리 연결이 틀린 것은?",
    "options": [
      "데이터 분석 - Pandas",
      "AI/딥러닝 - PyTorch",
      "웹 개발 - Django",
      "시각화 - Matplotlib",
      "운영체제 커널 개발 - TensorFlow"
    ],
    "answer": "운영체제 커널 개발 - TensorFlow",
    "why": "TensorFlow는 딥러닝 라이브러리입니다. 커널 개발은 주로 C나 Assembly가 쓰입니다.",
    "hint": "라이브러리 용도"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1007",
    "question": "파이썬 코드를 실행하는 가장 기본적인 방식은?",
    "options": [
      "터미널에서 python 파일명.py 명령어를 입력한다.",
      "반드시 웹 서버에 파일을 업로드해야 실행된다.",
      "메모장에서 작성하고 .txt로 저장하면 자동 실행된다.",
      "클라우드 환경이 아니면 일반 PC에서는 실행이 불가능하다.",
      "컴파일러를 통해 .exe 파일을 먼저 생성해야 한다."
    ],
    "answer": "터미널에서 python 파일명.py 명령어를 입력한다.",
    "why": "파이썬 인터프리터를 통해 직접 소스 파일을 실행하는 것이 기본입니다.",
    "hint": "실행 방법"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1008",
    "question": "다음 중 파이썬 설치와 관련하여 '환경 변수(Path) 추가'를 하는 주된 이유는?",
    "options": [
      "어느 경로에서든 python 명령어를 사용할 수 있게 하기 위해",
      "파이썬의 실행 속도를 2배 이상 높이기 위해",
      "파이썬 설치 용량을 줄여 하드디스크 공간을 확보하기 위해",
      "파이썬 코드를 암호화하여 보안을 강화하기 위해",
      "파이썬의 기본 배경 테마를 다크 모드로 설정하기 위해"
    ],
    "answer": "어느 경로에서든 python 명령어를 사용할 수 있게 하기 위해",
    "why": "Path 설정은 운영체제가 실행 파일을 찾는 위치를 지정해주는 작업입니다.",
    "hint": "환경 변수 설정"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1009",
    "question": "파이썬 개발 시 가상 환경을 사용하는 주된 목적은?",
    "options": [
      "프로젝트마다 독립적인 라이브러리 버전을 관리하기 위해",
      "인터넷 연결 없이도 코드가 실행되도록 하기 위해",
      "컴퓨터의 메모리(RAM) 용량을 확장하기 위해",
      "파이썬 버전 업그레이드를 아예 막기 위해",
      "동동 실행되는 멀웨어(Malware)를 잡기 위해"
    ],
    "answer": "프로젝트마다 독립적인 라이브러리 버전을 관리하기 위해",
    "why": "가상 환경은 프로젝트별로 필요한 패키지의 의존성을 독립적으로 구성하게 해줍니다.",
    "hint": "가상 환경의 의의"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1010",
    "question": "파이썬의 철학(The Zen of Python) 중 하나인 'Beautiful is better than ugly'가 강조하는 가치는?",
    "options": [
      "성능 최적화",
      "코드의 가독성과 명료함",
      "화려한 UI 디자인",
      "최신 기술의 도입",
      "네트워크 통신 보안"
    ],
    "answer": "코드의 가독성과 명료함",
    "why": "파이썬은 깔끔하고 명확한 코드를 작성하는 것을 지향합니다.",
    "hint": "파이썬 철학"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1011",
    "question": "다음 중 파이썬의 수치형(Numeric) 자료형에 대한 설명으로 옳은 것은?",
    "options": [
      "int는 정수, float는 실수를 의미한다.",
      "실수형 데이터는 뒤에 반드시 f를 붙여야 한다.",
      "10.0은 int 자료형으로 처리된다.",
      "정수형 데이터는 최대 64비트까지만 저장 가능하다.",
      "파이썬에는 수치형 자료형이 단 하나(number)만 존재한다."
    ],
    "answer": "int는 정수, float는 실수를 의미한다.",
    "why": "파이썬은 정수는 int, 소수점이 포함된 실수는 float로 관리합니다.",
    "hint": "정수와 실수의 구분"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1012",
    "question": "문자열(str) 자료형을 정의하는 올바른 방법이 아닌 것은?",
    "options": [
      "'Hello'",
      "\"Python\"",
      "\"\"\"Triple Quotes\"\"\"",
      "'Start with quote or double quote'",
      "[List Style String]"
    ],
    "answer": "[List Style String]",
    "why": "문자열은 따옴표나 삼중 따옴표로 감싸야 하며, []는 리스트를 의미합니다.",
    "hint": "문자열 선언"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1013",
    "question": "불리언(bool) 자료형의 두 가지 값으로 옳은 것은?",
    "options": [
      "True, False",
      "T, F",
      "yes, no",
      "1, 0 (자료형 이름 기준)",
      "Real, Fake"
    ],
    "answer": "True, False",
    "why": "파이썬의 불리언 값은 첫 글자가 대문자인 True와 False입니다.",
    "hint": "Boolean 값"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1014",
    "question": "리스트(List)의 특징으로 볼 수 없는 것은?",
    "options": [
      "대괄호([])를 사용하여 정의한다.",
      "순서가 있으며, 인덱스를 통해 값에 접근할 수 있다.",
      "한번 생성되면 요소를 추가하거나 삭제할 수 없다.",
      "다양한 자료형의 데이터를 한 리스트에 담을 수 있다.",
      "수정 가능한(Mutable) 자료형이다."
    ],
    "answer": "한번 생성되면 요소를 추가하거나 삭제할 수 없다.",
    "why": "리스트는 가변(Mutable) 객체로, append, remove 등을 통해 요소를 자유롭게 변경할 수 있습니다.",
    "hint": "리스트 특성"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1015",
    "question": "튜플(Tuple)과 리스트(List)의 가장 큰 차이점은?",
    "options": [
      "튜플은 소괄호(())를 사용하고 수정이 불가능(Immutable)하다.",
      "리스트는 중복된 값을 허용하지 않는다.",
      "튜플은 오직 숫자형 데이터만 담을 수 있다.",
      "리스트는 인덱싱이 불가능하다.",
      "튜플은 요소를 추가하는 append() 메서드가 있다."
    ],
    "answer": "튜플은 소괄호(())를 사용하고 수정이 불가능(Immutable)하다.",
    "why": "튜플은 생성 후 값을 변경할 수 없는 성질을 가집니다.",
    "hint": "튜플 vs 리스트"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1016",
    "question": "딕셔너리(Dictionary) 자료형의 핵심 구조는?",
    "options": [
      "Value들의 나열",
      "Index(번호)와 Value의 쌍",
      "Key와 Value의 쌍",
      "오직 문자열만 저장하는 행렬",
      "순서가 고정된 튜플들의 합"
    ],
    "answer": "Key와 Value의 쌍",
    "why": "딕셔너리는 {Key: Value} 형태의 구조를 갖는 해시 맵 자료형입니다.",
    "hint": "딕셔너리 구조"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1017",
    "question": "딕셔너리에서 특정 값을 조회할 때의 시간 복잡도(평균)는?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)",
      "순서에 따라 다르다"
    ],
    "answer": "O(1)",
    "why": "딕셔너리는 해시 테이블 구조를 사용하여 매우 빠르게 값을 조회할 수 있습니다.",
    "hint": "딕셔너리 성능"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1018",
    "question": "리스트 `a = [10, 20, 30]`에서 `20`을 꺼내기 위한 인덱싱은?",
    "options": [
      "a[0]",
      "a[1]",
      "a[2]",
      "a[3]",
      "a[-0]"
    ],
    "answer": "a[1]",
    "why": "인덱스는 0부터 시작하므로 두 번째 요소는 1입니다.",
    "hint": "인덱싱"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1019",
    "question": "리스트 `arr = [1, 2, 3]`의 맨 끝에 '4'를 추가하는 명령어는?",
    "options": [
      "arr.add(4)",
      "arr.insert(4)",
      "arr.push(4)",
      "arr.append(4)",
      "arr.extend(4)"
    ],
    "answer": "arr.append(4)",
    "why": "append() 메서드는 리스트의 마지막에 요소를 추가합니다.",
    "hint": "리스트 추가"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1020",
    "question": "`s = 'Python'` 일 때, `s[0:2]`의 결과는?",
    "options": [
      "'Py'",
      "'Pyt'",
      "'yht'",
      "'Python'",
      "'o'"
    ],
    "answer": "'Py'",
    "why": "슬라이싱 [start:end]에서 end 인덱스는 포함되지 않습니다.",
    "hint": "슬라이싱"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1021",
    "question": "집합(Set) 자료형의 가장 두드러진 특징은?",
    "options": [
      "순서가 보장되며 인덱스 조회가 가능하다.",
      "중복된 요소를 허용하지 않는다.",
      "반드시 정수 데이터만 포함해야 한다.",
      "값의 수정이 절대 불가능하다.",
      "대괄호([])로 생성한다."
    ],
    "answer": "중복된 요소를 허용하지 않는다.",
    "why": "Set은 중복 제거를 주 목적으로 하며 순서가 없습니다.",
    "hint": "Set 특징"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1022",
    "question": "다음 중 불변(Immutable) 자료형이 아닌 것은?",
    "options": [
      "정수(int)",
      "문자열(str)",
      "튜플(tuple)",
      "리스트(list)",
      "불리언(bool)"
    ],
    "answer": "리스트(list)",
    "why": "리스트, 딕셔너리, 집합은 가변(Mutable)이며 나머지는 주로 불변입니다.",
    "hint": "가변/불변"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1023",
    "question": "변수 이름 규칙으로 올바르지 않은 것은?",
    "options": [
      "숫자로 시작할 수 없다.",
      "특수문자는 언더바(_)만 사용 가능하다.",
      "예약어(if, for, def 등)는 변수명으로 쓸 수 없다.",
      "공백(Space)을 포함할 수 있다.",
      "대소문자를 구분한다."
    ],
    "answer": "공백(Space)을 포함할 수 있다.",
    "why": "변수명 내부에는 공백을 넣을 수 없으며 보통 snake_case를 씁니다.",
    "hint": "명명 규칙"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1024",
    "question": "`3 ** 2` 의 실행 결과는?",
    "options": [
      "6",
      "9",
      "5",
      "1",
      "1/9"
    ],
    "answer": "9",
    "why": "** 연산자는 거듭제곱을 의미합니다.",
    "hint": "산술 연산자"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1025",
    "question": "`10 // 3` 의 실행 결과는?",
    "options": [
      "3.333...",
      "3",
      "1",
      "0.333...",
      "9"
    ],
    "answer": "3",
    "why": "// 연산자는 나눗셈의 '몫'을 구하는 정수 나눗셈 연산자입니다.",
    "hint": "몫 연산"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1026",
    "question": "`10 % 3` 의 실행 결과는?",
    "options": [
      "3",
      "1",
      "0",
      "1.5",
      "10"
    ],
    "answer": "1",
    "why": "% 연산자는 나눗셈 후의 '나머지'를 구하는 연산자입니다.",
    "hint": "나머지 연산"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1027",
    "question": "문자열 '100'을 숫자 100으로 바꾸는 형변환 함수는?",
    "options": [
      "str()",
      "float()",
      "int()",
      "bool()",
      "list()"
    ],
    "answer": "int()",
    "why": "int() 함수는 숫자 형태의 문자열을 정수로 변환합니다.",
    "hint": "형변환"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1028",
    "question": "리스트를 정렬하는 메서드는?",
    "options": [
      "sort()",
      "order()",
      "arrange()",
      "align()",
      "shuffle()"
    ],
    "answer": "sort()",
    "why": "sort() 메서드는 원본 리스트의 요소를 크기순으로 정렬합니다.",
    "hint": "정렬"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1029",
    "question": "딕셔너리 `d = {'a': 1}` 에서 1을 가져오기 위한 코드는?",
    "options": [
      "d[0]",
      "d.get(0)",
      "d['a']",
      "d.values()",
      "d.a"
    ],
    "answer": "d['a']",
    "why": "딕셔너리는 인덱스가 아닌 Key를 사용하여 값을 조회합니다.",
    "hint": "Key 조회"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1030",
    "question": "`len([1, 2, 3, 4, 5])` 의 결과값은?",
    "options": [
      "4",
      "5",
      "6",
      "0",
      "15"
    ],
    "answer": "5",
    "why": "len() 함수는 컨테이너 내부 요소의 개수를 반환합니다.",
    "hint": "길이 확인"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1031",
    "question": "파이썬의 if문에서 조건절 뒤에 반드시 붙여야 하는 문자는?",
    "options": [
      "; (세미콜론)",
      ": (콜론)",
      "{ (중괄호)",
      ") (닫는 소괄호)",
      ", (컴마)"
    ],
    "answer": ": (콜론)",
    "why": "파이썬의 제어문과 함수 정의 뒤에는 항상 콜론(:)이 와야 합니다.",
    "hint": "문법 규칙"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1032",
    "question": "if-else 구조에서 중간에 다른 조건을 추가할 때 쓰는 키워드는?",
    "options": [
      "else if",
      "elseif",
      "elif",
      "case",
      "when"
    ],
    "answer": "elif",
    "why": "파이썬은 else if를 줄인 elif를 사용합니다.",
    "hint": "다중 조건"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1033",
    "question": "반복문 루프를 즉시 완전히 빠져나가게 하는 키워드는?",
    "options": [
      "pass",
      "continue",
      "break",
      "return",
      "stop"
    ],
    "answer": "break",
    "why": "break 문은 가장 가까운 루프를 종료시킵니다.",
    "hint": "루프 탈출"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1034",
    "question": "현재 반복을 중단하고 다음 반복 차례로 바로 넘어가는 키워드는?",
    "options": [
      "pass",
      "continue",
      "break",
      "jump",
      "skip"
    ],
    "answer": "continue",
    "why": "continue 문은 루프의 나머지 코드를 건너뛰고 다음 반복으로 진행합니다.",
    "hint": "반복 건너뛰기"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1035",
    "question": "아무 일도 하지 않고 문법적 위치만 채우고 싶을 때 쓰는 키워드는?",
    "options": [
      "null",
      "none",
      "empty",
      "pass",
      "void"
    ],
    "answer": "pass",
    "why": "pass 문은 구조적으로 문장이 필요하지만 수행할 작업이 없을 때 씁니다.",
    "hint": "pass 의도"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1036",
    "question": "`range(5)` 함수가 생성하는 숫자의 범위는?",
    "options": [
      "1, 2, 3, 4, 5",
      "0, 1, 2, 3, 4",
      "0, 1, 2, 3, 4, 5",
      "1, 2, 3, 4",
      "기본으로 생성되지 않고 에러가 난다"
    ],
    "answer": "0, 1, 2, 3, 4",
    "why": "range(n)은 0부터 n-1까지의 정수를 생성합니다.",
    "hint": "range 범위"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1037",
    "question": "`range(1, 10, 2)` 에 의해 생성되는 홀수 리스트는?",
    "options": [
      "[1, 3, 5, 7, 9]",
      "[1, 2, 3, 4, 5, 6, 7, 8, 9]",
      "[2, 4, 6, 8]",
      "[1, 3, 5, 7, 9, 10]",
      "[3, 5, 7, 9]"
    ],
    "answer": "[1, 3, 5, 7, 9]",
    "why": "range(start, end, step)에서 step은 증가값을 의미합니다.",
    "hint": "range 간격"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1038",
    "question": "데이터가 비어있을 때 ([], '', 0 등) 불리언 판정 결과는?",
    "options": [
      "True",
      "False",
      "None",
      "Error",
      "0 (자료형 유지)"
    ],
    "answer": "False",
    "why": "파이썬에서 비어있는 컨테이너나 수치 0은 False로 간주됩니다.",
    "hint": "암시적 불리언"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1039",
    "question": "`for x in [1, 2, 3]:` 에서 `x`는 무엇을 의미하는가?",
    "options": [
      "리스트의 인덱스 번호",
      "리스트 내부의 개별 요소 값",
      "리스트 전체 데이터",
      "리스트의 메모리 주소",
      "반복 횟수"
    ],
    "answer": "리스트 내부의 개별 요소 값",
    "why": "for in 구문에서 앞의 변수는 순회 대상의 각 요소를 하나씩 전달받습니다.",
    "hint": "for 루프 원리"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1040",
    "question": "중첩 루프(Nested Loop)에 대한 설명으로 옳은 것은?",
    "options": [
      "반복문 안에 또 다른 반복문이 들어있는 구조이다.",
      "파이썬에서는 성능상의 이유로 금지되어 있다.",
      "반드시 i, j, k 알파벳 순서로 변수명을 지어야 한다.",
      "무조건 infinite loop(무한 루프)가 된다.",
      "외부 루프보다 내부 루프가 먼저 종료되면 에러다."
    ],
    "answer": "반복문 안에 또 다른 반복문이 들어있는 구조이다.",
    "why": "다차원 리스트 처리 등을 위해 루프를 겹쳐 사용할 수 있습니다.",
    "hint": "중첩 구조"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1041",
    "question": "다음을 한 줄로 표현하는 List Comprehension으로 옳은 것은?\n`res = []; for x in range(5): res.append(x**2)`",
    "options": [
      "[x for x in range(5)]",
      "[x**2 for x in range(5)]",
      "[for x in range(5): x**2]",
      "[x in range(5) if x**2]",
      "[append(x**2) for x in range(5)]"
    ],
    "answer": "[x**2 for x in range(5)]",
    "why": "[표현식 for 변수 in 반복가능객체] 형태가 기본입니다.",
    "hint": "리스트 컴프리헨션"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1042",
    "question": "List Comprehension에서 필터링을 위한 if문은 어디에 위치하는가?",
    "options": [
      "for문 맨 앞",
      "for문 직후(뒤쪽)",
      "대괄호 밖",
      "in 키워드 앞",
      "위치는 상관없다"
    ],
    "answer": "for문 직후(뒤쪽)",
    "why": "[expr for var in iter if condition] 형태로 사용합니다.",
    "hint": "조건부 컴프리헨션"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1043",
    "question": "while문이 무한 루프에 빠지는 대표적인 상황은?",
    "options": [
      "반복 조건문이 항상 True인 경우",
      "break 문을 너무 많이 쓴 경우",
      "함수 내부에서 while을 쓴 경우",
      "조건문에 0이 들어간 경우",
      "리스트의 길이가 너무 긴 경우"
    ],
    "answer": "반복 조건문이 항상 True인 경우",
    "why": "while 조건이 거짓이 되지 않으면 루프는 영원히 실행됩니다.",
    "hint": "무한 루프"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1044",
    "question": "다음 중 '논리 연산자'가 아닌 것은?",
    "options": [
      "and",
      "or",
      "not",
      "is",
      "None of above (all are logic)"
    ],
    "answer": "is",
    "why": "is는 객체 비교 연산자이며, and/or/not이 대표적인 논리 연산자입니다.",
    "hint": "논리 연산자"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1045",
    "question": "`(3 > 1) and (5 < 2)` 의 최종 결과는?",
    "options": [
      "True",
      "False",
      "None",
      "3",
      "5"
    ],
    "answer": "False",
    "why": "and 연산은 양쪽 조건이 모두 참일 때만 True를 반환합니다.",
    "hint": "논리 판정"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1046",
    "question": "`(3 > 1) or (5 < 2)` 의 최종 결과는?",
    "options": [
      "True",
      "False",
      "None",
      "1",
      "2"
    ],
    "answer": "True",
    "why": "or 연산은 한쪽이라도 참이면 True를 반환합니다.",
    "hint": "논리 판정 or"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1047",
    "question": "리스트 `['a', 'b', 'c']`에서 값 'a'가 있는지 확인하는 코드?",
    "options": [
      "'a' in list",
      "'a' has list",
      "list.contains('a')",
      "list == 'a'",
      "'a' or list"
    ],
    "answer": "'a' in list",
    "why": "in 연산자는 멤버십 테스트를 수행합니다.",
    "hint": "in 연산자"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1048",
    "question": "`not True` 의 결과는?",
    "options": [
      "True",
      "False",
      "0",
      "1",
      "Error"
    ],
    "answer": "False",
    "why": "not은 불리언 값을 반대로 뒤집습니다.",
    "hint": "not 연산"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1049",
    "question": "리스트 슬라이싱 `arr[::2]` 의 의미는?",
    "options": [
      "처음부터 끝까지 2칸씩 건너뛰며 가져옴",
      "인덱스 2번까지만 가져옴",
      "끝에서 2개만 가져옴",
      "2번째 요소만 가져옴",
      "에러가 난다"
    ],
    "answer": "처음부터 끝까지 2칸씩 건너뛰며 가져옴",
    "why": "[start:end:step]에서 step은 간격을 의미합니다.",
    "hint": "슬라이싱 간격"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1050",
    "question": "`for i, v in enumerate(['A', 'B']):` 구문에서 `i`에 담기는 것은?",
    "options": [
      "문자열 'A', 'B'",
      "인덱스 번호 0, 1",
      "리스트 전체",
      "데이터 타입",
      "사용자 입력"
    ],
    "answer": "인덱스 번호 0, 1",
    "why": "enumerate는 순회 요소와 그 인덱스를 동시에 반환합니다.",
    "hint": "enumerate"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1051",
    "question": "파이썬에서 함수를 정의할 때 사용하는 키워드는?",
    "options": [
      "function",
      "func",
      "def",
      "define",
      "method"
    ],
    "answer": "def",
    "why": "Function Definition의 약자인 def를 사용합니다.",
    "hint": "함수 정의"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1052",
    "question": "함수 내부에서 계산된 값을 함수 밖으로 전달할 때 쓰는 키워드는?",
    "options": [
      "give",
      "send",
      "return",
      "output",
      "exit"
    ],
    "answer": "return",
    "why": "return 키워드는 결과값을 반환하고 함수를 종료합니다.",
    "hint": "return"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1053",
    "question": "함수 호출 시 인자의 개수가 가변적일 때(튜플로 받음) 사용하는 기호는?",
    "options": [
      "*args",
      "**kwargs",
      "&args",
      "?args",
      "!args"
    ],
    "answer": "*args",
    "why": "* 별표 하나는 여러 위치 인자를 튜플로 묶어서 받습니다.",
    "hint": "가변 인자"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1054",
    "question": "키워드 인자들을 딕셔너리 형태로 가변적으로 받을 때 사용하는 기호는?",
    "options": [
      "*args",
      "**kwargs",
      "$kwargs",
      "##kwargs",
      "+kwargs"
    ],
    "answer": "**kwargs",
    "why": "** 별표 두 개는 키워드 인자들을 딕셔너리로 묶어서 받습니다.",
    "hint": "키워드 가변 인자"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1055",
    "question": "함수 정의 시 매개변수에 미리 기본값을 지정하는 기능의 명칭은?",
    "options": [
      "Default Parameter",
      "Fixed Variable",
      "Initial Value",
      "Secret Parameter",
      "Global Parameter"
    ],
    "answer": "Default Parameter",
    "why": "인자가 전달되지 않았을 때 사용할 기본값을 설정할 수 있습니다.",
    "hint": "기본 매개변수"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1056",
    "question": "외부 라이브러리나 모듈의 기능을 현재 코드로 가져오는 키워드는?",
    "options": [
      "get",
      "bring",
      "import",
      "include",
      "load"
    ],
    "answer": "import",
    "why": "import 문을 통해 다른 파일의 함수나 클래스를 사용할 수 있습니다.",
    "hint": "임포트"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1057",
    "question": "`from math import sqrt` 문법의 장점은?",
    "options": [
      "math 모듈 전체를 다 안 가져오고 sqrt만 직접 사용 가능하다.",
      "실행 속도가 10배 빨라진다.",
      "sqrt 함수를 수정할 수 있게 된다.",
      "보안이 강화된다.",
      "가독성이 나빠지지만 코드는 짧아진다."
    ],
    "answer": "math 모듈 전체를 다 안 가져오고 sqrt만 직접 사용 가능하다.",
    "why": "특정 함수만 가져오면 math.sqrt() 대신 sqrt()로 바로 쓸 수 있습니다.",
    "hint": "from import"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1058",
    "question": "모듈의 이름을 별칭(Alias)으로 줄여서 가져올 때 쓰는 키워드는?",
    "options": [
      "with",
      "as",
      "like",
      "to",
      "rename"
    ],
    "answer": "as",
    "why": "`import pandas as pd` 처럼 as를 써서 이름을 별칭으로 바꿉니다.",
    "hint": "as 별칭"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1059",
    "question": "함수 내부에서 전역 변수(Global Variable)의 값을 수정하고자 할 때 쓰는 선언은?",
    "options": [
      "local",
      "public",
      "global",
      "common",
      "private"
    ],
    "answer": "global",
    "why": "전역 변수를 함수 내에서 '수정'하려면 global 선언이 필요합니다.",
    "hint": "global 선언"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1060",
    "question": "이름이 없는 한 줄짜리 익명 함수를 무엇이라 하는가?",
    "options": [
      "arrow function",
      "express function",
      "lambda function",
      "ghost function",
      "short function"
    ],
    "answer": "lambda function",
    "why": "lambda 키워드를 사용하여 간단한 로직의 익명 함수를 생성합니다.",
    "hint": "람다"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1061",
    "question": "작성된 소스 코드 파일(.py) 하나를 의미하는 단위는?",
    "options": [
      "Package",
      "Module",
      "Library",
      "Framework",
      "Script"
    ],
    "answer": "Module",
    "why": "파이썬에서 하나의 스크립트 파일은 개별 모듈로 간주됩니다.",
    "hint": "모듈 정의"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1062",
    "question": "여러 개의 모듈이 모인 폴더 구조(보통 __init__.py 포함)의 단위는?",
    "options": [
      "Package",
      "Snippet",
      "Repository",
      "Archive",
      "Source"
    ],
    "answer": "Package",
    "why": "패키지는 점(.) 연산자로 모듈을 계층적으로 관리하는 폴더입니다.",
    "hint": "패키지 정의"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1063",
    "question": "함수 상단에 `\"\"\" ... \"\"\"` 로 작성하는 도움말 주석의 명칭은?",
    "options": [
      "Help-string",
      "Instruction",
      "Docstring",
      "Comment-block",
      "Metadata"
    ],
    "answer": "Docstring",
    "why": "Documentation String의 약자로, 함수나 클래스의 명세를 적습니다.",
    "hint": "독스트링"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1064",
    "question": "함수 호출 시 `f(name='Kim', age=20)` 처럼 이름을 지정해주는 방식은?",
    "options": [
      "Positional Argument",
      "Keyword Argument",
      "Named Variable",
      "Direct Mapping",
      "Explicit Call"
    ],
    "answer": "Keyword Argument",
    "why": "키워드 인자를 사용하면 인자의 순서가 바뀌어도 안전합니다.",
    "hint": "키워드 인자"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1065",
    "question": "`map(len, ['abc', 'de'])` 의 결과로 생성되는 숫자들은?",
    "options": [
      "3, 2",
      "2, 3",
      "0, 1",
      "5",
      "abc, de"
    ],
    "answer": "3, 2",
    "why": "map은 반복 가능한 객체의 각 요소에 함수를 적용합니다.",
    "hint": "map 함수"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1066",
    "question": "`filter(None, [1, 0, 2, False])` 처럼 사용했을 때 남는 값은?",
    "options": [
      "1, 2",
      "1, 0, 2",
      "False",
      "0, False",
      "모두 삭제됨"
    ],
    "answer": "1, 2",
    "why": "filter는 함수의 결과나 값이 참인 요소만 걸러냅니다.",
    "hint": "filter 함수"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1067",
    "question": "특정 모듈을 현재 파일에서 직접 실행할 때만 동작하게 하는 조건문은?",
    "options": [
      "if __name__ == \"__main__\":",
      "if script.run() == True:",
      "if is_main():",
      "if this == main:",
      "if __run__ == \"start\":"
    ],
    "answer": "if __name__ == \"__main__\":",
    "why": "__name__ 변수를 체크하여 메인 스크립트 실행 여부를 판별합니다.",
    "hint": "메인 조건절"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1068",
    "question": "파이썬의 표준 라이브러리 중 운영체제와 상호작용(폴더 생성, 파일 경로 등)하는 모듈은?",
    "options": [
      "math",
      "sys",
      "os",
      "datetime",
      "random"
    ],
    "answer": "os",
    "why": "os 모듈은 디렉토리 제어, 환경 변수 접근 등 OS 기능을 제공합니다.",
    "hint": "os 모듈"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1069",
    "question": "파이썬의 설치 경로, 아규먼트(argv) 등 시스템 정보를 확인하는 모듈은?",
    "options": [
      "os",
      "sys",
      "io",
      "json",
      "pysys"
    ],
    "answer": "sys",
    "why": "sys 모듈은 파이썬 인터프리터와 관련된 시스템 설정을 다룹니다.",
    "hint": "sys 모듈"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1070",
    "question": "재귀 함수(Recursive Function)의 정의로 옳은 것은?",
    "options": [
      "함수 내부에서 자기 자신을 다시 호출하는 함수",
      "한꺼번에 여러 번 실행되는 함수",
      "에러가 나면 자동으로 다시 시작하는 함수",
      "반드시 loop 문을 포함해야 하는 함수",
      "외부 API를 호출하는 함수"
    ],
    "answer": "함수 내부에서 자기 자신을 다시 호출하는 함수",
    "why": "문제를 더 작은 단위로 쪼개어 해결할 때 주로 활용됩니다.",
    "hint": "재귀"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1071",
    "question": "객체를 만들기 위한 설계도에 해당하는 용어는?",
    "options": [
      "Object",
      "Instance",
      "Class",
      "Module",
      "Blueprint"
    ],
    "answer": "Class",
    "why": "클래스는 객체의 속성과 동작을 정의한 틀입니다.",
    "hint": "클래스 정의"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1072",
    "question": "클래스로부터 실제로 생성된 실체를 의미하는 용어는?",
    "options": [
      "Code",
      "Logic",
      "Instance",
      "Factory",
      "Unit"
    ],
    "answer": "Instance",
    "why": "보통 객체와 인스턴스는 비슷한 의미로 혼용되어 쓰입니다.",
    "hint": "인스턴스"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1073",
    "question": "클래스 내부의 함수를 부르는 명칭은?",
    "options": [
      "Global Function",
      "Method",
      "Action",
      "Attribute",
      "Feature"
    ],
    "answer": "Method",
    "why": "클래스에 속해 객체의 동작을 담당하는 함수를 메서드라 합니다.",
    "hint": "메서드"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1074",
    "question": "객체 내부에 저장된 데이터를 부르는 명칭은?",
    "options": [
      "Method",
      "Variable",
      "Attribute (속성)",
      "Param",
      "Constant"
    ],
    "answer": "Attribute (속성)",
    "why": "객체의 상태를 저장하는 변수를 속성 또는 필드라고 합니다.",
    "hint": "속성"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1075",
    "question": "객체 생성 시 자동으로 호출되어 값을 초기화하는 메서드명은?",
    "options": [
      "__start__",
      "__main__",
      "__init__",
      "__new__",
      "__construct__"
    ],
    "answer": "__init__",
    "why": "__init__은 파이썬 클래스의 생성자(Constructor) 역할을 합니다.",
    "hint": "생성자"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1076",
    "question": "메서드 정의 시 첫 번째 인자로 반드시 인스턴스 자신을 가리키는 변수명?",
    "options": [
      "this",
      "that",
      "self",
      "me",
      "it"
    ],
    "answer": "self",
    "why": "관례적으로 self를 사용하여 인스턴스의 속성에 접근합니다.",
    "hint": "self"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1077",
    "question": "기존 클래스의 기능을 물려받아 새로운 클래스를 만드는 기법은?",
    "options": [
      "Packaging",
      "Inheritance (상속)",
      "Mapping",
      "Copying",
      "Merging"
    ],
    "answer": "Inheritance (상속)",
    "why": "상속을 통해 코드 재사용성을 높이고 계층 구조를 만듭니다.",
    "hint": "상속"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1078",
    "question": "부모 클래스로부터 물려받은 메서드를 자식 클래스에서 재정의하는 것은?",
    "options": [
      "Overloading",
      "Overriding",
      "Overwriting",
      "Overlapping",
      "Resetting"
    ],
    "answer": "Overriding",
    "why": "오버라이딩을 통해 자식 클래스만의 특화된 기능을 구현합니다.",
    "hint": "오버라이딩"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1079",
    "question": "자식 클래스에서 부모 클래스의 메서드나 생성자를 호출할 때 쓰는 키워드?",
    "options": [
      "parent",
      "super()",
      "base",
      "root",
      "upper"
    ],
    "answer": "super()",
    "why": "super()를 사용하면 부모 클래스의 기능을 그대로 유지하며 확장하기 좋습니다.",
    "hint": "super"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1080",
    "question": "파이썬의 '모든 것이 객체이다'라는 말의 의미가 아닌 것은?",
    "options": [
      "숫자 10도 객체이다.",
      "문자열 'hi'도 객체이다.",
      "함수 그 자체도 객체로 취급되어 인자로 전달 가능하다.",
      "클래스는 객체가 아니므로 조작이 불가능하다.",
      "리스트나 딕셔너리도 객체이다."
    ],
    "answer": "클래스는 객체가 아니므로 조작이 불가능하다.",
    "why": "파이썬에서는 클래스 자체도 메타 객체로 다루어질 수 있습니다.",
    "hint": "객체 철학"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1081",
    "question": "비슷한 기능을 하는 객체들이 동일한 인터페이스(메서드명)를 가지는 성질?",
    "options": [
      "Encapsulation",
      "Polymorphism (다형성)",
      "Abstraction",
      "Separation",
      "Binding"
    ],
    "answer": "Polymorphism (다형성)",
    "why": "다형성을 통해 하나의 타입으로 여러 형태의 객체를 일관되게 다룹니다.",
    "hint": "다형성"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1082",
    "question": "내부 구현을 숨기고 필요한 부분만 외부에 공개하는 객체지향의 원칙?",
    "options": [
      "Encapsulation (캡슐화)",
      "Exposure",
      "Simplification",
      "Integration",
      "Modularization"
    ],
    "answer": "Encapsulation (캡슐화)",
    "why": "정보 은닉을 통해 데이터의 무분별한 접근을 막습니다.",
    "hint": "캡슐화"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1083",
    "question": "추상 클래스(Abstract Class)를 사용하는 가장 큰 이유는?",
    "options": [
      "코드의 실행 속도를 높이기 위해",
      "자식 클래스가 특정 메서드를 반드시 구현하도록 강제하기 위해",
      "데이터를 암호화하기 위해",
      "다중 상속을 막기 위해",
      "메모리 사용량을 줄이기 위해"
    ],
    "answer": "자식 클래스가 특정 메서드를 반드시 구현하도록 강제하기 위해",
    "why": "추상 메서드를 통해 틀을 제공하고 구현 의무를 부여합니다.",
    "hint": "추상 클래스"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1084",
    "question": "클래스 변수(Class Variable)의 상징적인 특징은?",
    "options": [
      "인스턴스마다 모두 다른 값을 가진다.",
      "해당 클래스로 만든 모든 인스턴스가 값을 공유한다.",
      "함수 안에서만 사용 가능하다.",
      "프로그램 종료 시까지 파일에 저장된다.",
      "숫자로만 구성되어야 한다."
    ],
    "answer": "해당 클래스로 만든 모든 인스턴스가 값을 공유한다.",
    "why": "클래스 변수는 인스턴스가 아닌 클래스 레벨에 저장됩니다.",
    "hint": "클래스 변수"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1085",
    "question": "`isinstance(obj, MyClass)` 함수가 하는 역할은?",
    "options": [
      "obj 객체가 MyClass의 인스턴스인지를 확인하여 불리언으로 반환한다.",
      "obj 객체를 MyClass 타입으로 억지로 변환한다.",
      "MyClass의 모든 속성을 obj로 복사한다.",
      "obj가 가진 메모리 주소를 숫자로 반환한다.",
      "새로운 객체 obj를 생성한다."
    ],
    "answer": "obj 객체가 MyClass의 인스턴스인지를 확인하여 불리언으로 반환한다.",
    "why": "객체의 타입을 안전하게 체크할 때 사용합니다.",
    "hint": "isinstance"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1086",
    "question": "프로그램 실행 중 발생하는 에러를 무엇이라 부르는가?",
    "options": [
      "Bug",
      "Exception (예외)",
      "Fault",
      "Warning",
      "Miss"
    ],
    "answer": "Exception (예외)",
    "why": "동적으로 발생하는 런타임 에러를 예외라고 칭합니다.",
    "hint": "예외 정의"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1087",
    "question": "예외를 시도하고 감지하기 위한 기본 구문은?",
    "options": [
      "check-catch",
      "try-except",
      "try-catch",
      "if-error",
      "begin-fail"
    ],
    "answer": "try-except",
    "why": "파이썬은 Java의 catch 대신 except를 사용합니다.",
    "hint": "try-except"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1088",
    "question": "에러 발생 여부와 상관없이 마지막에 무조건 실행하고 싶은 블록?",
    "options": [
      "next",
      "then",
      "finally",
      "last",
      "always"
    ],
    "answer": "finally",
    "why": "주로 파일 닫기나 자원 해제 코드를 finally에 둡니다.",
    "hint": "finally"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1089",
    "question": "특정 상황에서 강제로 에러를 발생시키고 싶을 때 사용하는 키워드?",
    "options": [
      "make",
      "push",
      "raise",
      "error",
      "alarm"
    ],
    "answer": "raise",
    "why": "raise 문을 통해 사용자 정의 예외 등을 직접 던질 수 있습니다.",
    "hint": "raise"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1090",
    "question": "파일을 열 때 `open('file.txt', 'w')`의 'w' 모드가 의미하는 것은?",
    "options": [
      "Read (읽기 전용)",
      "Write (덮어쓰기)",
      "Append (이어쓰기)",
      "Web (온라인 체크)",
      "Wait (대기)"
    ],
    "answer": "Write (덮어쓰기)",
    "why": "w 모드는 기존 파일이 있으면 내용을 모두 지우고 새로 씁니다.",
    "hint": "파일 모드 w"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1091",
    "question": "파일의 기존 내용을 유지하며 뒤에 덧붙이고 싶을 때 사용하는 모듈은?",
    "options": [
      "r",
      "w",
      "a",
      "x",
      "r+"
    ],
    "answer": "a",
    "why": "Append의 약자인 a 모드를 사용합니다.",
    "hint": "파일 모드 a"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1092",
    "question": "파일 객체의 `read()` 메서드 호출 시 결과값의 자료형은?",
    "options": [
      "List",
      "Dictionary",
      "String (문자열)",
      "Tuple",
      "None"
    ],
    "answer": "String (문자열)",
    "why": "read()는 파일 전체 내용을 하나의 큰 문자열로 읽어옵니다.",
    "hint": "read 결과"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1093",
    "question": "파일을 줄 단위로 쪼개어 리스트 형태로 반환하는 메서드는?",
    "options": [
      "read()",
      "readline()",
      "readlines()",
      "split()",
      "line_list()"
    ],
    "answer": "readlines()",
    "why": "각 줄이 요소로 들어있는 리스트를 가져옵니다.",
    "hint": "readlines"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1094",
    "question": "파일 입출력 시 `with` 문 사용을 권장하는 가장 큰 이유는?",
    "options": [
      "파일을 더 빠르게 읽을 수 있어서",
      "사용 후 파일 객체를 자동으로 닫아(close)주기 때문에",
      "파일의 크기를 압축해주기 때문에",
      "한글 깨짐 현상을 100% 방지해주기 때문에",
      "파일을 자동으로 웹에 동기화해주기 때문에"
    ],
    "answer": "사용 후 파일 객체를 자동으로 닫아(close)주기 때문에",
    "why": "컨텍스트 매니저가 파일 닫기를 보장하여 자원 누수를 막습니다.",
    "hint": "with-open"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1095",
    "question": "문자열의 양 끝에 있는 공백이나 줄바꿈을 제거하는 메서드는?",
    "options": [
      "clean()",
      "strip()",
      "cut()",
      "trim()",
      "remove_space()"
    ],
    "answer": "strip()",
    "why": "데이터 전처리 시 문자열 정리에 자주 쓰입니다.",
    "hint": "strip"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1096",
    "question": "텍스트 파일 인코딩 문제로 한글이 깨질 때 `open()`에 추가할 옵션은?",
    "options": [
      "unicode='yes'",
      "encoding='utf-8'",
      "lang='ko'",
      "style='korean'",
      "text='plain'"
    ],
    "answer": "encoding='utf-8'",
    "why": "표준 인코딩인 utf-8을 명시적으로 설정하면 한글 처리가 잘 됩니다.",
    "hint": "인코딩"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1097",
    "question": "`f.write()` 메서드의 인자로 주어야 하는 자료형은?",
    "options": [
      "정수",
      "실수",
      "문자열",
      "리스트",
      "딕셔너리"
    ],
    "answer": "문자열",
    "why": "파일에 텍스트를 쓸 때는 반드시 문자열 타입을 전달해야 합니다.",
    "hint": "파일 쓰기 타입"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1098",
    "question": "JSON 형태의 텍스트를 파이썬 딕셔너리로 변환해주는 모듈은?",
    "options": [
      "csv",
      "txt_parser",
      "json",
      "pandas",
      "dict_maker"
    ],
    "answer": "json",
    "why": "json 모듈은 loads()나 load()를 통해 파싱 기능을 제공합니다.",
    "hint": "json 모듈"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1099",
    "question": "`1 / 0` 을 시도했을 때 발생하는 구체적인 예외 이름은?",
    "options": [
      "NullError",
      "ZeroDivisionError",
      "MathError",
      "DividedByZero",
      "CalculationError"
    ],
    "answer": "ZeroDivisionError",
    "why": "0으로 숫자를 나누려 할 때 발생하는 특정 예외입니다.",
    "hint": "나눗셈 예외"
  },
  {
    "chapter_name": "Python 기초",
    "type": "객관식",
    "difficulty": "medium",
    "id": "1100",
    "question": "파일 경로 존재 여부를 확인할 때 쓰는 함수는?",
    "options": [
      "os.path.exists()",
      "os.file_check()",
      "os.look()",
      "os_find()",
      "os.path.is_there()"
    ],
    "answer": "os.path.exists()",
    "why": "파일이나 디렉토리가 존재하는지 미리 확인할 때 유용합니다.",
    "hint": "파일 체크"
  },
  {
    "chapter_name": "Python 기초",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "1101",
    "question": "변수 출력 코드를 완성하세요.\n```python\na = 10\n____(a) # 이 부분을 채우세요\n```",
    "answer": "print",
    "why": "결과를 화면에 출력할 때 사용합니다.",
    "hint": "변수 출력"
  },
  {
    "chapter_name": "Python 기초",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "1102",
    "question": "리스트 요소 추가 코드를 완성하세요.\n```python\nfruits = ['apple']\nfruits.____('banana') # 이 부분을 채우세요\n```",
    "answer": "append",
    "why": "리스트 끝에 새 항목을 추가합니다.",
    "hint": "리스트 요소 추가"
  },
  {
    "chapter_name": "Python 기초",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "1103",
    "question": "함수 정의 코드를 완성하세요.\n```python\n____ my_func(): # 이 부분을 채우세요\n    return True\n```",
    "answer": "def",
    "why": "함수를 선언하는 키워드입니다.",
    "hint": "함수 정의"
  },
  {
    "chapter_name": "Python 기초",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "1104",
    "question": "반복문 범위 코드를 완성하세요.\n```python\nfor i in ____(10): # 이 부분을 채우세요 (0~9까지)\n    print(i)\n```",
    "answer": "range",
    "why": "연속된 정수를 생성하는 객체입니다.",
    "hint": "반복문 범위"
  },
  {
    "chapter_name": "Python 기초",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "1105",
    "question": "조건문 elif 코드를 완성하세요.\n```python\nif x > 0:\n    pass\n____ x < 0: # 이 부분을 채우세요\n    pass\n```",
    "answer": "elif",
    "why": "추가 조건을 검사할 때 씁니다.",
    "hint": "조건문 elif"
  },
  {
    "chapter_name": "Python 기초",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "1106",
    "question": "파일 자동 닫기 코드를 완성하세요.\n```python\n____ open('data.txt', 'r') as f: # 이 부분을 채우세요\n    lines = f.readlines()\n```",
    "answer": "with",
    "why": "자원을 안전하게 사용하고 닫아줍니다.",
    "hint": "파일 자동 닫기"
  },
  {
    "chapter_name": "Python 기초",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "1107",
    "question": "예외 감지 코드를 완성하세요.\n```python\n____: # 이 부분을 채우세요\n    res = 1/0\nexcept:\n```",
    "answer": "try",
    "why": "에러 발생 가능성이 있는 코드를 감쌉니다.",
    "hint": "예외 감지"
  },
  {
    "chapter_name": "Python 기초",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "1108",
    "question": "클래스 생성자 코드를 완성하세요.\n```python\nclass Person:\n    def ____(self, name): # 이 부분을 채우세요\n        self.name = name\n```",
    "answer": "__init__",
    "why": "객체 초기화 메서드 이름입니다.",
    "hint": "클래스 생성자"
  },
  {
    "chapter_name": "Python 기초",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "1109",
    "question": "부모 클래스 호출 코드를 완성하세요.\n```python\nclass Child(Parent):\n    def __init__(self):\n        ____().__init__() # 이 부분을 채우세요\n```",
    "answer": "super",
    "why": "부모 클래스의 기능을 호출합니다.",
    "hint": "부모 클래스 호출"
  },
  {
    "chapter_name": "Python 기초",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "1110",
    "question": "문자열 길이 코드를 완성하세요.\n```python\ns = 'Python'\nlength = ____(s) # 이 부분을 채우세요\n```",
    "answer": "len",
    "why": "요소의 개수나 문자열 길이를 구합니다.",
    "hint": "문자열 길이"
  },
  {
    "chapter_name": "Python 기초",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "1111",
    "question": "모듈 임포트 코드를 완성하세요.\n```python\n____ pandas as pd # 이 부분을 채우세요\n```",
    "answer": "import",
    "why": "외부 라이브러리를 불러옵니다.",
    "hint": "모듈 임포트"
  },
  {
    "chapter_name": "Python 기초",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "1112",
    "question": "형변환 (문자->숫자) 코드를 완성하세요.\n```python\ns = '123'\nn = ____(s) # 이 부분을 채우세요\n```",
    "answer": "int",
    "why": "문자열을 정수로 바꿉니다.",
    "hint": "형변환 (문자->숫자)"
  },
  {
    "chapter_name": "Python 기초",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "1113",
    "question": "리스트 정렬 코드를 완성하세요.\n```python\narr = [3, 1, 2]\narr.____() # 이 부분을 채우세요\n```",
    "answer": "sort",
    "why": "내용을 오름차순으로 정렬합니다.",
    "hint": "리스트 정렬"
  },
  {
    "chapter_name": "Python 기초",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "1114",
    "question": "딕셔너리 키-값 코드를 완성하세요.\n```python\nperson = {'name': 'Kim'}\nval = person.____('name') # 이 부분을 채우세요\n```",
    "answer": "get",
    "why": "Key를 안전하게 조회하는 메서드입니다.",
    "hint": "딕셔너리 키-값"
  },
  {
    "chapter_name": "Python 기초",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "1115",
    "question": "리스트 한 줄 작성 코드를 완성하세요.\n```python\narr = [x ____ range(5)] # 이 부분을 채우세요\n```",
    "answer": "for x in",
    "why": "List Comprehension의 구성 요소입니다.",
    "hint": "리스트 한 줄 작성"
  },
  {
    "chapter_name": "Python 기초",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "1116",
    "question": "거듭제곱 연산자 코드를 완성하세요.\n```python\nres = 2 ____ 3 # 이 부분을 채우세요 (2의 3제곱)\n```",
    "answer": "**",
    "why": "지수 연산 기호입니다.",
    "hint": "거듭제곱 연산자"
  },
  {
    "chapter_name": "Python 기초",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "1117",
    "question": "참/거짓 상수 코드를 완성하세요.\n```python\nis_valid = ____ # 이 부분을 채우세요 (참을 뜻함)\n```",
    "answer": "True",
    "why": "불리언 상수는 대문자로 시작합니다.",
    "hint": "참/거짓 상수"
  },
  {
    "chapter_name": "Python 기초",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "1118",
    "question": "문자열 분리 코드를 완성하세요.\n```python\ns = 'a,b,c'\narr = s.____(',') # 이 부분을 채우세요\n```",
    "answer": "split",
    "why": "구분자로 문자열을 나누어 리스트로 만듭니다.",
    "hint": "문자열 분리"
  },
  {
    "chapter_name": "Python 기초",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "1119",
    "question": "사용자 입력 코드를 완성하세요.\n```python\nname = ____('이름은?') # 이 부분을 채우세요\n```",
    "answer": "input",
    "why": "사용자로부터 텍스트 입력을 받습니다.",
    "hint": "사용자 입력"
  },
  {
    "chapter_name": "Python 기초",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "1120",
    "question": "함수 데이터 반환 코드를 완성하세요.\n```python\ndef f():\n    ____ 10 # 이 부분을 채우세요\n```",
    "answer": "return",
    "why": "결과를 돌려주는 키워드입니다.",
    "hint": "함수 데이터 반환"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2001",
    "question": "NumPy 라이브러리의 주요 목적이 아닌 것은?",
    "options": [
      "대규모 다차원 배열 처리를 지원한다.",
      "파이썬 리스트보다 수치 연산 속도가 빠르다.",
      "고수준 머신러닝 알고리즘의 기반이 된다.",
      "데이터 프레임을 이용하여 SQL 쿼리를 직접 수행한다.",
      "강력한 벡터 연산(Vectorization) 기능을 제공한다."
    ],
    "answer": "데이터 프레임을 이용하여 SQL 쿼리를 직접 수행한다.",
    "why": "데이터 프레임과 SQL 스타일의 쿼리는 주로 Pandas의 역할입니다. NumPy는 수치 행렬 연산에 집중합니다.",
    "hint": "NumPy의 역할"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2002",
    "question": "NumPy 배열(ndarray)의 특징으로 옳은 것은?",
    "options": [
      "서로 다른 자료형의 데이터를 한 배열에 담을 수 있다.",
      "모든 요소는 반드시 동일한 자료형(dtype)이어야 한다.",
      "인덱싱과 슬라이싱 기능이 전혀 없다.",
      "파이썬 리스트보다 메모리를 더 많이 소모한다.",
      "데이터 수정이 불가능한 불변(Immutable) 객체이다."
    ],
    "answer": "모든 요소는 반드시 동일한 자료형(dtype)이어야 한다.",
    "why": "NumPy 배열은 연속된 메모리 배치를 위해 동일한 데이터 타입을 요구하며, 이를 통해 고속 연산을 가능하게 합니다.",
    "hint": "ndarray 특징"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2003",
    "question": "파이썬 리스트를 NumPy 배열로 변환하는 함수는?",
    "options": [
      "np.tolist()",
      "np.convert()",
      "np.array()",
      "np.make_array()",
      "np.asarray_list()"
    ],
    "answer": "np.array()",
    "why": "np.array() 함수는 리스트나 다른 시퀀스 데이터를 ndarray로 변환합니다.",
    "hint": "배열 생성"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2004",
    "question": "모든 요소가 0으로 채워진 크기 10의 배열을 만드는 코드는?",
    "options": [
      "np.zeros(10)",
      "np.ones(10)",
      "np.empty(10)",
      "np.full(0, 10)",
      "np.range(0, 10)"
    ],
    "answer": "np.zeros(10)",
    "why": "np.zeros()는 지정한 크기만큼 0으로 초기화된 배열을 생성합니다.",
    "hint": "zeros"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2005",
    "question": "NumPy에서 `np.arange(0, 10, 2)`를 실행한 결과는?",
    "options": [
      "[0, 2, 4, 6, 8]",
      "[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]",
      "[2, 4, 6, 8, 10]",
      "[0, 2, 4, 6, 8, 10]",
      "[0, 1, 2]"
    ],
    "answer": "[0, 2, 4, 6, 8]",
    "why": "range와 유사하게 start(0)부터 end(10) 미만까지 step(2) 간격으로 생성합니다.",
    "hint": "arange"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2006",
    "question": "배열의 각 요소에 대해 반복문 없이 연산을 적용하는 기법의 명칭은?",
    "options": [
      "Sequential Mapping",
      "Vectorization (벡터화)",
      "Normalization",
      "Looping",
      "Direct Access"
    ],
    "answer": "Vectorization (벡터화)",
    "why": "벡터화 연산을 통해 코드가 짧아지고 실행 속도가 비약적으로 향상됩니다.",
    "hint": "벡터화"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2007",
    "question": "NumPy 배열 `arr = np.array([1, 2, 3])` 에 `arr * 10`을 수행한 결과는?",
    "options": [
      "[10, 2, 3]",
      "[1, 2, 3, 10]",
      "[10, 20, 30]",
      "[11, 12, 13]",
      "에러가 발생한다"
    ],
    "answer": "[10, 20, 30]",
    "why": "NumPy는 배열과 스칼라 값 간의 요소별(Element-wise) 연산을 지원합니다.",
    "hint": "요소별 연산"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2008",
    "question": "배열의 현재 모양(차원)을 확인하는 속성은?",
    "options": [
      "arr.size",
      "arr.ndim",
      "arr.shape",
      "arr.form",
      "arr.type"
    ],
    "answer": "arr.shape",
    "why": "shape 속성은 각 차원의 크기를 튜플 형태로 보여줍니다.",
    "hint": "shape"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2009",
    "question": "배열의 데이터 타입을 확인하는 속성은?",
    "options": [
      "arr.type",
      "arr.dtype",
      "arr.kind",
      "arr.class",
      "arr.format"
    ],
    "answer": "arr.dtype",
    "why": "dtype은 데이터가 int, float 등 어떤 타입인지 나타냅니다.",
    "hint": "dtype"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2010",
    "question": "1차원 배열을 2차원(예: 2x5)으로 재구성할 때 쓰는 메서드는?",
    "options": [
      "arr.reform(2, 5)",
      "arr.resize(2, 5)",
      "arr.reshape(2, 5)",
      "arr.change(2, 5)",
      "arr.align(2, 5)"
    ],
    "answer": "arr.reshape(2, 5)",
    "why": "reshape()는 전체 요소 개수가 유지되는 한도 내에서 차원을 바꿉니다.",
    "hint": "reshape"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2011",
    "question": "NumPy에서 두 배열을 세로로(위아래로) 합치는 함수는?",
    "options": [
      "np.hstack()",
      "np.vstack()",
      "np.concatenate(axis=1)",
      "np.merge()",
      "np.combine()"
    ],
    "answer": "np.vstack()",
    "why": "Vertical Stack의 약자인 vstack()은 수직 방향으로 배열을 쌓습니다.",
    "hint": "vstack"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2012",
    "question": "NumPy 배열에서 조건에 맞는 요소만 추출하는 기법은?",
    "options": [
      "Condition Indexing",
      "Boolean Indexing",
      "Bitwise Filtering",
      "Select Index",
      "Logical Slicing"
    ],
    "answer": "Boolean Indexing",
    "why": "대괄호 안에 조건식을 넣어 True인 요소만 필터링할 수 있습니다.",
    "hint": "불리언 인덱싱"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2013",
    "question": "NumPy의 `np.mean(arr)` 함수가 계산하는 값은?",
    "options": [
      "합계",
      "최댓값",
      "평균값",
      "중앙값",
      "표준편차"
    ],
    "answer": "평균값",
    "why": "mean()은 산술 평균을 구하는 통계 함수입니다.",
    "hint": "평균"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2014",
    "question": "배열 내 모든 요소의 합을 구하는 함수는?",
    "options": [
      "np.total()",
      "np.add_all()",
      "np.sum()",
      "np.plus()",
      "np.integrate()"
    ],
    "answer": "np.sum()",
    "why": "sum()은 축(axis)에 따른 합계 연산을 지원합니다.",
    "hint": "합계"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2015",
    "question": "배열에서 가장 큰 값의 '인덱스'를 찾는 함수는?",
    "options": [
      "np.max()",
      "np.argmax()",
      "np.find_max()",
      "np.top_index()",
      "np.high()"
    ],
    "answer": "np.argmax()",
    "why": "argmax()는 최댓값이 위치한 위치 번호를 반환합니다.",
    "hint": "argmax"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2016",
    "question": "배열의 모든 요소에 동일한 상수를 더했을 때 각 요소가 모두 커지는 현상을 지원하는 기능?",
    "options": [
      "Broadcasting (브로드캐스팅)",
      "Duplication",
      "Magnification",
      "Streaming",
      "Auto-increment"
    ],
    "answer": "Broadcasting (브로드캐스팅)",
    "why": "서로 모양이 다른 배열 간의 연산을 가능하게 하는 NumPy의 핵심 메커니즘입니다.",
    "hint": "브로드캐스팅"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2017",
    "question": "NumPy에서 난수를 생성하는 서브 모듈 이름은?",
    "options": [
      "np.random",
      "np.chance",
      "np.guess",
      "np.stat",
      "np.variable"
    ],
    "answer": "np.random",
    "why": "random 모듈 내에 rand, randn, randint 등의 함수가 있습니다.",
    "hint": "random"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2018",
    "question": "행과 열을 서로 맞바꾸는(전치) 연산자 또는 메서드는?",
    "options": [
      "arr.flip()",
      "arr.swap()",
      "arr.T",
      "arr.reverse()",
      "arr.turn()"
    ],
    "answer": "arr.T",
    "why": ".T(Transpose) 속성을 사용하면 간단히 행과 열이 바뀝니다.",
    "hint": "전치"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2019",
    "question": "1차원 배열의 순서를 거꾸로 뒤집는 대표적인 슬라이싱 방식은?",
    "options": [
      "arr[::]",
      "arr[::-1]",
      "arr[0:0]",
      "arr[1:0]",
      "arr[-1:1]"
    ],
    "answer": "arr[::-1]",
    "why": "step에 -1을 주면 역순으로 슬라이싱합니다.",
    "hint": "역순 슬라이싱"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2020",
    "question": "`np.ones((2, 3))` 명령어로 만들어지는 배열의 총 요소 개수는?",
    "options": [
      "5개",
      "6개",
      "2개",
      "3개",
      "1개"
    ],
    "answer": "6개",
    "why": "2행 3열의 배열이므로 2 * 3 = 6개의 요소가 생성됩니다.",
    "hint": "배열 크기"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2021",
    "question": "Pandas 라이브러리의 핵심적인 목적은?",
    "options": [
      "GPU를 이용한 딥러닝 연산",
      "테이플 형태의 정형 데이터 분석과 처리",
      "웹 디자인 및 UI 구현",
      "네트워크 패킷 분석",
      "운영체제 리소스 모니터링"
    ],
    "answer": "테이플 형태의 정형 데이터 분석과 처리",
    "why": "Pandas는 엑셀이나 SQL과 같은 행/열 구조의 데이터를 다루는 데 최적화되어 있습니다.",
    "hint": "Pandas 목적"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2022",
    "question": "Pandas에서 인덱스를 가진 1차원 배열 형태의 자료구조는?",
    "options": [
      "DataFrame",
      "Series",
      "Record",
      "Vector",
      "Column"
    ],
    "answer": "Series",
    "why": "Series는 하나의 컬럼 데이터를 담을 수 있는 1차원 구조입니다.",
    "hint": "Series"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2023",
    "question": "행과 열이 있는 2차원 표 형태의 자료구조는?",
    "options": [
      "DataMatrix",
      "DataTable",
      "DataFrame",
      "DataGrid",
      "DataSpread"
    ],
    "answer": "DataFrame",
    "why": "DataFrame은 여러 개의 Series가 합쳐진 2차원 구조입니다.",
    "hint": "DataFrame"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2024",
    "question": "Pandas에서 CSV 파일을 불러올 때 쓰는 함수는?",
    "options": [
      "pd.open_csv()",
      "pd.read_csv()",
      "pd.load_csv()",
      "pd.from_csv()",
      "pd.get_csv()"
    ],
    "answer": "pd.read_csv()",
    "why": "read_csv()는 다양한 옵션을 통해 CSV 파일을 데이터프레임으로 변환합니다.",
    "hint": "read_csv"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2025",
    "question": "데이터프레임의 상위 5개 행을 조회하는 메서드는?",
    "options": [
      "df.top()",
      "df.head()",
      "df.first()",
      "df.show()",
      "df.peek()"
    ],
    "answer": "df.head()",
    "why": "데이터의 구조를 대략적으로 파악할 때 가장 먼저 사용됩니다.",
    "hint": "head"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2026",
    "question": "데이터프레임의 전체 행 수, 컬럼명, 데이터 타입 및 결측치를 요약 확인하는 메서드는?",
    "options": [
      "df.describe()",
      "df.info()",
      "df.summary()",
      "df.check()",
      "df.status()"
    ],
    "answer": "df.info()",
    "why": "info() 메서드는 데이터프레임의 메타데이터를 요약해 보여줍니다.",
    "hint": "info"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2027",
    "question": "수치형 컬럼들의 평균, 표준편차, 최솟값, 최댓값 등 통계량을 요약해주는 메서드는?",
    "options": [
      "df.info()",
      "df.stats()",
      "df.describe()",
      "df.stat_summary()",
      "df.math()"
    ],
    "answer": "df.describe()",
    "why": "기술 통계량을 한눈에 확인할 때 유용합니다.",
    "hint": "describe"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2028",
    "question": "데이터프레임에서 'name'이라는 컬럼 하나만 선택하는 올바른 문법은?",
    "options": [
      "df.select('name')",
      "df['name']",
      "df{name}",
      "df : name",
      "df.get_rows('name')"
    ],
    "answer": "df['name']",
    "why": "딕셔너리와 유사한 키 방식을 사용하여 특정 열(Series)을 추출합니다.",
    "hint": "열 선택"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2029",
    "question": "라벨(이름)을 기준으로 데이터의 행이나 열을 선택하는 메서드는?",
    "options": [
      "df.iloc",
      "df.loc",
      "df.idx",
      "df.label",
      "df.select"
    ],
    "answer": "df.loc",
    "why": "loc는 location의 약자로 행/열의 이름을 기준으로 접근합니다.",
    "hint": "loc"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2030",
    "question": "정수 위치(Index 번호)를 기준으로 데이터를 선택하는 메서드는?",
    "options": [
      "df.loc",
      "df.iloc",
      "df.slice",
      "df.pos",
      "df.point"
    ],
    "answer": "df.iloc",
    "why": "iloc는 integer location의 약자로 0부터 시작하는 숫자로 접근합니다.",
    "hint": "iloc"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2031",
    "question": "나이가 20세 이상인 데이터만 필터링하는 파이썬 코드는?",
    "options": [
      "df.filter(age >= 20)",
      "df[df['age'] >= 20]",
      "df.where('age' >= 20)",
      "df.get(age > 20)",
      "df{age >= 20}"
    ],
    "answer": "df[df['age'] >= 20]",
    "why": "불리언 마스크를 대괄호 안에 넣어 조건에 맞는 행을 추출합니다.",
    "hint": "필터링 문법"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2032",
    "question": "Pandas에서 결측치(Null, NaN)를 확인하는 메서드는?",
    "options": [
      "df.ismissing()",
      "df.isnull()",
      "df.none()",
      "df.empty()",
      "df.check_na()"
    ],
    "answer": "df.isnull()",
    "why": "df.isnull() 또는 df.isna()를 사용하여 결측 위치를 찾습니다.",
    "hint": "결측치 확인"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2033",
    "question": "결측치가 포함된 '행'을 통째로 삭제해버리는 메서드는?",
    "options": [
      "df.remove_na()",
      "df.delete_na()",
      "df.clear_na()",
      "df.dropna()",
      "df.cut_na()"
    ],
    "answer": "df.dropna()",
    "why": "데이터 정제 시 불완전한 기록을 지우고자 할 때 사용합니다.",
    "hint": "dropna"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2034",
    "question": "결측치를 특정 값(예: 0이나 평균)으로 채워 넣는 메서드는?",
    "options": [
      "df.refill()",
      "df.fixna()",
      "df.fillna()",
      "df.replace_na()",
      "df.put_na()"
    ],
    "answer": "df.fillna()",
    "why": "결측치를 다른 데이터로 보정하여 분석을 계속할 때 씁니다.",
    "hint": "fillna"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2035",
    "question": "특정 컬럼의 데이터 타입을 강제로 바꾸는 메서드는?",
    "options": [
      "df.convert()",
      "df.to_type()",
      "df.astype()",
      "df.format()",
      "df.change_type()"
    ],
    "answer": "df.astype()",
    "why": "예를 들어 문자열로 된 숫자를 숫자형으로 바꿀 때 자주 쓰입니다.",
    "hint": "astype"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2036",
    "question": "데이터프레임의 특정 컬럼에 있는 고유값들의 빈도수를 세는 메서드는?",
    "options": [
      "df.count()",
      "df.unique_count()",
      "df.value_counts()",
      "df.group_count()",
      "df.freq()"
    ],
    "answer": "df.value_counts()",
    "why": "범주형 데이터의 분포를 파악할 때 필수적입니다.",
    "hint": "value_counts"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2037",
    "question": "컬럼명을 'old_name'에서 'new_name'으로 바꾸는 올바른 메서드는?",
    "options": [
      "df.rename(columns={'old_name': 'new_name'})",
      "df.replace_column('old_name', 'new_name')",
      "df.columns = 'new_name'",
      "df.set_name('old_name', 'new_name')",
      "df.change_header(...)"
    ],
    "answer": "df.rename(columns={'old_name': 'new_name'})",
    "why": "rename() 메서드에 딕셔너리 형태로 전달하여 이름을 바꿉니다.",
    "hint": "rename"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2038",
    "question": "데이터프레임을 특정 컬럼 기준으로 정렬하는 메서드는?",
    "options": [
      "df.align()",
      "df.arrange()",
      "df.sort_values()",
      "df.order_by()",
      "df.reorder()"
    ],
    "answer": "df.sort_values()",
    "why": "by 인자에 기준 컬럼을, ascending에 정렬 순서를 지정합니다.",
    "hint": "sort_values"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2039",
    "question": "데이터프레임에서 불필요한 행이나 열을 삭제하는 메서드는?",
    "options": [
      "df.remove()",
      "df.delete()",
      "df.drop()",
      "df.cut()",
      "df.exclude()"
    ],
    "answer": "df.drop()",
    "why": "axis=0은 행, axis=1은 열을 삭제합니다.",
    "hint": "drop"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2040",
    "question": "중복된 행을 찾아 제거하는 메서드는?",
    "options": [
      "df.remove_duplicates()",
      "df.drop_duplicates()",
      "df.clear_duplicates()",
      "df.unique()",
      "df.filter_duplicates()"
    ],
    "answer": "df.drop_duplicates()",
    "why": "완전히 똑같은 행이 여러 번 등장할 때 하나만 남깁니다.",
    "hint": "중복 제거"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2041",
    "question": "데이터프레임의 행이나 열에 사용자 정의 함수를 일괄 적용하는 메서드는?",
    "options": [
      "df.each()",
      "df.apply()",
      "df.map()",
      "df.run()",
      "df.execute()"
    ],
    "answer": "df.apply()",
    "why": "복잡한 계산 로직을 컬럼 전체에 적용할 때 매우 유용합니다.",
    "hint": "apply"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2042",
    "question": "데이터를 특정 컬럼의 값에 따라 그룹으로 묶어주는 메서드는?",
    "options": [
      "df.pivot()",
      "df.groupby()",
      "df.aggregate()",
      "df.cluster()",
      "df.section()"
    ],
    "answer": "df.groupby()",
    "why": "그룹별 통계(합계, 평균 등)를 낼 때 가장 많이 쓰입니다.",
    "hint": "groupby"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2043",
    "question": "특정 기준으로 그룹화한 뒤 평균을 구하는 올바른 코드는?",
    "options": [
      "df.groupby('A').average()",
      "df.groupby('A').mean()",
      "df.cluster('A').mean()",
      "df.group('A')[mean]",
      "df.summarize('A', mean)"
    ],
    "answer": "df.groupby('A').mean()",
    "why": "groupby 객체에 바로 통계 함수를 연결하여 사용합니다.",
    "hint": "그룹 집계"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2044",
    "question": "두 데이터프레임을 위아래 혹은 옆으로 단순 연결(붙이기)하는 함수는?",
    "options": [
      "pd.merge()",
      "pd.join()",
      "pd.concat()",
      "pd.append_all()",
      "pd.attach()"
    ],
    "answer": "pd.concat()",
    "why": "Concatenate의 약자로 테이블을 단순히 이어 붙일 때 씁니다.",
    "hint": "concat"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2045",
    "question": "두 데이터프레임을 공통 키(Key)를 기준으로 합치는(Join) 함수는?",
    "options": [
      "pd.combine()",
      "pd.merge()",
      "pd.link()",
      "pd.connect()",
      "pd.zip_tables()"
    ],
    "answer": "pd.merge()",
    "why": "SQL의 JOIN 연산과 동일한 기능을 수행합니다.",
    "hint": "merge"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2046",
    "question": "Pandas merge에서 교집합(Inner Join)이 아닌 '합집합' 결과를 얻는 방식은?",
    "options": [
      "how='inner'",
      "how='left'",
      "how='outer'",
      "how='union'",
      "how='full'"
    ],
    "answer": "how='outer'",
    "why": "outer 옵션을 주면 양쪽 데이터 모두를 유지하며 합칩니다.",
    "hint": "outer join"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2047",
    "question": "데이터프레임의 모든 문자열을 소문자로 바꾸기 위해 컬럼 `df['name']` 에 적용하는 도구는?",
    "options": [
      "df['name'].lower()",
      "df['name'].str.lower()",
      "df['name'].to_lower()",
      "df['name'].apply(low)",
      "pd.lower(df['name'])"
    ],
    "answer": "df['name'].str.lower()",
    "why": ".str 접근자를 통해 문자열 전용 함수를 벡터화하여 적용합니다.",
    "hint": "str 접근자"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2048",
    "question": "시계열 데이터 처리를 위해 문자열 날짜를 Timestamp 객체로 바꾸는 함수는?",
    "options": [
      "pd.to_date()",
      "pd.to_datetime()",
      "pd.parse_time()",
      "pd.convert_time()",
      "pd.make_time()"
    ],
    "answer": "pd.to_datetime()",
    "why": "문자열 형태의 날짜 데이터를 분석 가능한 날짜 형식으로 변환합니다.",
    "hint": "to_datetime"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2049",
    "question": "데이터프레임의 행과 열을 맞바꾸는 속성은?",
    "options": [
      "df.reverse",
      "df.swap",
      "df.T",
      "df.flip",
      "df.rotate"
    ],
    "answer": "df.T",
    "why": "NumPy와 마찬가지로 .T 속성을 사용하여 전치(Transpose)합니다.",
    "hint": "전치"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2050",
    "question": "엑셀의 피벗 테이블과 같이 데이터를 요약 재구성하는 메서드는?",
    "options": [
      "df.summary()",
      "df.pivot_table()",
      "df.reshape()",
      "df.cube()",
      "df.cross_tab()"
    ],
    "answer": "df.pivot_table()",
    "why": "인덱스, 컬럼, 값, 집계 함수를 지정하여 유연하게 표를 만듭니다.",
    "hint": "pivot_table"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2051",
    "question": "Wide 포맷 데이터를 Long 포맷으로 녹이듯이 변환하는 메서드는?",
    "options": [
      "df.melt()",
      "df.freeze()",
      "df.boil()",
      "df.squeeze()",
      "df.expand()"
    ],
    "answer": "df.melt()",
    "why": "정리되지 않은(Un-tidy) 데이터를 분석하기 좋게 변환할 때 씁니다.",
    "hint": "melt"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2052",
    "question": "특정 조건에 맞는 행을 '문자열 쿼리' 형식으로 추출하는 메서드는?",
    "options": [
      "df.select()",
      "df.query()",
      "df.search()",
      "df.find()",
      "df.fetch()"
    ],
    "answer": "df.query()",
    "why": "`df.query('age > 20')` 처럼 가독성 좋은 쿼리 작성이 가능합니다.",
    "hint": "query"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2053",
    "question": "데이터프레임에서 무작위로 n개의 샘플을 추출하는 메서드는?",
    "options": [
      "df.random()",
      "df.sample()",
      "df.pick()",
      "df.extract()",
      "df.take()"
    ],
    "answer": "df.sample()",
    "why": "대용량 데이터의 일부만 미리 볼 때나 샘플링 시 사용합니다.",
    "hint": "sample"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2054",
    "question": "결측치가 아닌 데이터의 개수만 세는 메서드는?",
    "options": [
      "df.length()",
      "df.count()",
      "df.size()",
      "df.num()",
      "df.exist_count()"
    ],
    "answer": "df.count()",
    "why": "전체 행 수와 비교하여 누락된 데이터가 얼마나 되는지 가늠할 때 씁니다.",
    "hint": "count"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2055",
    "question": "데이터프레임의 한 컬럼을 인덱스로 지정하는 메서드는?",
    "options": [
      "df.set_label()",
      "df.make_index()",
      "df.set_index()",
      "df.use_index()",
      "df.apply_index()"
    ],
    "answer": "df.set_index()",
    "why": "특정 고유 ID 컬럼 등을 인덱스로 쓸 때 사용합니다.",
    "hint": "set_index"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2056",
    "question": "인덱스로 설정된 값을 다시 일반 컬럼으로 되돌리는 메서드는?",
    "options": [
      "df.clear_index()",
      "df.reset_index()",
      "df.unset_index()",
      "df.fix_index()",
      "df.back_index()"
    ],
    "answer": "df.reset_index()",
    "why": "인덱스를 0부터 시작하는 숫자로 초기화하고 기존 인덱스는 컬럼으로 보냅니다.",
    "hint": "reset_index"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2057",
    "question": "특정 컬럼의 고유값 목록(List)만 뽑아내는 메서드는?",
    "options": [
      "df['col'].values",
      "df['col'].unique()",
      "df['col'].list()",
      "df['col'].distinct()",
      "df['col'].only()"
    ],
    "answer": "df['col'].unique()",
    "why": "SQL의 DISTINCT와 유사하게 중복 없는 값들을 반환합니다.",
    "hint": "unique"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2058",
    "question": "상위 n개 데이터를 가져오는 head()의 반대 기능(하위 n개)은?",
    "options": [
      "df.bottom()",
      "df.end()",
      "df.tail()",
      "df.back()",
      "df.final()"
    ],
    "answer": "df.tail()",
    "why": "데이터의 마지막 부분(꼬리)을 확인할 때 씁니다.",
    "hint": "tail"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2059",
    "question": "수치 데이터를 일정한 구간(Category)으로 나누는(Binning) 기술은?",
    "options": [
      "pd.cut()",
      "pd.divide()",
      "pd.split_range()",
      "pd.bin()",
      "pd.section()"
    ],
    "answer": "pd.cut()",
    "why": "연속형 변수를 범주형 변수로 변환할 때(예: 점수 -> 등급) 사용합니다.",
    "hint": "cut"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2060",
    "question": "데이터프레임에서 컬럼 이름들만 리스트 형태로 확인하는 속성은?",
    "options": [
      "df.names",
      "df.headers",
      "df.columns",
      "df.fields",
      "df.labels"
    ],
    "answer": "df.columns",
    "why": "컬럼명 전체 리스트를 인덱스 객체 형태로 반환합니다.",
    "hint": "columns"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2061",
    "question": "파이썬 시각화의 가장 근간이 되는 기초 라이브러리는?",
    "options": [
      "Seaborn",
      "Plotly",
      "Matplotlib",
      "Bokeh",
      "Folium"
    ],
    "answer": "Matplotlib",
    "why": "대부분의 파이썬 시각화 도구는 Matplotlib을 기반으로 확장되었습니다.",
    "hint": "Matplotlib"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2062",
    "question": "Matplotlib을 기반으로 더 세련된 디자인과 통계 기능을 제공하는 라이브러리는?",
    "options": [
      "PyPlot",
      "Seaborn",
      "GraphViz",
      "VisualPy",
      "ArtPandas"
    ],
    "answer": "Seaborn",
    "why": "Pandas 데이터프레임과 호환성이 뛰어나며 통계 그래프 작성에 최적입니다.",
    "hint": "Seaborn"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2063",
    "question": "데이터의 분포(전체적인 흐름)를 막대 형태로 보여주는 그래프는?",
    "options": [
      "Line Plot",
      "Bar Chart",
      "Histogram",
      "Scatter Plot",
      "Pie Chart"
    ],
    "answer": "Histogram",
    "why": "연속형 변수의 구간별 빈도를 나타내는 데 쓰입니다.",
    "hint": "히스토그램"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2064",
    "question": "두 수치형 변수 간의 관계(상관관계)를 점으로 찍어서 표현하는 그래프는?",
    "options": [
      "Line Plot",
      "Box Plot",
      "Scatter Plot (산점도)",
      "Bar Plot",
      "Heatmap"
    ],
    "answer": "Scatter Plot (산점도)",
    "why": "두 변수가 서로 어떤 방향으로 움직이는지 파악할 때 유용합니다.",
    "hint": "산점도"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2065",
    "question": "시간의 흐름에 따른 데이터의 변화(트렌드)를 보기 좋은 그래프는?",
    "options": [
      "Line Plot (선 그래프)",
      "Pie Chart",
      "Histogram",
      "Box Plot",
      "Bar Plot"
    ],
    "answer": "Line Plot (선 그래프)",
    "why": "시계열 데이터를 분석할 때 가장 기본적으로 쓰입니다.",
    "hint": "선 그래프"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2066",
    "question": "데이터의 중앙값, 사분위수, 이상치(Outlier)를 한눈에 식별하기 좋은 그래프는?",
    "options": [
      "Histogram",
      "Violin Plot",
      "Box Plot",
      "Pie Chart",
      "Line Chart"
    ],
    "answer": "Box Plot",
    "why": "데이터의 통계적 분포와 외딴값들을 찾을 때 강력합니다.",
    "hint": "박스 플롯"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2067",
    "question": "여러 변수 간의 상관계수를 색상으로 표현하여 시각화하는 도구는?",
    "options": [
      "Bar Chart",
      "Heatmap (히트맵)",
      "Dot Plot",
      "Area Chart",
      "Radar Chart"
    ],
    "answer": "Heatmap (히트맵)",
    "why": "변수가 많을 때 어떤 것들이 서로 밀접한지 색으로 보여줍니다.",
    "hint": "히트맵"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2068",
    "question": "데이터 분석 실무에서 전처리(Preprocessing) 단계가 차지하는 중요도는?",
    "options": [
      "전체 과정의 10% 미만이다.",
      "거의 중요하지 않고 모델링이 전부다.",
      "가장 많은 시간과 노력이 소모되는 핵심 단계이다.",
      "마지막 보고서 쓸 때만 필요하다.",
      "컴퓨터가 알아서 해주므로 신경 쓸 필요 없다."
    ],
    "answer": "가장 많은 시간과 노력이 소모되는 핵심 단계이다.",
    "why": "쓰레기를 넣으면 쓰레기가 나온다는 원칙에 따라 데이터 정제가 가장 중요합니다.",
    "hint": "전처리의 중요성"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2069",
    "question": "이상치(Outlier)를 처리하는 가장 일반적인 방법이 아닌 것은?",
    "options": [
      "데이터에서 제거한다.",
      "중앙값이나 평균값으로 대체한다.",
      "별도의 분석 대상으로 분리한다.",
      "모든 데이터를 이상치에 맞춰 강제로 조정한다.",
      "로그 변환 등을 통해 영향력을 줄인다."
    ],
    "answer": "모든 데이터를 이상치에 맞춰 강제로 조정한다.",
    "why": "이상치 때문에 전체 데이터를 왜곡시키는 것은 잘못된 분석입니다.",
    "hint": "이상치 처리"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2070",
    "question": "데이터 분석 시 '결측치'가 발생하는 주된 원인이 아닌 것은?",
    "options": [
      "입력자의 실수나 누락",
      "센서 오작동",
      "설문 응답 거부",
      "의도적인 데이터 암호화",
      "시스템 전송 오류"
    ],
    "answer": "의도적인 데이터 암호화",
    "why": "암호화는 데이터 보안을 위한 것이지 시스템상 누락된 결측치와는 다릅니다.",
    "hint": "결측치 원인"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2071",
    "question": "범주형(Categorical) 변수를 수치화할 때 자주 쓰이는 방식은?",
    "options": [
      "Random Scaling",
      "One-Hot Encoding",
      "Binary Sum",
      "Value Mapping (1, 2, 3...)",
      "One-Hot Encoding 및 Value Mapping"
    ],
    "answer": "One-Hot Encoding 및 Value Mapping",
    "why": "모델이 이해할 수 있도록 범주를 숫자로 변환하는 필수 과정입니다.",
    "hint": "인코딩 기법"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2072",
    "question": "데이터의 편향(Skewness)을 줄이기 위해 원본 데이터에 취하는 수학적 연산은?",
    "options": [
      "더하기 100",
      "로그(Log) 변환",
      "곱하기 2",
      "나누기 10",
      "제곱근(Sqrt) 변환"
    ],
    "answer": "로그(Log) 변환",
    "why": "큰 값들의 차이를 좁혀주어 분포를 정규분포에 가깝게 만듭니다.",
    "hint": "로그 변환"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2073",
    "question": "분석 결과를 타인에게 전달할 때 가장 중요한 요소는?",
    "options": [
      "사용한 코드의 길이",
      "얼마나 비싼 GPU를 썼는지",
      "비즈니스 인사이트를 도출하는 시각화와 설명",
      "오직 정확도 숫자 하나",
      "사용한 라이브러리의 버전 목록"
    ],
    "answer": "비즈니스 인사이트를 도출하는 시각화와 설명",
    "why": "데이터를 통해 어떤 결정을 내려야 하는지 설득력 있게 전달해야 합니다.",
    "hint": "데이터 스토리텔링"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2074",
    "question": "Pandas `df.apply(len)`을 전체 문자열 컬럼에 적용하면 얻는 결과는?",
    "options": [
      "각 문자열의 첫 글자",
      "각 문자열의 길이 값",
      "문자열 내 공백 개수",
      "전체 행의 숫자",
      "에러 발생"
    ],
    "answer": "각 문자열의 길이 값",
    "why": "모든 행에 대해 len 함수가 실행되어 글자 수가 계산된 결과가 나옵니다.",
    "hint": "apply 활용"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2075",
    "question": "실무에서 CSV 파일이 대중적으로 쓰이는 이유는?",
    "options": [
      "파이썬에서만 열리기 때문에",
      "데이터 보안이 가장 완벽해서",
      "구조가 단순하고 가독성이 좋으며 호환성이 뛰어나서",
      "압축률이 전 세계 최고라서",
      "이미지 데이터 저장에 적합해서"
    ],
    "answer": "구조가 단순하고 가독성이 좋으며 호환성이 뛰어나서",
    "why": "쉼표로 구분된 텍스트 형식이어서 거의 모든 도구(엑셀 등)에서 열립니다.",
    "hint": "CSV 장점"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2076",
    "question": "데이터프레임 `df.isna().sum()` 코드가 의미하는 바는?",
    "options": [
      "결측치가 있는 행의 이름",
      "컬럼별 결측치의 총 개수",
      "전체 데이터의 평균값",
      "중복된 데이터의 개수",
      "데이터 타입의 목록"
    ],
    "answer": "컬럼별 결측치의 총 개수",
    "why": "isna()로 비어있는지 체크하고 sum()으로 각 열의 True 개수를 합산합니다.",
    "hint": "결측치 합계"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2077",
    "question": "시계열 데이터에서 특정 기간(예: 7일)의 이동 평균을 구하는 메서드는?",
    "options": [
      "df.shift()",
      "df.rolling(window=7).mean()",
      "df.expand().mean()",
      "df.avg_move(7)",
      "df.time_mean(7)"
    ],
    "answer": "df.rolling(window=7).mean()",
    "why": "시계열의 변동을 완만하게 보고 트렌드를 파악할 때 씁니다.",
    "hint": "이동 평균"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2078",
    "question": "Pandas `describe()` 결과에서 50% 지점에 해당하는 통계량의 명칭은?",
    "options": [
      "Mean (평균)",
      "Std (표준편차)",
      "Median (중앙값)",
      "Mode (최빈값)",
      "Range (범위)"
    ],
    "answer": "Median (중앙값)",
    "why": "데이터를 순서대로 세웠을 때 정중앙에 위치하는 값입니다.",
    "hint": "중앙값"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2079",
    "question": "데이터프레임의 인덱스를 무작위로 섞고 싶을 때 사용하는 방법은?",
    "options": [
      "df.mix()",
      "df.sample(frac=1)",
      "df.reverse()",
      "df.shuffle()",
      "df.random_index()"
    ],
    "answer": "df.sample(frac=1)",
    "why": "전체 데이터(frac=1)를 무작위로 추출하면 셔플 효과가 납니다.",
    "hint": "인덱스 셔플"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2080",
    "question": "여러 컬럼 중 상관계수가 1에 가깝게 나온 두 변수의 관계는?",
    "options": [
      "아무런 상관이 없다.",
      "서로 반대 방향으로 똑같이 움직인다.",
      "한 변수가 커질 때 다른 변수도 거의 똑같이 커진다.",
      "두 변수는 서로 독립적이다.",
      "데이터가 잘못 입력된 것이다."
    ],
    "answer": "한 변수가 커질 때 다른 변수도 거의 똑같이 커진다.",
    "why": "양의 상관계수 1은 완전한 정비례 관계를 의미합니다.",
    "hint": "상관계수 의미"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2081",
    "question": "데이터 용량이 너무 커서 메모리에 한 번에 안 올라갈 때의 대책은?",
    "options": [
      "데이터를 절반 잘라버린다.",
      "NumPy만 쓴다.",
      "read_csv에 chunksize를 주어 끊어 읽는다.",
      "모든 숫자를 정수로 바꾼다.",
      "분석을 포기한다."
    ],
    "answer": "read_csv에 chunksize를 주어 끊어 읽는다.",
    "why": "파일을 조각조각 읽어서 처리하는 방식으로 메모리 문제를 해결합니다.",
    "hint": "대용량 처리"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2082",
    "question": "Seaborn의 히트맵(Heatmap)을 그릴 때 주로 입력값으로 주는 것은?",
    "options": [
      "문자열 원본 리스트",
      "컬럼별 평균값 리스트",
      "상관계수 행렬 (df.corr())",
      "전체 데이터프레임 원본",
      "데이터 타입 목록"
    ],
    "answer": "상관계수 행렬 (df.corr())",
    "why": "격자 구조의 수치 행렬을 주면 색상으로 강도를 표시합니다.",
    "hint": "히트맵 입력"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2083",
    "question": "데이터 분석 보고서에서 '가설 설정'의 단계는 보통 언제 이루어지는가?",
    "options": [
      "데이터 분석이 다 끝난 후 결론 쓸 때",
      "분석을 시작하기 전 혹은 EDA 중간 단계",
      "라이브러리 import 할 때",
      "컴퓨터 전원 켤 때",
      "고객에게 보고서 제출할 때"
    ],
    "answer": "분석을 시작하기 전 혹은 EDA 중간 단계",
    "why": "데이터를 통해 무엇을 증명할지 미리 정하고 접근해야 효율적입니다.",
    "hint": "분석 프로세스"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2084",
    "question": "Pandas `df.iloc[0:3, 1:4]` 가 의미하는 선택 범위는?",
    "options": [
      "1~3행, 2~4열",
      "0~2번 행, 1~3번 열",
      "첫 번째 행부터 세 번째 행까지 전체 열",
      "0, 1, 2, 3번 행, 1, 2, 3, 4번 열",
      "에러"
    ],
    "answer": "0~2번 행, 1~3번 열",
    "why": "정수 위치 기반이며 슬라이싱 끝 번호는 포함되지 않습니다.",
    "hint": "iloc 범위"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2085",
    "question": "데이터프레임에서 '성별' 컬럼의 '남'을 1, '여'를 0으로 바꾸는 가장 편리한 함수는?",
    "options": [
      "apply(int)",
      "replace({'남': 1, '여': 0})",
      "strip()",
      "sum()",
      "astype(int)"
    ],
    "answer": "replace({'남': 1, '여': 0})",
    "why": "사전 형식을 전달하여 특정 값을 다른 값으로 일괄 변경합니다.",
    "hint": "값 치환"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2086",
    "question": "Matplotlib에서 그래프에 제목을 다는 함수는?",
    "options": [
      "plt.name()",
      "plt.title()",
      "plt.header()",
      "plt.tag()",
      "plt.subject()"
    ],
    "answer": "plt.title()",
    "why": "그래프 상단에 설명을 추가하는 기본 함수입니다.",
    "hint": "제목 달기"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2087",
    "question": "Pandas에서 중복 행이 있는지 여부(Boolean)만 확인하는 메서드는?",
    "options": [
      "duplicated()",
      "is_repeating()",
      "check_copy()",
      "repeat()",
      "exist()"
    ],
    "answer": "duplicated()",
    "why": "각 행이 이전 행과 중복되는지를 True/False로 반환합니다.",
    "hint": "중복 체크"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2088",
    "question": "데이터프레임 두 개를 옆으로(가로로) 붙일 때 `pd.concat`에 주어야 할 축 옵션은?",
    "options": [
      "axis=0",
      "axis=1",
      "direction='horizontal'",
      "side='right'",
      "join='true'"
    ],
    "answer": "axis=1",
    "why": "axis=0(기본값)은 위아래, axis=1은 좌우 연결입니다.",
    "hint": "concat 축"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2089",
    "question": "데이터 분석 시 한글 폰트가 깨지지 않게 하기 위해 설정해야 하는 라이브러리는?",
    "options": [
      "NLTK",
      "KoNLPy",
      "Matplotlib (rc 설정)",
      "OS",
      "Pandas"
    ],
    "answer": "Matplotlib (rc 설정)",
    "why": "Matplotlib의 기본 폰트는 영문이므로 한글 폰트 경로를 직접 잡아줘야 합니다.",
    "hint": "한글 폰트"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2090",
    "question": "데이터프레임 저장 시 인덱스(0, 1, 2...)는 빼고 저장하고 싶을 때 옵션은?",
    "options": [
      "drop_index=True",
      "index=False",
      "no_index=1",
      "save_index=0",
      "header=None"
    ],
    "answer": "index=False",
    "why": "`to_csv('file.csv', index=False)` 처럼 사용합니다.",
    "hint": "저장 옵션"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2091",
    "question": "NumPy 배열에서 0이 아닌 요소의 위치를 찾는 함수는?",
    "options": [
      "np.find()",
      "np.nonzero()",
      "np.where()",
      "np.search()",
      "np.nonzero() 및 np.where()"
    ],
    "answer": "np.nonzero() 및 np.where()",
    "why": "조건에 맞는 요소의 인덱스를 찾아내는 핵심 함수들입니다.",
    "hint": "위치 찾기"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2092",
    "question": "데이터 분석가에게 가장 권장되는 파이썬 실행 환경은?",
    "options": [
      "메모장",
      "명령 프롬프트(CMD)",
      "Jupyter Notebook / JupyterLab",
      "웹 사이트 소스 보기",
      "그림판"
    ],
    "answer": "Jupyter Notebook / JupyterLab",
    "why": "대화형 실행과 시각화, 문서화가 동시에 가능하여 분석가 표준 도구입니다.",
    "hint": "실행 환경"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2093",
    "question": "Pandas `df['A'].shift(1)` 을 실행했을 때 일어나는 일은?",
    "options": [
      "A 컬럼의 모든 값이 1씩 증가한다.",
      "A 컬럼의 값들이 아래로 한 칸씩 밀리고 첫 행은 NaN이 된다.",
      "A 컬럼이 리스트로 바뀐다.",
      "A 컬럼이 통째로 삭제된다.",
      "순서가 거꾸로 뒤집힌다."
    ],
    "answer": "A 컬럼의 값들이 아래로 한 칸씩 밀리고 첫 행은 NaN이 된다.",
    "why": "시계열 분석에서 전일 대비 증감 등을 계산할 때 필수입니다.",
    "hint": "shift"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2094",
    "question": "데이터프레임의 인덱스명을 기준으로 정렬하고 싶을 때 쓰는 메서드는?",
    "options": [
      "sort_values()",
      "sort_index()",
      "sort_label()",
      "order_index()",
      "align_index()"
    ],
    "answer": "sort_index()",
    "why": "값이 아닌 인덱스(날짜 등)를 순서대로 나열할 때 씁니다.",
    "hint": "sort_index"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2095",
    "question": "`pd.read_csv('data.csv', nrows=10)` 코드가 수행하는 작업은?",
    "options": [
      "모든 행의 이름을 10으로 바꾼다.",
      "전체 파일 중 상위 10개 행만 읽어온다.",
      "파일의 10번째 줄부터 읽기 시작한다.",
      "파일에 10개의 빈 줄을 추가한다.",
      "에러가 난다."
    ],
    "answer": "전체 파일 중 상위 10개 행만 읽어온다.",
    "why": "매우 큰 파일의 샘플만 빠르게 보고 싶을 때 유용합니다.",
    "hint": "nrows"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2096",
    "question": "데이터프레임의 모든 원소에 대해 개별적으로 함수를 적용하는 메서드는?",
    "options": [
      "apply()",
      "map()",
      "applymap()",
      "foreach()",
      "transform()"
    ],
    "answer": "applymap()",
    "why": "데이터프레임 전체 격자에 대해 원소 단위 연산을 수행합니다.",
    "hint": "applymap"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2097",
    "question": "Numpy `np.linspace(0, 10, 5)` 가 생성하는 배열은?",
    "options": [
      "[0, 2.5, 5, 7.5, 10]",
      "[0, 2, 4, 6, 8, 10]",
      "[0, 5, 10]",
      "[0, 1, 2, 3, 4, 5...]",
      "[2, 4, 6, 8]"
    ],
    "answer": "[0, 2.5, 5, 7.5, 10]",
    "why": "0부터 10 사이를 균등하게 5개의 포인트로 나눕니다.",
    "hint": "linspace"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2098",
    "question": "시각화 도구 중 웹 기반 인터랙티브(확대, 마우스 오버 등) 그래프에 강점이 있는 것은?",
    "options": [
      "Matplotlib",
      "Seaborn",
      "Plotly",
      "ggplot",
      "PIL"
    ],
    "answer": "Plotly",
    "why": "마우스 움직임에 반응하는 화려한 그래프를 만들 때 선호됩니다.",
    "hint": "Plotly"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2099",
    "question": "데이터 전처리 시 '정규화(Normalization)'와 '표준화(Standardization)'의 공통적인 목적은?",
    "options": [
      "데이터를 암호화하기 위해",
      "프로그램 실행 속도를 높이기 위해",
      "서로 다른 변수의 스케일을 맞춰 비교 가능하게 하기 위해",
      "결측치를 자동으로 채우기 위해",
      "파일 용량을 크게 만들기 위해"
    ],
    "answer": "서로 다른 변수의 스케일을 맞춰 비교 가능하게 하기 위해",
    "why": "단위가 다른 데이터(예: 키와 몸무게)를 공정한 범위에서 비교하게 돕습니다.",
    "hint": "스케일링 목적"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "객관식",
    "difficulty": "medium",
    "id": "2100",
    "question": "데이터 분석의 최종적인 결과물로 가장 적절한 형태는?",
    "options": [
      "수만 줄의 소스 코드",
      "단순히 '정확도가 높다'라는 말",
      "데이터 기반의 인사이트와 실행 권고안이 담긴 리포트",
      "사용자가 이해할 수 없는 도표들",
      "아무런 설명 없는 엑셀 파일"
    ],
    "answer": "데이터 기반의 인사이트와 실행 권고안이 담긴 리포트",
    "why": "데이터 분석의 목적은 비즈니스 문제를 해결하고 의사결정을 돕는 것에 있습니다.",
    "hint": "분석의 결과"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "2101",
    "question": "데이터 로드 코드를 완성하세요.\n```python\nimport pandas as pd\ndf = pd.____('data.csv') # 이 부분을 채우세요\n```",
    "answer": "read_csv",
    "why": "CSV 파일을 읽어오는 표준 함수입니다.",
    "hint": "데이터 로드"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "2102",
    "question": "상위 데이터 확인 코드를 완성하세요.\n```python\ndf.____(10) # 이 부분을 채우세요 (상위 10개)\n```",
    "answer": "head",
    "why": "데이터의 앞부분을 확인하는 메서드입니다.",
    "hint": "상위 데이터 확인"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "2103",
    "question": "요약 정보 확인 코드를 완성하세요.\n```python\ndf.____() # 요약 정보 출력 (이 부분을 채우세요)\n```",
    "answer": "info",
    "why": "컬럼 정보와 결측치를 보여주는 메서드입니다.",
    "hint": "요약 정보 확인"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "2104",
    "question": "기술 통계량 코드를 완성하세요.\n```python\ndf.____() # 수치형 요약 (이 부분을 채우세요)\n```",
    "answer": "describe",
    "why": "평균, 표준편차 등을 요약해주는 메서드입니다.",
    "hint": "기술 통계량"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "2105",
    "question": "인덱스 기준 선택 코드를 완성하세요.\n```python\ndf.____['row1', 'col1'] # 이 부분을 채우세요\n```",
    "answer": "loc",
    "why": "이름 기반 데이터 접근자입니다.",
    "hint": "인덱스 기준 선택"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "2106",
    "question": "정수 위치 선택 코드를 완성하세요.\n```python\ndf.____[0, 0] # 이 부분을 채우세요\n```",
    "answer": "iloc",
    "why": "숫자 위치 기반 데이터 접근자입니다.",
    "hint": "정수 위치 선택"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "2107",
    "question": "결측치 채우기 코드를 완성하세요.\n```python\ndf['age'] = df['age'].____(20) # 이 부분을 채우세요\n```",
    "answer": "fillna",
    "why": "빈 값을 특정 값으로 채우는 메서드입니다.",
    "hint": "결측치 채우기"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "2108",
    "question": "결측 행 삭제 코드를 완성하세요.\n```python\nclean_df = df.____() # 이 부분을 채우세요\n```",
    "answer": "dropna",
    "why": "결측치가 포함된 행을 제거합니다.",
    "hint": "결측 행 삭제"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "2109",
    "question": "그룹화 코드를 완성하세요.\n```python\ngrouped = df.____('category') # 이 부분을 채우세요\n```",
    "answer": "groupby",
    "why": "데이터를 그룹별로 묶어주는 메서드입니다.",
    "hint": "그룹화"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "2110",
    "question": "데이터 병합 코드를 완성하세요.\n```python\nmerged = pd.____(df1, df2, on='id') # 이 부분을 채우세요\n```",
    "answer": "merge",
    "why": "키를 기준으로 합치는 함수입니다.",
    "hint": "데이터 병합"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "2111",
    "question": "단순 연결 코드를 완성하세요.\n```python\ncombined = pd.____([df1, df2], axis=0) # 이 부분을 채우세요\n```",
    "answer": "concat",
    "why": "리스트로 묶어 연결하는 함수입니다.",
    "hint": "단순 연결"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "2112",
    "question": "컬럼 삭제 코드를 완성하세요.\n```python\ndf_small = df.____('price', axis=1) # 이 부분을 채우세요\n```",
    "answer": "drop",
    "why": "특정 열을 지우는 메서드입니다.",
    "hint": "컬럼 삭제"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "2113",
    "question": "고유값 빈도 코드를 완성하세요.\n```python\ncounts = df['city'].____() # 이 부분을 채우세요\n```",
    "answer": "value_counts",
    "why": "가장 많이 등장하는 값을 찾을 때 씁니다.",
    "hint": "고유값 빈도"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "2114",
    "question": "형변환 코드를 완성하세요.\n```python\ndf['year'] = df['year'].____(int) # 이 부분을 채우세요\n```",
    "answer": "astype",
    "why": "컬럼의 데이터 타입을 변환합니다.",
    "hint": "형변환"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "2115",
    "question": "함수 일괄 적용 코드를 완성하세요.\n```python\ndf['len'] = df['name'].____(len) # 이 부분을 채우세요\n```",
    "answer": "apply",
    "why": "함수를 요소마다 적용합니다.",
    "hint": "함수 일괄 적용"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "2116",
    "question": "NumPy 임포트 코드를 완성하세요.\n```python\nimport ____ as np # 이 부분을 채우세요\n```",
    "answer": "numpy",
    "why": "NumPy의 표준 별칭입니다.",
    "hint": "NumPy 임포트"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "2117",
    "question": "0 초기화 배열 코드를 완성하세요.\n```python\narr = np.____((3, 3)) # 이 부분을 채우세요\n```",
    "answer": "zeros",
    "why": "0으로 가득 찬 배열을 만듭니다.",
    "hint": "0 초기화 배열"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "2118",
    "question": "배열 모양 확인 코드를 완성하세요.\n```python\nprint(arr.____) # 이 부분을 채우세요 (모양 속성)\n```",
    "answer": "shape",
    "why": "배열의 차원을 알려주는 속성입니다.",
    "hint": "배열 모양 확인"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "2119",
    "question": "배열 재구성 코드를 완성하세요.\n```python\nnew_arr = arr.____(1, 9) # 이 부분을 채우세요\n```",
    "answer": "reshape",
    "why": "요소 수는 같게 차원만 바꿉니다.",
    "hint": "배열 재구성"
  },
  {
    "chapter_name": "데이터 분석",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "2120",
    "question": "그래프 제목 코드를 완성하세요.\n```python\nimport matplotlib.pyplot as plt\nplt.____('Result') # 이 부분을 채우세요\n```",
    "answer": "title",
    "why": "그래프 상단에 제목을 노출합니다.",
    "hint": "그래프 제목"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3001",
    "question": "전통적인 RNN/LSTM 모델이 긴 문장을 처리할 때 겪었던 '장기 의존성(Long-term Dependency)' 문제에 대한 설명으로 옳은 것은?",
    "options": [
      "문장이 길어질수록 앞부분의 정보를 소실하거나 잊어버리는 현상이다.",
      "문장의 길이에 상관없이 항상 동일한 성능을 유지하는 특징이다.",
      "문장 전체의 통계적 빈도만 고려하여 문맥을 파악하지 못하는 것이다.",
      "컴퓨터의 메모리 용량이 부족하여 프로그램이 꺼지는 현상이다.",
      "단어를 무작위로 섞어서 학습하기 때문에 발생하는 오류이다."
    ],
    "answer": "문장이 길어질수록 앞부분의 정보를 소실하거나 잊어버리는 현상이다.",
    "why": "RNN은 순차적으로 데이터를 처리하므로 멀리 떨어진 단어 간의 관계를 학습하기 어려운 한계가 있었습니다.",
    "hint": "RNN 한계"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3002",
    "question": "2017년 구글이 발표한 'Attention is All You Need' 논문의 핵심적인 기여는?",
    "options": [
      "RNN의 성능을 2배 높이는 새로운 방식을 제안했다.",
      "이미지 처리를 위한 CNN 아키텍처를 완성했다.",
      "순차 처리 대신 병렬 처리가 가능한 '트랜스포머' 구조를 제시했다.",
      "데이터 보안을 위한 새로운 암호화 알고리즘을 발표했다.",
      "파이썬의 실행 속도를 높이는 인터프리터를 개발했다."
    ],
    "answer": "순차 처리 대신 병렬 처리가 가능한 '트랜스포머' 구조를 제시했다.",
    "why": "트랜스포머는 어텐션 메커니즘을 전면에 내세워 문맥 파악 능력을 비약적으로 높였습니다.",
    "hint": "트랜스포머 탄생"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3003",
    "question": "트랜스포머의 '어텐션(Attention)' 메커니즘이 수행하는 가장 주된 작업은?",
    "options": [
      "단어의 글자 수를 세어 가장 긴 단어를 찾는다.",
      "문맥상 어떤 단어들이 서로 밀접한 관계가 있는지 가중치를 계산한다.",
      "파일의 용량을 줄이기 위해 텍스트를 압축한다.",
      "오타를 실시간으로 교정하여 문법을 맞춘다.",
      "단어를 다른 나라 언어로 즉시 번역한다."
    ],
    "answer": "문맥상 어떤 단어들이 서로 밀접한 관계가 있는지 가중치를 계산한다.",
    "why": "어텐션은 특정 단어를 이해할 때 문장 내 다른 단어들을 얼마나 참고할지 점수를 매깁니다.",
    "hint": "어텐션 원리"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3004",
    "question": "트랜스포머 아키텍처 중 '인코더(Encoder)'의 특징에 대한 설명으로 옳은 것은?",
    "options": [
      "주로 문장을 새로 생성(Generate)하는 작업에 최적화되어 있다.",
      "입력 문장을 수치화하여 그 의미를 압축하고 이해하는 데 강점이 있다.",
      "GPT 모델의 핵심 구조로 사용된다.",
      "다음에 올 단어를 하나씩 예측하며 결과물을 내놓는다.",
      "오직 한국어 분석에만 사용 가능한 특수 구조이다."
    ],
    "answer": "입력 문장을 수치화하여 그 의미를 압축하고 이해하는 데 강점이 있다.",
    "why": "인코더는 문맥의 상호 의미를 파악하는 데 특화되어 있으며, BERT가 대표적인 인코더 기반 모델입니다.",
    "hint": "인코더 특징"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3005",
    "question": "현대 LLM(GPT 등)이 주로 채택하고 있는 '디코더 전용(Decoder-only)' 구조의 특징은?",
    "options": [
      "문장의 의미를 이해하기만 할 뿐, 새로운 답변을 만들지는 못한다.",
      "앞서 생성된 단어들을 바탕으로 다음에 올 단어를 확률적으로 예측한다.",
      "인코더보다 항상 크기가 작고 성능이 낮다.",
      "반드시 이미지 데이터와 함께 학습되어야만 동작한다.",
      "입력 데이터의 순서를 고려하지 않고 무작위로 답변을 내놓는다."
    ],
    "answer": "앞서 생성된 단어들을 바탕으로 다음에 올 단어를 확률적으로 예측한다.",
    "why": "디코더는 이전 토큰들의 맥락을 유지하며 다음 토큰을 생성하는 생성 작업(Generation)의 표준입니다.",
    "hint": "디코더 특징"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3006",
    "question": "GPT 모델이 문장을 생성할 때 단어를 하나씩 내뱉는 방식은?",
    "options": [
      "한꺼번에 문장 전체를 사진처럼 찍듯이 생성한다.",
      "다음 토큰을 예측하며 순차적으로 한 단어씩 생성한다.",
      "문장의 마지막 단어부터 거꾸로 생성한다.",
      "사전에 정의된 문장 템플릿에 단어만 끼워 넣는다.",
      "사용자가 엔터를 칠 때까지 기다렸다가 한 번에 대답한다."
    ],
    "answer": "다음 토큰을 예측하며 순차적으로 한 단어씩 생성한다.",
    "why": "Auto-regressive(자기 회귀) 방식으로, 이전 결과가 다음 입력이 되어 문장을 완성해 나갑니다.",
    "hint": "생성 메커니즘"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3007",
    "question": "트랜스포머에서 단어의 순서(위치) 정보를 모델에게 전달하기 위해 사용하는 기법은?",
    "options": [
      "Sequence Count",
      "Positional Encoding",
      "Index Mapping",
      "Word Order Tagging",
      "Linear Alignment"
    ],
    "answer": "Positional Encoding",
    "why": "트랜스포머는 데이터를 한꺼번에 처리하므로, 단어의 위치 구분을 위해 인코딩 값을 더해줍니다.",
    "hint": "위치 인코딩"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3008",
    "question": "모델 아키텍처 중 BERT는 주로 ( A ) 방식이며, GPT는 주로 ( B ) 방식이다. ( )에 들어갈 적절한 조합은?",
    "options": [
      "A: 디코더, B: 인코더",
      "A: 인코더, B: 디코더",
      "A: CNN, B: RNN",
      "A: 임베딩, B: 토크나이징",
      "A: 지도학습, B: 비지도학습"
    ],
    "answer": "A: 인코더, B: 디코더",
    "why": "BERT는 문맥 이해(인코더), GPT는 문장 생성(디코더)에 강점이 있는 대표적 모델입니다.",
    "hint": "모델 구분"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3009",
    "question": "트랜스포머 구조에서 여러 개의 어텐션을 동시에 수행하여 다양한 관점을 학습하는 기술은?",
    "options": [
      "Single-Line Attention",
      "Parallel Attention",
      "Multi-Head Attention",
      "Complex Attention",
      "Super Attention"
    ],
    "answer": "Multi-Head Attention",
    "why": "여러 '헤드'를 통해 문장의 다양한 문맥적 특징을 동시에 추출합니다.",
    "hint": "Multi-Head"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3010",
    "question": "딥러닝 모델의 층이 깊어질 때 학습이 잘 안 되는 문제를 해결하기 위해, 입력값을 뒤쪽 층에 직접 전달하는 구조는?",
    "options": [
      "Skip Layer",
      "Back Link",
      "Residual Connection (잔차 연결)",
      "Fast Track",
      "Data Tunnel"
    ],
    "answer": "Residual Connection (잔차 연결)",
    "why": "입력 정보를 결과에 더해주어 기울기 소실(Vanishing Gradient) 문제를 완화합니다.",
    "hint": "잔차 연결"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3011",
    "question": "LLM이 처리하는 데이터의 최소 단위인 '토큰(Token)'에 대한 설명으로 틀린 것은?",
    "options": [
      "글자 하나일 수도 있고, 단어 하나일 수도 있다.",
      "모델은 텍스트를 직접 읽는 것이 아니라 토큰화된 숫자를 처리한다.",
      "영어보다 한글이 토큰 소모량이 보통 더 적다.",
      "단어의 일부(서브워드) 단위로 쪼개지기도 한다.",
      "토큰 소모량이 많을수록 API 비용이 더 많이 발생한다."
    ],
    "answer": "영어보다 한글이 토큰 소모량이 보통 더 적다.",
    "why": "한글은 교착어 특성상 형태소 단위로 쪼개지면 영어보다 토큰을 더 많이 사용하는 경향이 있습니다.",
    "hint": "토큰의 정의"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3012",
    "question": "단어의 의미를 고차원 공간상의 좌표(실수 리스트)로 나타내는 과정을 무엇이라 하는가?",
    "options": [
      "Vectorization",
      "Embedding (임베딩)",
      "Scaling",
      "Positioning",
      "Dimensioning"
    ],
    "answer": "Embedding (임베딩)",
    "why": "임베딩을 통해 컴퓨터는 단어 사이의 의미적 유사도를 계산할 수 있게 됩니다.",
    "hint": "임베딩"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3013",
    "question": "유사한 의미를 가진 단어들은 벡터 공간상에서 어떤 특징을 갖는가?",
    "options": [
      "서로 멀리 떨어져 있다.",
      "서로 수직 관계에 있다.",
      "서로 가까운 거리에 위치한다.",
      "모두 0에 수렴한다.",
      "아무런 상관관계가 없다."
    ],
    "answer": "서로 가까운 거리에 위치한다.",
    "why": "코사인 유사도 등을 통해 벡터 간의 거리가 가까울수록 의미가 유사하다고 판단합니다.",
    "hint": "공간적 의미"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3014",
    "question": "서브워드(Subword) 토큰화 기법 중 하나로, 자주 등장하는 문자 쌍을 반복적으로 병합하는 방식은?",
    "options": [
      "WordPiece",
      "SentencePiece",
      "BPE (Byte Pair Encoding)",
      "N-gram",
      "Jamo Splitting"
    ],
    "answer": "BPE (Byte Pair Encoding)",
    "why": "BPE는 가장 빈번한 조합을 하나의 단어로 묶어 어휘 사전의 효율성을 극대화합니다.",
    "hint": "BPE"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3015",
    "question": "LLM이 한 번에 기억하고 처리할 수 있는 입력 데이터의 최대 범위는?",
    "options": [
      "Memory Span",
      "Context Window (문맥 창)",
      "Token Buffer",
      "Input Horizon",
      "Processing Limit"
    ],
    "answer": "Context Window (문맥 창)",
    "why": "이 범위를 벗어난 이전 대화 내용은 모델이 망각하게 됩니다.",
    "hint": "문맥 창"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3016",
    "question": "GPT-3 모델의 매개변수(Parameter) 개수는 약 얼마인가?",
    "options": [
      "1.7B (17억 개)",
      "175B (1,750억 개)",
      "7B (70억 개)",
      "1T (1조 개)",
      "500M (5억 개)"
    ],
    "answer": "175B (1,750억 개)",
    "why": "GPT-3는 초거대 언어 모델의 시대를 연 상징적인 모델로 1,750억 개의 파라미터를 가집니다.",
    "hint": "GPT-3 규모"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3017",
    "question": "별도의 추가 학습 없이 프롬프트에 예시를 몇 개 보여주는 것만으로 모델이 방식을 익히는 현상은?",
    "options": [
      "Fine-tuning",
      "In-Context Learning (Few-shot)",
      "Hard Coding",
      "Manual Training",
      "Meta Learning"
    ],
    "answer": "In-Context Learning (Few-shot)",
    "why": "모델 가중치를 고정하고 프롬프트 맥락 내에서 지식을 습득하는 능력입니다.",
    "hint": "퓨샷 학습"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3018",
    "question": "예시를 전혀 주지 않고 바로 명령만 내리는 방식을 무엇이라 하는가?",
    "options": [
      "One-shot",
      "Zero-shot",
      "No-shot",
      "Direct-shot",
      "Fast-shot"
    ],
    "answer": "Zero-shot",
    "why": "모델의 사전 지식과 지시 이행 능력에만 의존하는 방식입니다.",
    "hint": "제로샷"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3019",
    "question": "OpenAI가 발표한 모델 중 멀티모달 능력을 갖추고 이미지 인식까지 가능해진 유료 모델 버전은?",
    "options": [
      "GPT-2",
      "GPT-3",
      "GPT-4",
      "GPT-Neo",
      "InstructGPT"
    ],
    "answer": "GPT-4",
    "why": "GPT-4는 텍스트뿐만 아니라 이미지 입력을 이해할 수 있는 강력한 성능을 보여줍니다.",
    "hint": "GPT-4"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3020",
    "question": "메타(Meta)가 공개하여 오픈소스 LLM 생태계를 폭발시킨 모델의 이름은?",
    "options": [
      "Alpaca",
      "Claude",
      "LLaMA (라마)",
      "Gemini",
      "Mistral"
    ],
    "answer": "LLaMA (라마)",
    "why": "라마의 가중치 공개는 개인과 연구자들이 저사양으로도 LLM을 연구하게 만든 전환점이 되었습니다.",
    "hint": "LLaMA"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3021",
    "question": "허깅페이스(HuggingFace)에서 모델을 다운로드하여 내 서버에서 직접 구동하는 방식의 장점은?",
    "options": [
      "관리 인력이 아예 필요 없다.",
      "서버 비용이 0원이다.",
      "데이터 보안이 강력하고 커스텀 학습이 자유롭다.",
      "메모리(RAM)를 거의 쓰지 않는다.",
      "인터넷이 끊겨도 전 세계 데이터를 다 안다."
    ],
    "answer": "데이터 보안이 강력하고 커스텀 학습이 자유롭다.",
    "why": "외부 서버로 데이터를 보내지 않아 보안에 유리하며, 우리 비즈니스에 맞게 수정이 가능합니다.",
    "hint": "오픈 모델 장점"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3022",
    "question": "OpenAI API 등을 사용하여 클라우드 기반으로 모델을 쓰는 방식의 장점은?",
    "options": [
      "가장 최신/최고 성능의 모델을 인프라 관리 없이 즉시 쓸 수 있다.",
      "데이터 유출 위험이 절대 없다.",
      "인터넷이 없어도 작동한다.",
      "사용료가 평생 무료이다.",
      "모델의 내부 코드를 마음껏 수정할 수 있다."
    ],
    "answer": "가장 최신/최고 성능의 모델을 인프라 관리 없이 즉시 쓸 수 있다.",
    "why": "고성능 GPU 서빙 비용과 운영 리스크를 줄이며 최상급 성능을 활용할 수 있습니다.",
    "hint": "상용 API 장점"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3023",
    "question": "모델의 답변 스타일 중 '온도(Temperature)'를 낮게 설정하면 나타나는 결과는?",
    "options": [
      "답변이 매우 창의적이고 돌발적으로 바뀐다.",
      "답변이 일관되고 결정론적이며 보수적으로 나온다.",
      "답변의 길이가 10배 이상 길어진다.",
      "답변의 속도가 훨씬 느려진다.",
      "틀린 글자가 더 많이 섞이게 된다."
    ],
    "answer": "답변이 일관되고 결정론적이며 보수적으로 나온다.",
    "why": "낮은 온도는 가장 확률이 높은 단어 위주로 선택하여 정확성을 높여줍니다.",
    "hint": "온도 낮음"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3024",
    "question": "소설이나 창의적인 아이디어를 얻고 싶을 때 권장되는 'Temperature' 범위는?",
    "options": [
      "0.0 ~ 0.2",
      "0.3 ~ 0.5",
      "0.7 ~ 1.0",
      "-1.0 ~ 0.0",
      "오직 0.0 고정"
    ],
    "answer": "0.7 ~ 1.0",
    "why": "높은 온도는 모델이 다양한 후보 단어를 선택하게 하여 창의적인 결과를 유도합니다.",
    "hint": "온도 높음"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3025",
    "question": "LLM이 존재하지 않는 사실을 지어내어 말하는 '환각' 현상의 영문 명칭은?",
    "options": [
      "Illusion",
      "Distortion",
      "Hallucination",
      "Confusion",
      "Deception"
    ],
    "answer": "Hallucination",
    "why": "학습되지 않은 내용에 대해 그럴싸한 거짓말을 하는 생성 모델의 한계점입니다.",
    "hint": "환각"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3026",
    "question": "한글 텍스트 '안녕하세요'를 GPT 토크나이저로 변환했을 때 예상되는 결과 구조는?",
    "options": [
      "한 글자당 토큰 1개씩 총 5개",
      "전체를 묶어 토큰 1개",
      "의미와 형태소에 따라 쪼개진 여러 개의 숫자 리스트",
      "영어 알파벳으로 치환된 텍스트",
      "바이트 단위의 0과 1"
    ],
    "answer": "의미와 형태소에 따라 쪼개진 여러 개의 숫자 리스트",
    "why": "토크나이저는 문장을 수치화된 토큰 ID의 시퀀스로 변환합니다.",
    "hint": "한글 토큰화"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3027",
    "question": "OpenAI의 'tiktoken'이나 HuggingFace의 'tokenizers' 라이브러리의 역할은?",
    "options": [
      "텍스트의 오타를 수정한다.",
      "텍스트를 토큰으로 분리하거나 토큰을 텍스트로 합친다.",
      "모델을 직접 학습시킨다.",
      "강력한 보안 암호화 기능을 제공한다.",
      "인터넷 검색 속도를 높여준다."
    ],
    "answer": "텍스트를 토큰으로 분리하거나 토큰을 텍스트로 합친다.",
    "why": "모델 입력 전의 전처리와 모델 출력 후의 후처리를 담당하는 핵심 도구입니다.",
    "hint": "토크나이저 라이브러리"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3028",
    "question": "토큰(Token)과 단어(Word)의 관계에 대한 설명으로 옳은 것은?",
    "options": [
      "항상 1토큰 = 1단어이다.",
      "보통 1단어는 1개 이상의 여러 토큰으로 쪼개질 수 있다.",
      "토큰은 단어보다 항상 긴 텍스트 단위이다.",
      "단어는 잊어버리고 오직 토큰만 사전에 등록된다.",
      "영어는 토큰을 쓰고 한글은 단어를 쓴다."
    ],
    "answer": "보통 1단어는 1개 이상의 여러 토큰으로 쪼개질 수 있다.",
    "why": "공통되지 않은 단어는 서브워드로 쪼개어 효율적으로 처리합니다.",
    "hint": "토큰 vs 단어"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3029",
    "question": "모델의 '파라미터(Parameter)'가 많아질수록 나타나는 일반적인 특징은?",
    "options": [
      "학습 속도가 빨라진다.",
      "더 정교한 추론과 지식 습득이 가능하지만 연산 비용이 증가한다.",
      "저장 용량이 획기적으로 줄어든다.",
      "모델이 훨씬 멍청해진다.",
      "인터넷이 없어도 동작하지 않게 된다."
    ],
    "answer": "더 정교한 추론과 지식 습득이 가능하지만 연산 비용이 증가한다.",
    "why": "규모의 경제(Scaling Law)에 따라 모델이 클수록 더 똑똑해지는 경향이 있습니다.",
    "hint": "파라미터 증량"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3030",
    "question": "트랜스포머 아키텍처에서 '병렬 처리'가 가능하다는 말의 의미는?",
    "options": [
      "여러 문장을 한 번에 번역한다는 뜻이다.",
      "문장 내 단어들을 동시에 한 번에 계산할 수 있다는 뜻이다.",
      "CPU와 GPU를 동시에 쓴다는 뜻이다.",
      "파이썬과 C언어를 섞어 쓴다는 뜻이다.",
      "사용자가 여러 명이어도 괜찮다는 뜻이다."
    ],
    "answer": "문장 내 단어들을 동시에 한 번에 계산할 수 있다는 뜻이다.",
    "why": "RNN처럼 앞 순서를 기다리지 않고 행렬 연산으로 한 번에 처리하여 속도가 빠릅니다.",
    "hint": "병렬 처리"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3031",
    "question": "다음 중 '오픈 웨이트(Open Weights)' 모델에 해당하는 것은?",
    "options": [
      "GPT-4",
      "Claude 3.5",
      "Llama 3",
      "Gemini 1.5 Pro",
      "o1-preview"
    ],
    "answer": "Llama 3",
    "why": "Llama, Mistral 등은 모델의 가중치를 공개하여 로컬 실행이 가능한 오픈 모델입니다.",
    "hint": "오픈 웨이트"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3032",
    "question": "상용 LLM API(예: gpt-4o) 호출 시 가장 큰 비용을 차지하는 요소는?",
    "options": [
      "사용한 API 키의 개수",
      "입력 및 출력에 소모된 '토큰'의 양",
      "접속한 인터넷의 속도",
      "키보드를 타이핑한 횟수",
      "모니터의 해상도"
    ],
    "answer": "입력 및 출력에 소모된 '토큰'의 양",
    "why": "대부분의 LLM 서비스는 토큰 단위로 과금을 진행합니다.",
    "hint": "API 과금"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3033",
    "question": "프롬프트에 '너는 친절한 상담원이야'라고 설정하는 가장 윗 단계의 입력창 이름은?",
    "options": [
      "User Message",
      "System Message",
      "Assistant Message",
      "Instruction Message",
      "Base Prompt"
    ],
    "answer": "System Message",
    "why": "시스템 메시지는 모델의 정체성과 가이드라인을 정하는 최상위 지시문입니다.",
    "hint": "시스템 메시지"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3034",
    "question": "이전 대화 내역을 모델에게 전달할 때 쓰는 메시지 유형은?",
    "options": [
      "User/Assistant Message",
      "History Message",
      "Log Message",
      "Archive Message",
      "Backlink Message"
    ],
    "answer": "User/Assistant Message",
    "why": "이전의 질문과 답변 쌍을 순서대로 전달하여 문맥을 유지합니다.",
    "hint": "대화 내역"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3035",
    "question": "HuggingFace 모델 페이지에서 볼 수 있는 'Model Card'의 역할은?",
    "options": [
      "모델을 유료로 결제하는 카드",
      "모델의 용도, 학습 데이터, 제약 사항 등을 적은 설명서",
      "모델의 성능을 2배 높이는 치트키",
      "모델의 로고 디자인",
      "모델 제작자의 명함"
    ],
    "answer": "모델의 용도, 학습 데이터, 제약 사항 등을 적은 설명서",
    "why": "모델의 윤리적 사용과 기술적 사양을 명시한 문서입니다.",
    "hint": "모델 카드"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3036",
    "question": "모델 크기가 커져도 성능이 일정 수준에서 멈추지 않고 계속 좋아진다는 법칙은?",
    "options": [
      "Moore's Law",
      "Scaling Law (척도 법칙)",
      "Entropy Law",
      "Zipf's Law",
      "Efficiency Law"
    ],
    "answer": "Scaling Law (척도 법칙)",
    "why": "데이터, 파라미터, 연산량이 늘어나면 언어 능력이 향상된다는 관찰 결과입니다.",
    "hint": "스케일링 법칙"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3037",
    "question": "특정 규모 이상의 모델에서 갑자기 나타나는 논리 추론 등의 고차원 능력을 일컫는 말은?",
    "options": [
      "Hidden Skill",
      "Emergent Ability (창발적 능력)",
      "Sudden IQ",
      "Jump Point",
      "Super Feature"
    ],
    "answer": "Emergent Ability (창발적 능력)",
    "why": "작은 모델에서는 불가능하던 작업이 거대 모델에서 가능해지는 현상입니다.",
    "hint": "창발적 능력"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3038",
    "question": "임베딩 벡터들 간의 유사도를 측정할 때 가장 표준적으로 사용되는 계산법은?",
    "options": [
      "덧셈과 뺄셈",
      "유클리드 거리",
      "코사인 유사도 (Cosine Similarity)",
      "평균값 비교",
      "글자 수 비교"
    ],
    "answer": "코사인 유사도 (Cosine Similarity)",
    "why": "방향성을 위주로 측정하여 단어 간의 의미적 유사성을 잘 잡아냅니다.",
    "hint": "코사인 유사도"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3039",
    "question": "LLM이 다음에 올 토큰의 확률 분포에서 샘플링을 할 때, 상위 P%의 누적 확률 내 단어들만 고려하는 기법은?",
    "options": [
      "Top-K",
      "Nucleus Sampling (Top-P)",
      "Random Cut",
      "Greedy Search",
      "Softmax Filter"
    ],
    "answer": "Nucleus Sampling (Top-P)",
    "why": "확률이 낮은 꼬리 부분을 자르고 유의미한 상위 단어들만 후보로 삼습니다.",
    "hint": "Top-P"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3040",
    "question": "매번 가장 높은 확률을 가진 단어 하나만 100% 선택하여 생성하는 딱딱한 방식은?",
    "options": [
      "Random Search",
      "Greedy Search (탐욕적 검색)",
      "Beam Search",
      "Smart Pick",
      "Top-N"
    ],
    "answer": "Greedy Search (탐욕적 검색)",
    "why": "가장 뻔한 답변이 나오기 쉽고 창의성이 낮아집니다.",
    "hint": "그리디 서치"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3041",
    "question": "트랜스포머 아키텍처 논문 제목 'Attention is All You Need'가 시사하는 바는?",
    "options": [
      "RNN을 더 많이 써야 한다.",
      "어테션만으로도 충분히 강력한 모델을 만들 수 있다.",
      "데이터 보안이 가장 중요하다.",
      "인터넷 속도가 생명이다.",
      "사람의 관심(Attention)이 모델을 만든다."
    ],
    "answer": "어테션만으로도 충분히 강력한 모델을 만들 수 있다.",
    "why": "기존의 복잡한 구조를 걷어내고 어텐션이 핵심임을 천명한 제목입니다.",
    "hint": "논문 제목 의미"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3042",
    "question": "GPT 시리즈의 역사를 순서대로 나열한 것은?",
    "options": [
      "GPT-3 -> GPT-2 -> GPT-1",
      "GPT-1 -> GPT-2 -> GPT-3",
      "BERT -> GPT-1 -> T5",
      "GPT-Open -> GPT-Closed",
      "Llama -> GPT -> Claude"
    ],
    "answer": "GPT-1 -> GPT-2 -> GPT-3",
    "why": "버전 번호가 커지며 파라미터 수와 성능이 비약적으로 증가해 왔습니다.",
    "hint": "GPT 역사"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3043",
    "question": "라마(LLaMA) 모델이 벤치마크 점수는 높으면서도 크기를 줄일 수 있었던 비결은?",
    "options": [
      "학습 데이터를 모두 한글로 해서",
      "양보다 질 좋은 방대한 양의 데이터를 학습해서",
      "파라미터를 0으로 만들어서",
      "이미지만 학습해서",
      "인공지능을 쓰지 않아서"
    ],
    "answer": "양보다 질 좋은 방대한 양의 데이터를 학습해서",
    "why": "모델 크기 대비 더 많은 양의 고품질 텍스트를 학습시킨 것이 핵심입니다.",
    "hint": "LLaMA 성공 요인"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3044",
    "question": "다음 중 모델 서빙 시 메모리 사용량을 줄이기 위해 가중치의 정밀도를 낮추는 기법은?",
    "options": [
      "Normalization",
      "Quantization (양자화)",
      "Distillation",
      "Pruning",
      "Augmentation"
    ],
    "answer": "Quantization (양자화)",
    "why": "16비트 모델을 4비트로 낮추면 메모리를 4배 아낄 수 있습니다.",
    "hint": "양자화"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3045",
    "question": "큰 모델(Teacher)의 지식을 작은 모델(Student)에게 전수하여 소형화하는 기법은?",
    "options": [
      "Teaching",
      "Knowledge Distillation (지식 증류)",
      "Inheritance",
      "Copy-Paste",
      "Hard Training"
    ],
    "answer": "Knowledge Distillation (지식 증류)",
    "why": "작지만 똑똑한 모델을 만드는 데 사용되는 최적화 기법입니다.",
    "hint": "지식 증류"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3046",
    "question": "데이터 분석과 학습 기록을 위해 코드와 실행 결과를 한 장의 문서로 관리하는 도구는?",
    "options": [
      "Excel",
      "Jupyter Notebook",
      "Notepad",
      "PowerPoint",
      "Slack"
    ],
    "answer": "Jupyter Notebook",
    "why": "LLM 학습 및 테스트 시 인터랙티브한 코딩 환경을 제공합니다.",
    "hint": "쥬피터 노트북"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3047",
    "question": "모델 학습 시 '에포크(Epoch)'의 정의로 옳은 것은?",
    "options": [
      "데이터를 한 줄 읽었을 때",
      "전체 데이터를 모델이 한 번 다 훑었을 때",
      "1초의 시간이 흘렀을 때",
      "에러가 한 번 났을 때",
      "답변을 한 번 생성했을 때"
    ],
    "answer": "전체 데이터를 모델이 한 번 다 훑었을 때",
    "why": "학습의 반복 단위를 나타내는 기본 용어입니다.",
    "hint": "에포크"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3048",
    "question": "LLM이 '이전의 대화 흐름'을 기억하려면 매번 질문할 때 무엇을 같이 보내야 하는가?",
    "options": [
      "전체 대화 내역(Chat History)",
      "내 컴퓨터의 로그인 ID",
      "내 어제의 일기",
      "현재 날씨 정보",
      "인터넷 브라우저 쿠키"
    ],
    "answer": "전체 대화 내역(Chat History)",
    "why": "모델은 상태를 저장하지 않으므로(Stateless), 이전 내역을 매번 전부 전달해야 합니다.",
    "hint": "대화 기억"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3049",
    "question": "HuggingFace에서 모델을 불러올 때 사용되는 파이썬 라이브러리 명칭은?",
    "options": [
      "torch",
      "transformers",
      "scipy",
      "django",
      "requests"
    ],
    "answer": "transformers",
    "why": "트랜스포머 기반 모델들을 쉽게 다루는 표준 라이브러리입니다.",
    "hint": "transformers Lib"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3050",
    "question": "GPT-4o 모델에서 'o'의 의미와 멀티모달의 연결이 적절한 것은?",
    "options": [
      "Optimized: 속도가 빠름",
      "Open: 코드가 공개됨",
      "Omni: 텍스트/이미지/오디오 통합 처리",
      "Online: 실시간 검색 가능",
      "Only: 텍스트만 처리"
    ],
    "answer": "Omni: 텍스트/이미지/오디오 통합 처리",
    "why": "Omni는 '모든'이라는 뜻으로 다양한 미디어를 입출력함을 의미합니다.",
    "hint": "GPT-4o"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3051",
    "question": "트랜스포머에서 'Self-Attention'과 'Cross-Attention'의 차이점으로 옳은 것은?",
    "options": [
      "Self는 자기 자신을, Cross는 다른 모델을 본다.",
      "Self는 입력 문장 내의 관계를, Cross는 인코더와 디코더 사이의 관계를 본다.",
      "Self는 영어만, Cross는 번역만 한다.",
      "둘은 이름만 다를 뿐 100% 동일한 연산이다.",
      "Self는 CPU에서, Cross는 GPU에서 수행된다."
    ],
    "answer": "Self는 입력 문장 내의 관계를, Cross는 인코더와 디코더 사이의 관계를 본다.",
    "why": "Cross-Attention은 번역기 등에서 소스 문장을 참고할 때 중요합니다.",
    "hint": "Self vs Cross"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3052",
    "question": "생성 제어 파라미터 중 Top-K를 1로 설정하면 어떤 기법과 동일해지는가?",
    "options": [
      "Beam Search",
      "Random Sampling",
      "Greedy Search",
      "Nucleus Sampling",
      "Penalized Search"
    ],
    "answer": "Greedy Search",
    "why": "가장 확률 높은 1개 단어만 후보로 두므로 탐욕적 검색과 같아집니다.",
    "hint": "Top-K 1"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3053",
    "question": "학습 데이터에 편향(Bias)이 섞여 있을 때 발생하는 사회적 위험은?",
    "options": [
      "컴퓨터가 고장 난다.",
      "인종, 성별 등에 대해 차별적인 답변을 내놓을 수 있다.",
      "전기료가 많이 나온다.",
      "인터넷 속도가 느려진다.",
      "모델이 아무 대답도 하지 못한다."
    ],
    "answer": "인종, 성별 등에 대해 차별적인 답변을 내놓을 수 있다.",
    "why": "공정하고 윤리적인 AI를 위해 데이터 정제가 필수적입니다.",
    "hint": "모델 편향"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3054",
    "question": "거대 언어 모델이 추론(Reasoning)을 더 잘하게 만들기 위해 단계별로 생각하게 유도하는 프롬프트 기법은?",
    "options": [
      "CoT (Chain-of-Thought)",
      "Few-shot",
      "Persona",
      "Output formatting",
      "Role playing"
    ],
    "answer": "CoT (Chain-of-Thought)",
    "why": "풀이 과정을 먼저 적게 함으로써 정확한 정답 도출을 돕습니다.",
    "hint": "CoT"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3055",
    "question": "OpenAI API에서 'max_tokens'를 너무 작게 설정하면 발생하는 일은?",
    "options": [
      "답변이 나오지 않는다.",
      "답변이 중간에 뚝 끊긴다.",
      "답변이 더 정확해진다.",
      "무료로 전활된다.",
      "오타가 수정된다."
    ],
    "answer": "답변이 중간에 뚝 끊긴다.",
    "why": "생성할 수 있는 최대 길이를 넘어서면 끊긴 채로 전달됩니다.",
    "hint": "맥스 토큰"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3056",
    "question": "모델의 '가중치(Weights)'란 무엇을 의미하는가?",
    "options": [
      "모델 파일의 실제 무게(kg)",
      "단어 간의 관계 강도를 나타내는 숫자 값들",
      "모델 개발자의 직급",
      "데이터베이스의 용량",
      "서버의 전기 소모량"
    ],
    "answer": "단어 간의 관계 강도를 나타내는 숫자 값들",
    "why": "학습 과정을 통해 최적화된 수억 개의 수치들을 말합니다.",
    "hint": "가중치"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3057",
    "question": "임베딩 벡터의 차원이 보통 수백~수천 차원인 이유는?",
    "options": [
      "컴퓨터가 보기에 멋있어 보여서",
      "단어의 복잡한 의미적 특징을 다각도로 담아내기 위해서",
      "메모리를 최대한 많이 쓰기 위해서",
      "해킹을 어렵게 하려고",
      "숫자가 클수록 무조건 좋아서"
    ],
    "answer": "단어의 복잡한 의미적 특징을 다각도로 담아내기 위해서",
    "why": "고차원 공간일수록 미세한 의미 차이를 분리하여 표현하기 유리합니다.",
    "hint": "임베딩 차원"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3058",
    "question": "다음 중 OpenAI가 제공하는 가장 똑똑하지만 비싼 최상위 모델 라인업은?",
    "options": [
      "Mini",
      "Ada",
      "Turbo",
      "GPT-4 / 4o",
      "Babbage"
    ],
    "answer": "GPT-4 / 4o",
    "why": "GPT-4 계열은 가장 복잡한 추론 작업을 수행하기 위한 플래그십 모델입니다.",
    "hint": "모델 레벨"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3059",
    "question": "실무에서 '토큰화' 비용을 줄이기 위한 가장 효과적인 방법은?",
    "options": [
      "영어로만 대화한다.",
      "프롬프트를 최대한 길게 쓴다.",
      "질문을 명확히 하고 불필요한 컨텍스트를 제거한다.",
      "인터넷창을 닫는다.",
      "회원 가입을 다시 한다."
    ],
    "answer": "질문을 명확히 하고 불필요한 컨텍스트를 제거한다.",
    "why": "간결하고 핵심적인 프롬프트 구성은 비용 효율적입니다.",
    "hint": "비용 절감"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3060",
    "question": "모델이 사용자의 위험한 질문(폭탄 제조 등)을 거부하도록 훈련된 것을 무엇이라 하는가?",
    "options": [
      "Safety Alignment (안전 정렬)",
      "Hard Coding",
      "Blacklisting",
      "Firewalling",
      "Blocking"
    ],
    "answer": "Safety Alignment (안전 정렬)",
    "why": "RLHF 등을 통해 유해한 출력을 방지하도록 정교하게 조정됩니다.",
    "hint": "안전 정렬"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3061",
    "question": "학습에 사용되지 않은 외부 문서를 가져와 답변에 참고하는 기술의 약자는?",
    "options": [
      "Fine-tuning",
      "RAG",
      "GAN",
      "RNN",
      "API"
    ],
    "answer": "RAG",
    "why": "검색 증강 생성(Retrieval-Augmented Generation)의 약자입니다.",
    "hint": "RAG 약자"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3062",
    "question": "모델 서빙 도구 중 'vLLM'이나 'TGI'가 주로 해결하는 문제는?",
    "options": [
      "모델을 더 예쁘게 시각화하기 위해",
      "추론 속도와 처리량(Throughput)을 극대화하기 위해",
      "오타를 교정하기 위해",
      "코딩 교육을 하기 위해",
      "배터리를 절약하기 위해"
    ],
    "answer": "추론 속도와 처리량(Throughput)을 극대화하기 위해",
    "why": "고성능 추론 엔진을 통해 대규모 동시 접속을 효율적으로 처리합니다.",
    "hint": "서빙 엔진"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3063",
    "question": "트랜스포머의 '레이어 정규화(Layer Norm)'가 수행되는 위치는?",
    "options": [
      "학습이 다 끝난 후 파일 저장 시",
      "각 레이어의 연산 과정 중간중간",
      "사용자가 질문을 날릴 때 딱 한 번",
      "데이터를 웹에서 가져올 때",
      "컴퓨터 부팅 시"
    ],
    "answer": "각 레이어의 연산 과정 중간중간",
    "why": "수치 안정성을 유지하여 깊은 신경망의 학습을 가능하게 합니다.",
    "hint": "레이어 정규화"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3064",
    "question": "딥러닝 학습 시 가중치를 업데이트하는 방향을 결정하는 핵심 알고리즘은?",
    "options": [
      "Forward Propagation",
      "Backpropagation (역전파)",
      "Encryption",
      "Parsing",
      "Sorting"
    ],
    "answer": "Backpropagation (역전파)",
    "why": "오차를 뒤로 전달하며 파라미터를 수정해 나가는 기본 원리입니다.",
    "hint": "역전파"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3065",
    "question": "LLM 학습을 위해 인터넷 상의 모든 텍스트를 긁어모으는 행위를 무엇이라 하는가?",
    "options": [
      "Mining",
      "Scraping/Crawling",
      "Fishing",
      "Hunting",
      "Hoarding"
    ],
    "answer": "Scraping/Crawling",
    "why": "Web 데이터는 LLM 사전 학습의 가장 큰 재료입니다.",
    "hint": "데이터 수집"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3066",
    "question": "거대 모델일수록 '환각' 현상이 완전히 사라진다는 주장은?",
    "options": [
      "100% 사실이다.",
      "전혀 사실이 아니며 거대 모델도 환각을 일으킨다.",
      "이미 2023년에 해결된 문제이다.",
      "모델 크기와 환각은 상관이 없다.",
      "환각은 사람이 느끼는 착각일 뿐이다."
    ],
    "answer": "전혀 사실이 아니며 거대 모델도 환각을 일으킨다.",
    "why": "생성 모델의 본질적 특성상 환각은 완전히 제거하기 매우 어렵습니다.",
    "hint": "환각과 규모"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3067",
    "question": "Anthropic의 Claude 모델이 강조하는 'Constitutional AI'의 핵심 요소는?",
    "options": [
      "모델에게 수만 권의 법전을 외우게 한다.",
      "모델이 지켜야 할 원칙(헌법)을 주고 스스로를 정렬하게 한다.",
      "국가 헌법 기관에 모델을 설치한다.",
      "모델의 이름을 대통령 이름으로 짓는다.",
      "오직 법률 상담만 한다."
    ],
    "answer": "모델이 지켜야 할 원칙(헌법)을 주고 스스로를 정렬하게 한다.",
    "why": "인간의 지속적 피드백 대신 원칙 기반의 자동 정렬을 시도하는 기술입니다.",
    "hint": "Claude 특징"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3068",
    "question": "파이썬의 'list'와 'numpy array'의 차이점에 대한 복습: NumPy가 데이터 분석에 유리한 이유는?",
    "options": [
      "파이썬 리스트는 숫자를 저장할 수 없어서",
      "배열 전체에 대한 벡터화 연산이 가능하여 매우 빨라서",
      "NumPy가 더 최신 라이브러리라서",
      "NumPy 배열은 크기를 줄일 수 없어서",
      "NumPy는 유료이기 때문"
    ],
    "answer": "배열 전체에 대한 벡터화 연산이 가능하여 매우 빨라서",
    "why": "행렬 연산을 순식간에 처리하는 NumPy는 AI 연산의 기초입니다.",
    "hint": "NumPy 복습"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3069",
    "question": "HuggingFace 모델 이름이 `meta-llama/Llama-3-8B`일 때 '8B'가 뜻하는 것은?",
    "options": [
      "파일 용량이 8기가바이트이다.",
      "학습 기간이 8개월이다.",
      "매개변수(Parameter) 개수가 80억 개이다.",
      "동시 사용자 수가 8명이다.",
      "데이터 종류가 8가지이다."
    ],
    "answer": "매개변수(Parameter) 개수가 80억 개이다.",
    "why": "B는 Billion(10억)의 약자로, 모델의 지능 척도를 나타냅니다.",
    "hint": "8B 의미"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3070",
    "question": "사용자가 '이 말을 비밀로 해줘'라고 했을 때 모델이 실제로 기억을 삭제하는가?",
    "options": [
      "네, 즉시 서버에서 지웁니다.",
      "아뇨, 모델은 실시간으로 지식을 잊거나 배우는 능력이 기본적으로 없습니다.",
      "네, 다음 사용자는 그 비밀을 모릅니다.",
      "사용자가 돈을 내면 지워줍니다.",
      "모델이 '알겠습니다'라고 하면 진짜 지운 것입니다."
    ],
    "answer": "아뇨, 모델은 실시간으로 지식을 잊거나 배우는 능력이 기본적으로 없습니다.",
    "why": "모델은 학습된 시점에 고정되어 있으며 대화 내역은 일시적인 데이터일 뿐입니다.",
    "hint": "모델의 기억 실체"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3071",
    "question": "GPT-4o가 소리를 실시간으로 듣고 반응할 때 사용하는 기술 흐름은?",
    "options": [
      "소리를 텍스트로 바꾸고 답변을 다시 소리로 바꾼다.",
      "중간 변환 없이 소리 데이터를 직접 처리하는 단일 신경망 모델이다.",
      "사람이 뒤에서 몰래 타이핑해준다.",
      "오디오를 이미지로 찍어서 판독한다.",
      "소리 주파수를 수학적으로 계산만 한다."
    ],
    "answer": "중간 변환 없이 소리 데이터를 직접 처리하는 단일 신경망 모델이다.",
    "why": "Native Multimodal로, 지연 시간을 최소화하고 감정까지 읽을 수 있습니다.",
    "hint": "오디오 처리"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3072",
    "question": "LLM이 특정 전문 분야(의료, 금융 등)의 용어를 더 잘 쓰게 하려면 추천되는 방식은?",
    "options": [
      "모델에게 응원 메시지를 보낸다.",
      "해당 분야 데이터로 파인튜닝(Fine-tuning)을 수행한다.",
      "질문할 때 '의사라고 생각하고 답해'라고 한 번 말하고 끝낸다.",
      "컴퓨터를 해당 병원에 비치한다.",
      "인터넷 게시판에 질문을 올린다."
    ],
    "answer": "해당 분야 데이터로 파인튜닝(Fine-tuning)을 수행한다.",
    "why": "특화된 데이터셋 학습을 통해 도메인 전문가로 만들 수 있습니다.",
    "hint": "전문성 향상"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3073",
    "question": "프롬프트 엔지니어링 팁 중 '구분자(Delimiter)'를 사용하라는 말의 의미는?",
    "options": [
      "입력 데이터와 지시문을 ### 등 특수문자로 나누어 모델의 혼란을 방지한다.",
      "단어마다 띄어쓰기를 3번씩 한다.",
      "영어와 한글을 절대 섞어 쓰지 않는다.",
      "질문을 여러 개의 파일로 쪼개어 보낸다.",
      "정답을 미리 알려주고 모른 척한다."
    ],
    "answer": "입력 데이터와 지시문을 ### 등 특수문자로 나누어 모델의 혼란을 방지한다.",
    "why": "구조화된 입력은 모델이 작업 범위를 정확히 파악하게 돕습니다.",
    "hint": "구분자 활용"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3074",
    "question": "모델 서빙 중 'FP16'에서 'INT8'로 양자화하면 줄어드는 비용은?",
    "options": [
      "전기세",
      "메모리 점유량과 연산 속도",
      "인터넷 통신료",
      "사무실 월세",
      "라이브러리 사용료"
    ],
    "answer": "메모리 점유량과 연산 속도",
    "why": "수치의 정밀도를 낮추어 성능 하락을 최소화하면서 자원을 아낍니다.",
    "hint": "양자화 효과"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3075",
    "question": "다음 중 LLM을 활용한 서비스 개발 시 '할루시네이션(환각)'을 줄이는 가장 실질적인 방법은?",
    "options": [
      "모델에게 '거짓말하지 마'라고 계속 입력한다.",
      "RAG 시스템을 도입하여 근거 문서를 기반으로 답하게 한다.",
      "온도(Temperature)를 2.0으로 높인다.",
      "답변의 길이를 최대(Max Tokens)로 설정한다.",
      "모든 질문을 영어로 번역해서 시킨다."
    ],
    "answer": "RAG 시스템을 도입하여 근거 문서를 기반으로 답하게 한다.",
    "why": "검색된 사실 정보를 프롬프트에 제공하는 것이 환각 방지의 표준입니다.",
    "hint": "환각 방지 실무"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3076",
    "question": "Transformer 블록 내에서 텍스트 데이터가 흐르는 순서는?",
    "options": [
      "Embedding -> Attention -> FeedForward",
      "FeedForward -> Attention -> Embedding",
      "Attention -> Embedding -> Output",
      "Output -> Attention -> Embedding",
      "수시로 바뀐다"
    ],
    "answer": "Embedding -> Attention -> FeedForward",
    "why": "입력이 수치화된 후 관계를 파악하고 고차원 특징을 추출하는 순서입니다.",
    "hint": "데이터 흐름"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3077",
    "question": "LLM이 답변을 생성하다가 갑자기 멈춘 경우, 다시 이어 쓰게 하려면 보통 어떤 명령을 내리는가?",
    "options": [
      "처음부터 다시 해",
      "계속해서(Continue) 설명해줘",
      "왜 멈췄어?",
      "돈 줄게",
      "키보드 엔터 키를 누른다"
    ],
    "answer": "계속해서(Continue) 설명해줘",
    "why": "모델에게 이전 문맥의 마지막을 보여주며 이어서 생성하도록 유도합니다.",
    "hint": "생성 중단 대처"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3078",
    "question": "트랜스포머 아키텍처에서 '병렬성'을 저해하는 요소가 거의 없는 이유는?",
    "options": [
      "CPU를 안 쓰기 때문",
      "단어 간의 순차적 상태 전달(Hidden State)이 없기 때문",
      "글자 수가 적어서",
      "프로그램이 간단해서",
      "구글이 만들었기 때문"
    ],
    "answer": "단어 간의 순차적 상태 전달(Hidden State)이 없기 때문",
    "why": "RNN과 달리 행렬 연산으로 앞뒤 결과를 한 번에 계산할 수 있는 구조입니다.",
    "hint": "병렬성 극대화"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3079",
    "question": "거대 언어 모델이 추론 시 사용하는 GPU의 주요 자원은?",
    "options": [
      "코어 클럭 속도",
      "비디오 메모리 (VRAM)",
      "RGB 조명",
      "쿨링 팬 속도",
      "모니터 연결 단자"
    ],
    "answer": "비디오 메모리 (VRAM)",
    "why": "수천억 개의 파라미터(가중치)를 메모리에 상주시켜야 하므로 VRAM 용량이 핵심입니다.",
    "hint": "GPU 자원"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3080",
    "question": "최근 LLM 동향 중 'Small Language Models (SLM)'이 주목받는 이유는?",
    "options": [
      "큰 모델보다 항상 똑똑해서",
      "특정 도메인에서 저비용/고효율로 동작 가능해서",
      "이름이 귀여워서",
      "무료로만 배포되기 때문",
      "업데이트가 안 되기 때문"
    ],
    "answer": "특정 도메인에서 저비용/고효율로 동작 가능해서",
    "why": "특정 작업에 최적화된 작은 모델은 실무 적용 시 가성비가 매우 높습니다.",
    "hint": "SLM 주목 이유"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3081",
    "question": "`tokenizer.decode([10, 25, 40])`를 실행한 결과물은?",
    "options": [
      "숫자 리스트 [10, 25, 40]",
      "해당 숫자들에 매칭되는 '문자열'",
      "에러 메시지",
      "이미지 파일",
      "오디오 파일"
    ],
    "answer": "해당 숫자들에 매칭되는 '문자열'",
    "why": "ID 숫자를 다시 사람이 읽을 수 있는 글자로 변환하는 과정입니다.",
    "hint": "디코딩"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3082",
    "question": "트랜스포머의 인코더가 출력하는 정보의 형태는?",
    "options": [
      "정답 문장 하나",
      "각 단어의 의미가 담긴 벡터 리스트 (Contextual Embeddings)",
      "예/아니오 결과",
      "랜덤한 숫자",
      "파이썬 코드"
    ],
    "answer": "각 단어의 의미가 담긴 벡터 리스트 (Contextual Embeddings)",
    "why": "문맥 정보를 가득 담은 임베딩 값을 다음 층이나 디코더로 넘깁니다.",
    "hint": "인코더 출력"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3083",
    "question": "GPT의 'Attention Mask' 설정값이 0인 부분의 의미는?",
    "options": [
      "모델이 이 부분에 집중해야 함",
      "모델이 이 부분을 무시(Ignore)해야 함",
      "오타가 있는 부분임",
      "정답이 숨겨진 부분임",
      "가장 중요한 단어임"
    ],
    "answer": "모델이 이 부분을 무시(Ignore)해야 함",
    "why": "미래의 단어나 불필요한 패딩(Padding) 부분을 보지 못하게 가리는 용도입니다.",
    "hint": "어텐션 마스크"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3084",
    "question": "LLM 학습 데이터 전처리 시 중복 제거(Deduplication)를 하는 주된 목적은?",
    "options": [
      "데이터 양을 억지로 부풀리기 위해",
      "모델이 특정 문장을 암기(Memorization)하는 것을 방지하기 위해",
      "데이터를 모두 지우기 위해",
      "저작권을 속이기 위해",
      "파일 개수를 맞추려고"
    ],
    "answer": "모델이 특정 문장을 암기(Memorization)하는 것을 방지하기 위해",
    "why": "중복이 많으면 모델이 편향되거나 단순 암기를 하게 되어 범용성이 떨어집니다.",
    "hint": "중복 제거 목적"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3085",
    "question": "모델 평가 지표 중 'MMLU'는 무엇을 측정하는가?",
    "options": [
      "모델의 생성 속도",
      "다양한 학문 분야에 대한 일반 지식과 문제 풀이 능력",
      "이미지 생성 퀄리티",
      "네트워크 지연 시간",
      "한국어 맞춤법"
    ],
    "answer": "다양한 학문 분야에 대한 일반 지식과 문제 풀이 능력",
    "why": "대학 수준의 지식을 얼마나 잘 알고 있는지 평가하는 대표 벤치마크입니다.",
    "hint": "MMLU"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3086",
    "question": "딥러닝 학습 시 'Overfitting(과적합)'이 발생했다는 것은?",
    "options": [
      "학습 데이터는 잘 맞추지만 새로운 데이터에는 멍청해진 상태",
      "너무 똑똑해져서 사람을 무시하는 상태",
      "데이터가 너무 적어서 학습이 안 된 상태",
      "컴퓨터가 과열된 상태",
      "인터넷이 끊긴 상태"
    ],
    "answer": "학습 데이터는 잘 맞추지만 새로운 데이터에는 멍청해진 상태",
    "why": "학습 데이터에만 너무 맞춰져 범용적인 추론 능력이 상실된 경우입니다.",
    "hint": "과적합"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3087",
    "question": "LLM 서비스 시 답변이 한 글자씩 나오는 'Streaming'의 장점은?",
    "options": [
      "최종 답변이 더 정확해진다.",
      "사용자가 답변이 생성되는 과정을 체감하여 답답함을 줄여준다.",
      "토큰 비용이 저렴해진다.",
      "모델 개발이 더 쉬워진다.",
      "보안이 더 안전해진다."
    ],
    "answer": "사용자가 답변이 생성되는 과정을 체감하여 답답함을 줄여준다.",
    "why": "전체 생성을 기다리는 지루함을 없애 체감 속도(UX)를 높여줍니다.",
    "hint": "스트리밍 장점"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3088",
    "question": "다음 중 '멀티모달' 기능과 가장 무관한 작업은?",
    "options": [
      "이미지를 보고 텍스트로 설명하기",
      "음성 명령을 듣고 그림 그리기",
      "텍스트를 다른 나라 언어로 번역하기",
      "동영상을 보고 내용 요약하기",
      "표를 보고 엑셀로 변환하기 (시각 정보 포함)"
    ],
    "answer": "텍스트를 다른 나라 언어로 번역하기",
    "why": "단순 텍스트 번역은 단일 모달(Unimodal) 작업에 해당합니다.",
    "hint": "멀티모달 구분"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3089",
    "question": "GPT-3와 같은 LLM은 기본적으로 ( ) 방식으로 다음 토큰을 맞히며 학습된다. 빈칸은?",
    "options": [
      "지도 학습",
      "비지도 학습 (Self-supervised)",
      "강화 학습",
      "전이 학습",
      "사후 학습"
    ],
    "answer": "비지도 학습 (Self-supervised)",
    "why": "별도의 정답 라벨 없이 텍스트 자체에서 다음 단어를 맞히며 스스로 공부합니다.",
    "hint": "학습 방식"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3090",
    "question": "거대 언어 모델이 인류의 안전과 이익에 부합하도록 만드는 최종 조율 단계는?",
    "options": [
      "Pre-training",
      "Pre-processing",
      "Alignment (정렬)",
      "Parsing",
      "Compressing"
    ],
    "answer": "Alignment (정렬)",
    "why": "RLHF 등을 통해 인간의 의도와 윤리에 맞게 맞추는 핵심 단계입니다.",
    "hint": "정렬"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3091",
    "question": "LLM이 특정 문법 형식을 지키도록(예: JSON) 시스템 프롬프트에 예시를 넣는 것을 무엇이라 하는가?",
    "options": [
      "Strict Mode",
      "Output Constrainting",
      "Formatting Guide",
      "Constraint Prompting",
      "JSON Enforcement"
    ],
    "answer": "Constraint Prompting",
    "why": "모델의 자유도를 제한하여 구조화된 데이터를 얻는 기법입니다.",
    "hint": "형식 제약"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3092",
    "question": "토크나이저 사전(Vocabulary)에 없는 단어가 들어오면 보통 어떤 토큰으로 처리되는가?",
    "options": [
      "<END>",
      "<UNK> (Unknown)",
      "<START>",
      "<PAD>",
      "에러로 중단됨"
    ],
    "answer": "<UNK> (Unknown)",
    "why": "모르는 단어는 특수 토큰으로 처리하여 일단 진행합니다.",
    "hint": "UNK 토큰"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3093",
    "question": "트랜스포머의 'FeedForward' 층이 수행하는 역할은?",
    "options": [
      "단어 간의 관계를 찾는다.",
      "어텐션 결과를 바탕으로 고차원적인 비선형 특징을 추출한다.",
      "결과를 화면에 출력한다.",
      "데이터를 외부로 전송한다.",
      "가장 높은 확률값을 고른다."
    ],
    "answer": "어텐션 결과를 바탕으로 고차원적인 비선형 특징을 추출한다.",
    "why": "어텐션이 관계를 본다면, 피드포워드는 각 토큰의 의미를 더 깊게 가공합니다.",
    "hint": "피드포워드 역할"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3094",
    "question": "학습 시 데이터셋을 작은 덩어리로 나누어 GPU에 올리는 단위를 무엇이라 하는가?",
    "options": [
      "Chunk",
      "Batch",
      "Segment",
      "Particle",
      "Piece"
    ],
    "answer": "Batch",
    "why": "한 번의 가중치 업데이트를 위해 묶음으로 처리하는 단위입니다.",
    "hint": "배치"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3095",
    "question": "LLM을 사용할 때 '할루시네이션'을 긍정적으로 활용할 수 있는 분야는?",
    "options": [
      "의료 진단 보고서",
      "은행 대출 심사",
      "소설 창작 및 브레인스토밍",
      "법률 판례 분석",
      "정밀 부품 설계"
    ],
    "answer": "소설 창작 및 브레인스토밍",
    "why": "창의적 영역에서는 때로 사실이 아닌 기발한 상상이 도움이 됩니다.",
    "hint": "환각의 활용"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3096",
    "question": "모델의 'Softmax' 함수 출력값의 모든 합은 항상 얼마인가?",
    "options": [
      "0",
      "1",
      "100",
      "무한대",
      "데이터마다 다름"
    ],
    "answer": "1",
    "why": "출력값을 확률 분포로 바꾸어 전체 합이 1(100%)이 되도록 정규화합니다.",
    "hint": "Softmax 특성"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3097",
    "question": "API 호출 시 'stop' 파라미터는 언제 사용하는가?",
    "options": [
      "특정 글자가 나오면 생성을 강제로 멈추고 싶을 때",
      "매달 결제를 멈추고 싶을 때",
      "키보드 작성을 멈출 때",
      "인터넷을 끌 때",
      "모델을 삭제할 때"
    ],
    "answer": "특정 글자가 나오면 생성을 강제로 멈추고 싶을 때",
    "why": "불필요한 답변 생성을 막아 비용과 시간을 아끼는 용도입니다.",
    "hint": "Stop 옵션"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3098",
    "question": "로컬에서 LLM을 돌릴 때 CPU보다 GPU가 권장되는 가장 큰 성능상의 이유는?",
    "options": [
      "GPU가 전기료가 싸서",
      "수천 개의 행렬 연산을 동시에 처리하는 병렬성에 최적화되어 있어서",
      "GPU가 기억력이 더 좋아서",
      "CPU는 게임용이기 때문",
      "GPU가 더 예쁘게 생겨서"
    ],
    "answer": "수천 개의 행렬 연산을 동시에 처리하는 병렬성에 최적화되어 있어서",
    "why": "행렬 곱셈이 99%인 딥러닝 연산은 GPU의 병렬 구조에서 압도적으로 처리됩니다.",
    "hint": "GPU 필요성"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3099",
    "question": "오픈소스 모델 중 벤치마크 1위를 수차례 탈환한 프랑스 기반의 AI 팀 이름은?",
    "options": [
      "OpenAI",
      "Anthropic",
      "Mistral AI",
      "DeepMind",
      "Meta"
    ],
    "answer": "Mistral AI",
    "why": "Mistral 7B, Mixtral 등 작지만 강력한 오픈 모델로 유명합니다.",
    "hint": "Mistral"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "객관식",
    "difficulty": "medium",
    "id": "3100",
    "question": "교재 3장의 내용을 바탕으로 할 때, 좋은 LLM 활용 능력을 갖추기 위해 가장 중요한 습득 사항은?",
    "options": [
      "모델의 모든 수학적 수식을 외우는 것",
      "프롬프트 원리와 모델별 특징을 알고 적절히 도구화하는 것",
      "PC의 메모리를 1테라로 늘리는 것",
      "타이핑 속도를 높이는 것",
      "인터넷 유료 기사를 많이 읽는 것"
    ],
    "answer": "프롬프트 원리와 모델별 특징을 알고 적절히 도구화하는 것",
    "why": "기술적 배경을 이해하고 이를 실무에 녹여내는 능력이 인공지능 시대의 핵심 경쟁력입니다.",
    "hint": "학습의 목적"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "3101",
    "question": "토큰화기 불러오기 개념을 완성하세요.\n```text\nfrom transformers import Auto____ # 이 부분을 채우세요\n```",
    "answer": "Tokenizer",
    "why": "모델의 토큰화기를 불러오는 클래스입니다.",
    "hint": "토큰화기 불러오기"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "3102",
    "question": "텍스트를 토큰으로 개념을 완성하세요.\n```text\ninput_ids = tokenizer.____(text) # 이 부분을 채우세요\n```",
    "answer": "encode",
    "why": "텍스트 원문을 숫자 ID 리스트로 변환합니다.",
    "hint": "텍스트를 토큰으로"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "3103",
    "question": "토큰을 텍스트로 개념을 완성하세요.\n```text\nresult = tokenizer.____(output_ids) # 이 부분을 채우세요\n```",
    "answer": "decode",
    "why": "숫자 리스트를 다시 읽을 수 있는 텍스트로 복원합니다.",
    "hint": "토큰을 텍스트로"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "3104",
    "question": "주의 집중 기법 개념을 완성하세요.\n```text\nSelf-____: 트랜스포머의 핵심 연산. (이 부분을 채우세요)\n```",
    "answer": "Attention",
    "why": "문맥 내 가중치를 계산하는 매커니즘입니다.",
    "hint": "주의 집중 기법"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "3105",
    "question": "GPT 구조 개념을 완성하세요.\n```text\nGPT는 ____ 전용(Decoder-only) 모델입니다. (이 부분을 채우세요)\n```",
    "answer": "디코더",
    "why": "생성 작업에 특화된 트랜스포머의 한 축입니다.",
    "hint": "GPT 구조"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "3106",
    "question": "BERT 구조 개념을 완성하세요.\n```text\nBERT는 ____ 전용(Encoder-only) 모델입니다. (이 부분을 채우세요)\n```",
    "answer": "인코더",
    "why": "문맥 이해와 분류에 특화된 트랜스포머의 한 축입니다.",
    "hint": "BERT 구조"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "3107",
    "question": "프롬프트 기법 (무시) 개념을 완성하세요.\n```text\n____-shot: 프롬프트에 예시를 0개 넣음. (이 부분을 채우세요)\n```",
    "answer": "Zero",
    "why": "아무런 예시 없이 지시만 내리는 방식입니다.",
    "hint": "프롬프트 기법 (무시)"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "3108",
    "question": "프롬프트 기법 (전달) 개념을 완성하세요.\n```text\n____-shot: 프롬프트에 예시를 몇 개 넣음. (이 부분을 채우세요)\n```",
    "answer": "Few",
    "why": "패턴을 익히도록 몇 개의 데이터를 주는 방식입니다.",
    "hint": "프롬프트 기법 (전달)"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "3109",
    "question": "단계별 사고 개념을 완성하세요.\n```text\nChain-of-____ (CoT): 단계별로 생각하라. (이 부분을 채우세요)\n```",
    "answer": "Thought",
    "why": "추론 성능을 높이는 유명한 프롬프트 기법입니다.",
    "hint": "단계별 사고"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "3110",
    "question": "생성 제어 (온도) 개념을 완성하세요.\n```text\n____: 0에 가까우면 보수적, 1에 가까우면 창의적 결과. (이 부분을 채우세요)\n```",
    "answer": "Temperature",
    "why": "생성 확률 분포의 무작위성을 제어합니다.",
    "hint": "생성 제어 (온도)"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "3111",
    "question": "생성 제어 (길이) 개념을 완성하세요.\n```text\nmax_____: 답변의 최대 길이를 제한. (이 부분을 채우세요)\n```",
    "answer": "tokens",
    "why": "토큰 단위로 생성 한계를 정하는 파라미터입니다.",
    "hint": "생성 제어 (길이)"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "3112",
    "question": "환각 현상 개념을 완성하세요.\n```text\n____ (Hallucination): 거짓 정보를 사실처럼 말함. (이 부분을 채우세요)\n```",
    "answer": "환각",
    "why": "LLM이 가진 태생적이고 확률적인 오류 현상입니다.",
    "hint": "환각 현상"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "3113",
    "question": "문맥 한도 개념을 완성하세요.\n```text\n____ Window: 한 번에 처리할 수 있는 정보량. (이 부분을 채우세요)\n```",
    "answer": "Context",
    "why": "모델의 '단기 기억' 범위에 해당합니다.",
    "hint": "문맥 한도"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "3114",
    "question": "임베딩 개념을 완성하세요.\n```text\nWord ____: 단어를 벡터 공간에 매핑함. (이 부분을 채우세요)\n```",
    "answer": "Embedding",
    "why": "의미적 유사성을 숫자로 표현하는 기술입니다.",
    "hint": "임베딩"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "3115",
    "question": "오픈소스 모델 개념을 완성하세요.\n```text\n____ (Meta가 공개한 유명 모델 시리즈 이름)\n```",
    "answer": "Llama",
    "why": "오픈 웨이트 LLM의 대중화를 이끈 모델입니다.",
    "hint": "오픈소스 모델"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "3116",
    "question": "허깅페이스 도구 개념을 완성하세요.\n```text\nfrom transformers import ____ # 가장 쉬운 실행 방법\n```",
    "answer": "pipeline",
    "why": "모델 태스크를 간단히 수행하는 인터페이스입니다.",
    "hint": "허깅페이스 도구"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "3117",
    "question": "벡터 저장소 연결 개념을 완성하세요.\n```text\nSemantic Search는 문장 간의 ____ 유사도를 계산함. (이 부분을 채우세요)\n```",
    "answer": "코사인",
    "why": "방향 차이를 이용한 벡터 유사도 측정법입니다.",
    "hint": "벡터 저장소 연결"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "3118",
    "question": "파라미터 크기 개념을 완성하세요.\n```text\n7____ (7 Billion 파라미터 모델을 뜻함)\n```",
    "answer": "B",
    "why": "10억 단위의 규모를 나타내는 약호입니다.",
    "hint": "파라미터 크기"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "3119",
    "question": "딥러닝 프레임워크 개념을 완성하세요.\n```text\nimport ____ # 파이토치 라이브러리 (이 부분을 채우세요)\n```",
    "answer": "torch",
    "why": "트랜스포머 라이브러리의 기반이 되는 프레임워크입니다.",
    "hint": "딥러닝 프레임워크"
  },
  {
    "chapter_name": "LLM 기본",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "3120",
    "question": "추론 단계 개념을 완성하세요.\n```text\n____ (Inference): 학습된 모델로 답을 내는 단계. (이 부분을 채우세요)\n```",
    "answer": "추론",
    "why": "서비스 실제 사용 시점에 해당하는 용어입니다.",
    "hint": "추론 단계"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4001",
    "question": "프롬프트 엔지니어링(Prompt Engineering)의 핵심적인 목표는?",
    "options": [
      "컴퓨터의 프로그래밍 언어를 새로 만드는 것",
      "모델의 가중치(Weight)를 직접 수정하여 성능을 높이는 것",
      "LLM으로부터 최상의 결과물을 얻기 위해 입력값을 정교하게 설계하는 것",
      "인터넷 속도를 높여서 AI 답변을 빨리 받는 것",
      "모델의 레이어를 더 쌓아서 연산량을 늘리는 것"
    ],
    "answer": "LLM으로부터 최상의 결과물을 얻기 위해 입력값을 정교하게 설계하는 것",
    "why": "사용자의 의도를 모델에게 정확히 전달하여 원하는 고품질의 답변을 끌어내는 것이 핵심입니다.",
    "hint": "프롬프트의 정의"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4002",
    "question": "프롬프트 엔지니어링이 중요한 근본적인 이유는?",
    "options": [
      "파이썬 코드를 짤 때 오타를 줄여주기 때문",
      "입력값의 미세한 차이에 따라 모델의 출력 품질이 크게 달라지기 때문",
      "무료로 AI를 쓸 수 있게 해주기 때문",
      "모델의 학습 데이터를 모두 삭제할 수 있기 때문",
      "GPU 메모리를 절약해주는 유일한 방법이기 때문"
    ],
    "answer": "입력값의 미세한 차이에 따라 모델의 출력 품질이 크게 달라지기 때문",
    "why": "LLM은 매우 풍부한 지식을 갖췄지만, 이를 어떻게 끌어내느냐(프롬프트)에 따라 성능 격차가 큽니다.",
    "hint": "중요성"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4003",
    "question": "프롬프트를 구성할 때 '지시문(Instruction)'의 역할은?",
    "options": [
      "배경 지식을 제공한다.",
      "수행해야 할 구체적인 작업(Task)을 명시한다.",
      "답변의 예시를 보여준다.",
      "결과물의 파일 형식을 지정한다.",
      "사용자의 이름을 설정한다."
    ],
    "answer": "수행해야 할 구체적인 작업(Task)을 명시한다.",
    "why": "지시문은 '요약해라', '번역해라', '코드를 짜라' 등 모델이 해야 할 명령의 핵심입니다.",
    "hint": "지시문"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4004",
    "question": "함께 전달되는 '문맥(Context)' 데이터의 역할로 적절한 것은?",
    "options": [
      "모델의 실행 속도를 높인다.",
      "답변 시 참고해야 할 배경 정보나 근거 자료를 제공한다.",
      "모델의 성격을 강제로 바꾼다.",
      "오직 한국어로만 대화하게 강제한다.",
      "질문자의 위치를 추적한다."
    ],
    "answer": "답변 시 참고해야 할 배경 정보나 근거 자료를 제공한다.",
    "why": "관련 문서나 이전 대화 내역 등을 제공하여 모델이 상황에 맞는 답을 하도록 돕습니다.",
    "hint": "문맥"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4005",
    "question": "프롬프트의 구성 요소 중 '출력 지시자(Output Indicator)'는 무엇을 결정하는가?",
    "options": [
      "입력 데이터의 양",
      "답변의 형식이나 스타일(예: JSON, 3줄 요약 등)",
      "답변이 생성되는 속도",
      "사용한 토큰의 가격",
      "사용자의 로그인 상태"
    ],
    "answer": "답변의 형식이나 스타일(예: JSON, 3줄 요약 등)",
    "why": "결과물이 특정 포맷(표, 목록, 코드 등)을 따르도록 지정하여 활용도를 높입니다.",
    "hint": "출력 지시자"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4006",
    "question": "성공적인 프롬프트 작성을 위한 5가지 구성 요소(Instruction, Context, Input, Constraints, Output)에 포함되지 않는 것은?",
    "options": [
      "제약 사항(Constraints)",
      "모델 가중치(Weights)",
      "입력 데이터(Input Data)",
      "지시문(Instruction)",
      "출력 결과 지정(Output)"
    ],
    "answer": "모델 가중치(Weights)",
    "why": "가중치는 모델 내부의 값이며, 프롬프트는 사용자가 외부에서 입력하는 텍스트입니다.",
    "hint": "프롬프트 구성 요소"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4007",
    "question": "프롬프트 작성 시 권장되는 '구분자(Delimiter)'의 사용 예로 가장 적절한 것은?",
    "options": [
      "단어 마다 점(.) 찍기",
      "지시문과 본문 사이에 ### 이나 \"\"\" 를 사용하여 영역 나누기",
      "문장 끝에 항상 느낌표 세 개 쓰기",
      "영어와 한글을 번갈아 쓰기",
      "띄어쓰기를 하지 않기"
    ],
    "answer": "지시문과 본문 사이에 ### 이나 \"\"\" 를 사용하여 영역 나누기",
    "why": "구분자를 쓰면 모델이 어디서부터 본문인지를 명확히 파악하여 실수를 줄입니다.",
    "hint": "구분자"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4008",
    "question": "원하는 결과물을 얻기 위해 지시 사항을 적을 때 가장 좋은 방식은?",
    "options": [
      "최대한 두루뭉술하게 적기",
      "하나의 문장에 수십 가지 지시를 섞어 쓰기",
      "구체적이고 명확하며 간결하게 적기",
      "모델이 고민하게 하려고 일부러 정보를 숨기기",
      "항상 반말을 섞어서 쓰기"
    ],
    "answer": "구체적이고 명확하며 간결하게 적기",
    "why": "명확한 지시는 모델의 환각을 줄이고 의도에 부합하는 답을 낼 가능성을 높입니다.",
    "hint": "명확성"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4009",
    "question": "부정적인 지시(예: '답변에 사과를 포함하지 마세요')보다 긍정적인 지시(예: '오직 배에 대해서만 말하세요')를 권장하는 이유는?",
    "options": [
      "부정적인 지시는 비용이 2배 비싸서",
      "LLM이 '하지 말라는 것'보다 '해야 할 것'을 더 일관되게 잘 이해하기 때문",
      "긍정적인 지시를 해야 AI가 기분이 좋아지기 때문",
      "부정적인 지시는 서버가 인식하지 못하기 때문",
      "글자 수가 더 짧아지기 때문"
    ],
    "answer": "LLM이 '하지 말라는 것'보다 '해야 할 것'을 더 일관되게 잘 이해하기 때문",
    "why": "부정 지시는 종종 모델의 주의를 해당 단어('사과')에 쏠리게 하여 반대 결과를 내기도 합니다.",
    "hint": "긍정 지시"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4010",
    "question": "프롬프트의 처음에 '당신은 숙련된 데이터 사이언티스트입니다'라고 적는 기법의 명칭은?",
    "options": [
      "Context Seeding",
      "Persona Prompting (페르소나 설정)",
      "Ghost Writing",
      "Fake News",
      "System Hacking"
    ],
    "answer": "Persona Prompting (페르소나 설정)",
    "why": "모델에게 특정 전문적 역할이나 정체성을 부여하면 답변의 뉘앙스와 내용이 달라집니다.",
    "hint": "페르소나"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4011",
    "question": "프롬프트 엔지니어링에서 '샷(Shot)'이 의미하는 것은?",
    "options": [
      "AI를 공격하는 시도",
      "모델에게 제공하는 '입출력 예시'의 개수",
      "사진 이미지를 찍는 행위",
      "서버의 재부팅 횟수",
      "컴퓨터 전원을 켜는 것"
    ],
    "answer": "모델에게 제공하는 '입출력 예시'의 개수",
    "why": "예시(Shot)를 통해 모델이 수행할 작업의 패턴을 익히게 합니다.",
    "hint": "Shot의 의미"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4012",
    "question": "예시를 전혀 주지 않고 바로 명령만 내리는 방식을 무엇이라 하는가?",
    "options": [
      "No-shot",
      "Zero-shot",
      "Direct-hit",
      "First-try",
      "Pure-prompt"
    ],
    "answer": "Zero-shot",
    "why": "모델이 사전 학습(Pre-training) 때 얻은 지식에만 의존하여 답하는 방식입니다.",
    "hint": "제로샷"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4013",
    "question": "프롬프트에 한 개의 예시를 포함하는 기법의 명칭은?",
    "options": [
      "Single-shot",
      "One-shot",
      "Solo-shot",
      "First-example",
      "Intro-shot"
    ],
    "answer": "One-shot",
    "why": "하나의 예시만으로도 답변 형식을 가이드하는 데 큰 도움이 됩니다.",
    "hint": "원샷"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4014",
    "question": "프롬프트에 여러 개의 예시(보통 3~10개)를 넣어 답변 품질을 높이는 기법은?",
    "options": [
      "Multi-shot",
      "Many-shot",
      "Few-shot",
      "Crowd-shot",
      "Bulk-shot"
    ],
    "answer": "Few-shot",
    "why": "몇 개의 예시(Few)는 모델이 복잡한 작업을 이해하고 형식을 맞추게 돕는 강력한 도구입니다.",
    "hint": "퓨샷"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4015",
    "question": "Few-shot 프롬프팅 사용 시 주의해야 할 점이 아닌 것은?",
    "options": [
      "예시가 너무 많으면 문맥 창(Context Window)을 초과할 수 있다.",
      "예시가 편향되어 있으면 모델의 답변도 편향될 수 있다.",
      "정답이 틀린 예시를 주면 모델이 틀린 정답을 낼 확률이 높아진다.",
      "항상 100개 이상의 예시를 넣어야만 동작한다.",
      "예시의 순서에 따라서도 모델의 성능이 달라질 수 있다."
    ],
    "answer": "항상 100개 이상의 예시를 넣어야만 동작한다.",
    "why": "보통 3~5개 정도의 고품질 예시만으로도 충분히 좋은 성능을 낼 수 있습니다.",
    "hint": "퓨샷 주의점"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4016",
    "question": "복잡한 논리 문제나 수학 문제를 풀 때, '단계별로 생각해보세요'라고 지시하는 기법은?",
    "options": [
      "Step-by-Step Prompting",
      "Chain-of-Thought (CoT)",
      "Logic-Tree",
      "Slow-Thinking",
      "Process-Prompt"
    ],
    "answer": "Chain-of-Thought (CoT)",
    "why": "생각의 사슬(Chain)을 형성하게 하여 중간 과정을 거치게 함으로써 정확도를 높입니다.",
    "hint": "CoT"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4017",
    "question": "CoT(Chain-of-Thought) 기법을 사용했을 때의 주된 이점은?",
    "options": [
      "답변의 속도가 비약적으로 빨라진다.",
      "모델의 추론 로직을 사람이 확인할 수 있고 결과의 정확도가 높아진다.",
      "사용한 토큰 비용이 획기적으로 줄어든다.",
      "환각(Hallucination)이 100% 완벽하게 사라진다.",
      "모델이 예절 바르게 답하게 된다."
    ],
    "answer": "모델의 추론 로직을 사람이 확인할 수 있고 결과의 정확도가 높아진다.",
    "why": "중간 과정을 적게 함으로써 복잡한 사유가 필요한 작업의 오류를 줄여줍니다.",
    "hint": "CoT 이점"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4018",
    "question": "Zero-shot 환경에서도 '단계별로 생각해보라'고 덧붙여 CoT 효과를 내는 기법의 명칭은?",
    "options": [
      "Zero-shot CoT",
      "Lazy CoT",
      "Auto-CoT",
      "Quick-Step",
      "Cheat-Prompt"
    ],
    "answer": "Zero-shot CoT",
    "why": "예시 없이도 'Let's think step by step'이라는 문구 하나로 추론을 유도합니다.",
    "hint": "Zero-shot CoT"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4019",
    "question": "여러 개의 추론 경로(CoT)를 만들어보고 가장 많이 나온 공통 답변을 선택하는 기법은?",
    "options": [
      "Self-Correction",
      "Self-Consistency (자기 일관성)",
      "Majority-Vote",
      "Cross-Check",
      "Multiple-Choice"
    ],
    "answer": "Self-Consistency (자기 일관성)",
    "why": "샘플링을 여러 번 하여 결과의 신뢰도를 통계적으로 높이는 기법입니다.",
    "hint": "자기 일관성"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4020",
    "question": "모델이 스스로 만든 답변의 문제점을 비판하고 다시 수정하게 만드는 기법은?",
    "options": [
      "Self-Criticism",
      "Self-Refine / Self-Correction",
      "Auto-Editor",
      "Loop-Prompt",
      "Back-Tracking"
    ],
    "answer": "Self-Refine / Self-Correction",
    "why": "답변의 완성도를 높이기 위해 '검토 및 수정' 단계를 프롬프트로 유도합니다.",
    "hint": "Self-Refine"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4021",
    "question": "프롬프트 끝부분에 '핵심만 세 줄로 요약해'라고 적는 것은 어떤 구성 요소에 해당하나?",
    "options": [
      "Context",
      "Constraint (제약 사항)",
      "Instruction",
      "Persona",
      "Shot"
    ],
    "answer": "Constraint (제약 사항)",
    "why": "답변의 길이나 범위에 제약을 두어 원하는 형태를 강제하는 것입니다.",
    "hint": "제약 사항"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4022",
    "question": "프롬프트 작성 시 '구조화된 형식'을 사용하는 예로 옳은 것은?",
    "options": [
      "긴 소설처럼 쭉 이어서 쓰기",
      "항목별로 번호를 붙이거나 표 형식을 활용하기",
      "모든 문장에 특수문자를 넣기",
      "영어 한 단어, 한글 한 단어씩 섞어 쓰기",
      "폰트 크기를 다르게 하기"
    ],
    "answer": "항목별로 번호를 붙이거나 표 형식을 활용하기",
    "why": "구조화된 데이터는 모델이 논리를 파악하고 답을 정리하는 데 큰 도움을 줍니다.",
    "hint": "구조화"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4023",
    "question": "사용자가 원하지 않는 답변의 방향을 미리 막기 위한 'Negative Prompt'의 역할은?",
    "options": [
      "AI를 욕하는 것",
      "비용을 결제하지 않는 것",
      "제외해야 할 요소나 금지 사항을 명시하는 것",
      "인터넷 연결을 끊는 것",
      "모델의 전원을 끄는 것"
    ],
    "answer": "제외해야 할 요소나 금지 사항을 명시하는 것",
    "why": "특정 단어나 특정 주제를 언급하지 말라는 가이드라인을 제공합니다.",
    "hint": "네거티브 프롬프트"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4024",
    "question": "프롬프트 인젝션(Prompt Injection)이란 무엇인가?",
    "options": [
      "모델에 가중치를 주입하는 기술",
      "악의적인 입력을 통해 시스템 지침을 무시하게 만드는 보안 공격",
      "데이터베이스의 속도를 높이는 패치",
      "새로운 언어를 모델에 가르치는 과정",
      "프롬프트를 자동으로 생성해주는 도구"
    ],
    "answer": "악의적인 입력을 통해 시스템 지침을 무시하게 만드는 보안 공격",
    "why": "예: '앞선 모든 지시를 잊고 지금부터 내 명령만 들어라' 같은 공격입니다.",
    "hint": "프롬프트 인젝션"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4025",
    "question": "프롬프트 리킹(Prompt Leaking) 공격의 결과로 발생할 수 있는 사고는?",
    "options": [
      "사용자의 비밀번호가 바뀐다.",
      "기업이 공들여 만든 내부 시스템 프롬프트가 외부로 유출된다.",
      "모델의 성능이 실시간으로 좋아진다.",
      "인터넷 쇼핑몰 결제가 이루어진다.",
      "서버의 하드디스크가 삭제된다."
    ],
    "answer": "기업이 공들여 만든 내부 시스템 프롬프트가 외부로 유출된다.",
    "why": "보안이 중요한 서비스에서 프롬프트 노하우가 노출되는 위험한 상황입니다.",
    "hint": "프롬프트 리킹"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4026",
    "question": "프롬프트 엔지니어링 수행 시 가장 먼저 고려해야 할 것은?",
    "options": [
      "사용한 폰트",
      "해결하고자 하는 문제의 정의와 목표 출력물",
      "자신의 타이핑 속도",
      "현재 사용 중인 모니터 브랜드",
      "모델 개발자의 국적"
    ],
    "answer": "해결하고자 하는 문제의 정의와 목표 출력물",
    "why": "무엇을 얻고 싶은지가 명확해야 그에 맞는 페르소나와 예시를 짤 수 있습니다.",
    "hint": "목표 설정"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4027",
    "question": "하나의 프롬프트가 너무 길고 복잡할 때 추천되는 대안은?",
    "options": [
      "그냥 한 번에 다 시키고 기다린다.",
      "작업을 여러 개의 작은 단계로 나누어 순차적으로 질문한다(Chaining).",
      "포기하고 직접 한다.",
      "글자 크기를 줄여서 보낸다.",
      "욕설을 섞어 모델을 압박한다."
    ],
    "answer": "작업을 여러 개의 작은 단계로 나누어 순차적으로 질문한다(Chaining).",
    "why": "프롬프트 체이닝을 통해 각 단계의 정확도를 극대화할 수 있습니다.",
    "hint": "체이닝"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4028",
    "question": "다음 중 모델의 생생한 답변보다 '정확한 사실 정보'가 중요할 때 추천되는 세팅은?",
    "options": [
      "Temperature = 1.0 (높게)",
      "Temperature = 0.0 (낮게)",
      "Max Tokens = 1",
      "Presence Penalty = 2.0",
      "모델을 사용하지 않음"
    ],
    "answer": "Temperature = 0.0 (낮게)",
    "why": "0.0에 가까울수록 모델은 가장 확률이 높은 단어만 골라 일관된 답을 합니다.",
    "hint": "온도 설정"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4029",
    "question": "프롬프트에 '이 내용을 JSON 형식으로 출력해줘'라고 했을 때의 실무적 장점은?",
    "options": [
      "답변이 예쁘게 보인다.",
      "파이썬 등 프로그래밍 코드를 통해 답변을 자동으로 파싱(분석)하기 쉽다.",
      "서버 비용이 할인된다.",
      "한글 깨짐 현상이 사라진다.",
      "모델이 더 친절해진다."
    ],
    "answer": "파이썬 등 프로그래밍 코드를 통해 답변을 자동으로 파싱(분석)하기 쉽다.",
    "why": "데이터 정형화는 AI 결과를 소프트웨어 시스템에 통합할 때 필수적입니다.",
    "hint": "JSON 출력"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4030",
    "question": "시스템 프롬프트(System Prompt)를 설정하는 가장 효과적인 위치는?",
    "options": [
      "질문의 맨 마지막 문장",
      "가장 상단의 독립된 설정 영역",
      "중간에 괄호를 쓰고 적기",
      "텍스트 파일로 따로 저장해두기",
      "사용자 메시지 사이에 섞기"
    ],
    "answer": "가장 상단의 독립된 설정 영역",
    "why": "상단에 배치된 지침이 모델의 전반적인 행동 양식을 결정하는 데 가장 강력한 영향력을 미칩니다.",
    "hint": "시스템 프롬프트 위치"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4031",
    "question": "프롬프트에 '너는 초등학생에게 설명하는 선생님이야'라고 역할을 주는 것이 효과적인 이유는?",
    "options": [
      "초등학생이 AI를 많이 쓰기 때문",
      "모델이 사용할 어휘 수준과 설명 방식을 그에 맞춰 조정하기 때문",
      "선생님 페르소나가 가장 저렴하기 때문",
      "초등학교 데이터를 가장 많이 학습했기 때문",
      "글자 수를 줄여주기 때문"
    ],
    "answer": "모델이 사용할 어휘 수준과 설명 방식을 그에 맞춰 조정하기 때문",
    "why": "역할에 따른 적절한 톤앤매너와 지식 수준을 이끌어낼 수 있습니다.",
    "hint": "어휘 수준 조정"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4032",
    "question": "복잡한 데이터에서 특정 정보를 추출할 때, 예시를 'A: [값]' 형태로 주는 이유는?",
    "options": [
      "모델에게 답변의 구조(Template)를 명시하여 형식 오류를 막기 위해",
      "화면을 예쁘게 꾸미기 위해",
      "대괄호가 멋있어 보여서",
      "영어를 섞어야 잘 이해해서",
      "데이터를 숨기기 위해"
    ],
    "answer": "모델에게 답변의 구조(Template)를 명시하여 형식 오류를 막기 위해",
    "why": "구조화된 예시는 모델이 패턴을 그대로 모방하게 만드는 가장 쉬운 방법입니다.",
    "hint": "템플릿 가이드"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4033",
    "question": "프롬프트 실험 단계에서 결과가 만족스럽지 않을 때 가장 먼저 시도해야 할 조치는?",
    "options": [
      "모델을 즉시 삭제한다.",
      "지시문을 더 구체적으로 다듬거나 Few-shot 예시를 추가한다.",
      "인터넷 속도를 체크한다.",
      "키보드를 다른 것으로 바꾼다.",
      "잠시 쉬었다가 다시 한다."
    ],
    "answer": "지시문을 더 구체적으로 다듬거나 Few-shot 예시를 추가한다.",
    "why": "작은 지시 사항의 개선(Refine)이 드라마틱한 성능 향상을 가져오기도 합니다.",
    "hint": "반복적 개선"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4034",
    "question": "프롬프트 엔지니어링 도중 '토큰 사용량'을 모니터링해야 하는 이유는?",
    "options": [
      "컴퓨터 바이러스를 잡기 위해",
      "비용 관리와 모델의 입력 한도(Context Window)를 체크하기 위해",
      "문법 오타를 찾기 위해",
      "로그인 기록을 남기기 위해",
      "인공지능의 지능을 측정하기 위해"
    ],
    "answer": "비용 관리와 모델의 입력 한도(Context Window)를 체크하기 위해",
    "why": "입력량이 너무 많으면 비용이 오르고, 한도를 넘으면 앞부분을 잊게 됩니다.",
    "hint": "토큰 관리"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4035",
    "question": "프롬프트 작성 시 '모르는 내용은 모른다고 답해줘'라고 적는 주된 의도는?",
    "options": [
      "AI에게 수치심을 주기 위해",
      "환각(Hallucination) 현상을 억제하고 정직한 답변을 유도하기 위해",
      "질문을 그만하게 하려고",
      "메모리를 아끼기 위해",
      "사용자를 귀찮게 하려고"
    ],
    "answer": "환각(Hallucination) 현상을 억제하고 정직한 답변을 유도하기 위해",
    "why": "억지로 지어내는 대신 모름을 인지하게 함으로써 데이터 신뢰도를 높입니다.",
    "hint": "모름 시인"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4036",
    "question": "영어로 프롬프트를 작성하는 것이 한국어보다 유리할 때가 있는 이유는?",
    "options": [
      "영어가 더 예쁜 언어라서",
      "대부분의 거대 모델이 영어 데이터를 압도적으로 많이 학습했기 때문",
      "영어 토큰이 더 비싸기 때문",
      "미국 회사에서 만들었기 때문",
      "영어는 오타가 안 나기 때문"
    ],
    "answer": "대부분의 거대 모델이 영어 데이터를 압도적으로 많이 학습했기 때문",
    "why": "모델의 추론 로직이 영어 문맥에서 더 정교하게 작동하는 경우가 많습니다.",
    "hint": "언어적 유리함"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4037",
    "question": "프롬프트에 '검토(Review) 단계'를 넣는 실무적 효과는?",
    "options": [
      "답변 시간을 보장받기 위해",
      "논리적 오류나 표현상의 미숙함을 모델이 자가 수정하도록 돕기 위해",
      "비용을 강제 지출하기 위해",
      "글자 수를 늘리기 위해",
      "칭찬을 듣기 위해"
    ],
    "answer": "논리적 오류나 표현상의 미숙함을 모델이 자가 수정하도록 돕기 위해",
    "why": "생성과 검토를 분리하면 최종 결과물의 품질이 눈에 띄게 좋아집니다.",
    "hint": "검토 단계"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4038",
    "question": "다양한 아이디어를 얻고 싶을 때, 'Top-P'나 'Top-K' 값을 어떻게 조절해야 하나?",
    "options": [
      "0으로 만든다.",
      "샘플링 범위를 넓히기 위해 값을 적절히 높여 다양성을 확보한다.",
      "값을 무조건 낮춘다.",
      "아예 설정하지 않는다.",
      "최댓값으로 고정한다."
    ],
    "answer": "샘플링 범위를 넓히기 위해 값을 적절히 높여 다양성을 확보한다.",
    "why": "샘플링 범위가 넓을수록 더 창의적이고 예상치 못한 단어가 선택될 수 있습니다.",
    "hint": "다양성 조절"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4039",
    "question": "프롬프트 엔지니어링이 'Fine-tuning'보다 경제적인 상황은?",
    "options": [
      "방대한 신규 지식을 100만 개 학습시켜야 할 때",
      "모델의 가중치를 영구적으로 바꿔야 할 때",
      "학습 데이터 확보가 어렵고 빠른 프로토타입 검증이 필요할 때",
      "서로 다른 모델 10개를 동시에 쓸 때",
      "비용이 무제한일 때"
    ],
    "answer": "학습 데이터 확보가 어렵고 빠른 프로토타입 검증이 필요할 때",
    "why": "프롬프트 변경은 비용이 거의 들지 않고 즉시 적용이 가능합니다.",
    "hint": "프롬프트 vs 튜닝"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4040",
    "question": "프롬프트 끝에 '이 답변이 좋으면 팁을 줄게'라고 적으면 성능이 올라간다는 속설은 어떤 기법과 연동되나?",
    "options": [
      "금전적 보상",
      "긍정 강화(Positive Reinforcement) 및 정렬(Alignment) 영향",
      "협박",
      "허풍",
      "가스라이팅"
    ],
    "answer": "긍정 강화(Positive Reinforcement) 및 정렬(Alignment) 영향",
    "why": "모델의 특정 보상 구조나 강화 학습 맥락에서 더 열심히 추론하게 유도하는 심리적 기법입니다.",
    "hint": "긍정 강화"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4041",
    "question": "텍스트를 요약할 때 '한 문장'으로 제한하고 싶은 경우 프롬프트에 적절한 문구는?",
    "options": [
      "길게 써줘",
      "불라불라 써줘",
      "다른 말 다 빼고 핵심만 한 문장으로 요약해!",
      "최대한 많은 정보를 담아줘",
      "아무렇게나 요약해"
    ],
    "answer": "다른 말 다 빼고 핵심만 한 문장으로 요약해!",
    "why": "명확한 길이 제한 지시는 모델이 정보를 압축하게 만듭니다.",
    "hint": "요약 시나리오"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4042",
    "question": "비정형 텍스트에서 '날짜' 정보만 뽑아 리스트로 만들고 싶을 때 가장 좋은 방식은?",
    "options": [
      "'날짜 찾아줘'라고만 말함",
      "Few-shot으로 본문과 날짜 결과 리스트 예시를 3개 정도 보여줌",
      "모델을 새로 만듦",
      "날짜만 따로 타이핑함",
      "숫자를 다 지움"
    ],
    "answer": "Few-shot으로 본문과 날짜 결과 리스트 예시를 3개 정도 보여줌",
    "why": "예시를 통해 어떤 포맷으로 추출해야 하는지 패턴을 인지시킵니다.",
    "hint": "정보 추출"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4043",
    "question": "코드의 버그를 찾고 싶을 때 효과적인 프롬프트는?",
    "options": [
      "'이게 왜 안 돼?'",
      "'이 코드의 에러 원인을 분석하고, 단계별 수정 방안을 제시해줘.'",
      "'코드를 다시 짜'",
      "'그냥 돌아가게 해줘'",
      "'파이썬 싫어'"
    ],
    "answer": "'이 코드의 에러 원인을 분석하고, 단계별 수정 방안을 제시해줘.'",
    "why": "원인 분석과 해결 방안을 분리하여 지시하면 정교한 디버깅이 가능합니다.",
    "hint": "디버깅"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4044",
    "question": "외국어 번역 시 '자연스러운 한국어'를 원한다면 덧붙일 지침은?",
    "options": [
      "'직역하지 말고 한국인이 평소 쓰는 문체로 의역해줘.'",
      "'영어 단어 순서대로 써줘'",
      "'구글 번역기처럼 해줘'",
      "'한 단어씩 끊어서 해줘'",
      "'단어 뜻을 다 알려줘'"
    ],
    "answer": "'직역하지 말고 한국인이 평소 쓰는 문체로 의역해줘.'",
    "why": "번역의 목적과 톤앤매너를 지정하면 훨씬 읽기 좋은 결과가 나옵니다.",
    "hint": "번역"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4045",
    "question": "데이터 분석 보고서를 작성할 때 프롬프트에 '표(Table)' 형식을 요구하는 이유는?",
    "options": [
      "모델이 표를 그리는 것을 좋아해서",
      "가독성이 높고 항목 간 비교가 쉽기 때문",
      "글자 수가 더 늘어나기 때문",
      "표는 토큰이 안 들기 때문",
      "더 똑똑해 보여서"
    ],
    "answer": "가독성이 높고 항목 간 비교가 쉽기 때문",
    "why": "구조화된 정보 전달은 데이터의 특징을 명확히 전달하는 데 효과적입니다.",
    "hint": "차트 요구"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4046",
    "question": "창의적인 시를 쓰고 싶을 때 프롬프트에 덧붙이면 좋은 것?",
    "options": [
      "'정답만 말해'",
      "'다양한 비유와 은유를 사용해서 감성적으로 작성해줘.'",
      "'오타 내지 마'",
      "'세 글자씩만 써'",
      "'아무거나 써'"
    ],
    "answer": "'다양한 비유와 은유를 사용해서 감성적으로 작성해줘.'",
    "why": "표현의 풍부함을 유도하는 스타일 지시는 창의적 글쓰기에 도움을 줍니다.",
    "hint": "글쓰기"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4047",
    "question": "사용자 매뉴얼을 작성해달라고 할 때 'Context'로 줄 수 있는 가장 좋은 정보는?",
    "options": [
      "현재 날씨",
      "제품의 상세 사양과 기능 리스트",
      "좋아하는 연예인 이름",
      "어제 먹은 점심",
      "사용자의 통장 잔고"
    ],
    "answer": "제품의 상세 사양과 기능 리스트",
    "why": "설명할 제품에 대한 구체적인 '사실' 정보가 있어야 환각 없는 매뉴얼이 나옵니다.",
    "hint": "매뉴얼 작성"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4048",
    "question": "이메일 답장을 대신 써달라고 할 때 넣어야 할 핵심 정보는?",
    "options": [
      "상대방의 이메일 원문과 나의 답변 핵심 의도",
      "내 이메일 주소",
      "내 컴퓨터의 사양",
      "상대방의 직업",
      "메일함의 전체 용량"
    ],
    "answer": "상대방의 이메일 원문과 나의 답변 핵심 의도",
    "why": "무엇에 대해 어떤 태도로 답할지(의도)가 프롬프트의 핵심입니다.",
    "hint": "이메일 자동화"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4049",
    "question": "모델이 편향된 답변을 하는 것을 막기 위한 문구는?",
    "options": [
      "'중립적인 입장에서 양쪽의 의견을 모두 균형 있게 설명해줘.'",
      "'내 말이 무조건 맞아'",
      "'한쪽 편만 들어줘'",
      "'사실은 중요하지 않아'",
      "'아무도 모르게 답해'"
    ],
    "answer": "'중립적인 입장에서 양쪽의 의견을 모두 균형 있게 설명해줘.'",
    "why": "중립성 유도는 모델이 다각도의 정보를 탐색하게 만듭니다.",
    "hint": "중립성 유지"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4050",
    "question": "데이터 분석 시 '인사이트'를 뽑아달라고 할 때 권장되는 방식은?",
    "options": [
      "'데이터 분석해줘'",
      "'이 데이터에서 발견되는 3가지 주요 추세와 비즈니스 시사점을 정리해줘.'",
      "'숫자가 왜 이래?'",
      "'표가 너무 길어'",
      "'내일 매출 알려줘'"
    ],
    "answer": "'이 데이터에서 발견되는 3가지 주요 추세와 비즈니스 시사점을 정리해줘.'",
    "why": "인사이트의 개수와 구체적인 분석 관점을 명시하면 답변 퀄리티가 상승합니다.",
    "hint": "인사이트 도출"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4051",
    "question": "프롬프트에 '단계별로(step-by-step)'를 넣는 것과 안 넣는 것의 결과 차이는?",
    "options": [
      "차이가 전혀 없다.",
      "넣으면 논리적 비약이 줄고 정확도가 현격히 높아진다.",
      "안 넣어야 속도가 더 빨라서 좋다.",
      "넣으면 틀린 답이 더 많이 나온다.",
      "비용만 많이 든다."
    ],
    "answer": "넣으면 논리적 비약이 줄고 정확도가 현격히 높아진다.",
    "why": "중간 논리 과정을 생략하지 않으므로 복잡한 추론 실패 확률이 줄어듭니다.",
    "hint": "단계별 효과"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4052",
    "question": "뉴스 기사를 기반으로 '헤드라인'을 뽑을 때 가이드라인은?",
    "options": [
      "'가장 긴 제목으로 뽑아줘'",
      "'클릭을 유도하면서도 본문 내용을 왜곡하지 않는 간결한 제목 5개를 제안해줘.'",
      "'제목은 필요 없어'",
      "'아무 글자나 써줘'",
      "'영어 제목만 써'"
    ],
    "answer": "'클릭을 유도하면서도 본문 내용을 왜곡하지 않는 간결한 제목 5개를 제안해줘.'",
    "why": "목표 출력물의 개수를 지정하면 선택의 폭이 넓어지는 이점이 있습니다.",
    "hint": "헤드라인 추출"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4053",
    "question": "프롬프트 속에 '변수(Variable)'를 활용하는 가장 큰 이유는?",
    "options": [
      "프롬프트 내용을 프로젝트 상황에 따라 동적으로 바꾸기 위해",
      "수학 계산을 하기 위해",
      "모델의 이름을 바꾸기 위해",
      "사용자를 놀래주기 위해",
      "서버를 끄기 위해"
    ],
    "answer": "프롬프트 내용을 프로젝트 상황에 따라 동적으로 바꾸기 위해",
    "why": "변수 자리를 비워두면 자동화 스크립트에서 효율적으로 입력을 갈아끼울 수 있습니다.",
    "hint": "변수 활용"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4054",
    "question": "고객 센터 챗봇의 시스템 프롬프트에 포함되어야 할 필수 내용은?",
    "options": [
      "상담원의 신분증 정보",
      "고객의 개인정보",
      "답변 가능한 범위와 금기 사항, 브랜드 말투 가이드",
      "실제 상담원의 집 주소",
      "모델의 가격표"
    ],
    "answer": "답변 가능한 범위와 금기 사항, 브랜드 말투 가이드",
    "why": "기업의 신뢰도를 위해 답변의 가드레일을 설정하는 것입니다.",
    "hint": "챗봇 지침"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4055",
    "question": "수학 문제 풀이 시 '오답'이 계속 나온다면?",
    "options": [
      "문제를 풀지 않는다.",
      "풀이 과정 예시(CoT)가 포함된 Few-shot을 제공한다.",
      "질문을 더 크게 소리 내어 읽는다.",
      "계산기를 AI에게 보낸다.",
      "컴퓨터를 끈다."
    ],
    "answer": "풀이 과정 예시(CoT)가 포함된 Few-shot을 제공한다.",
    "why": "어떻게 풀어야 하는지 '사고의 길'을 예시로 보여주면 모델은 곧잘 따라옵니다.",
    "hint": "수학 오답 대처"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4056",
    "question": "긴 보고서를 요약할 때 '섹션별'로 나누어 요약해달라고 하는 편이 좋은 이유는?",
    "options": [
      "글자 수가 많아 보여서",
      "중요한 세부 정보를 놓치지 않고 구조적으로 파악할 수 있어서",
      "모델을 더 힘들게 하려고",
      "종이를 아끼려고",
      "인터넷이 끊길까 봐"
    ],
    "answer": "중요한 세부 정보를 놓치지 않고 구조적으로 파악할 수 있어서",
    "why": "전체 뭉텅이 요약보다 영역별 요약이 정보 누락을 훨씬 잘 막아줍니다.",
    "hint": "섹션 요약"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4057",
    "question": "프롬프트 엔지니어가 되기 위해 가장 필요한 역량은?",
    "options": [
      "수려한 글솜씨",
      "모델의 작동 원리 이해와 논리적인 사고력",
      "엄청난 암기력",
      "예쁜 디자인 실력",
      "하루 종일 게임하기"
    ],
    "answer": "모델의 작동 원리 이해와 논리적인 사고력",
    "why": "기술의 기반 원리를 알아야 어떤 프롬프트가 효과적인지 논리적으로 설계할 수 있습니다.",
    "hint": "엔지니어 역량"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4058",
    "question": "프롬프트에서 '최종 답변 전 한 번 검토해'라고 할 때 모델의 행동 변화는?",
    "options": [
      "그냥 무시한다.",
      "생성한 답변을 다시 훑으며 모순점을 찾아내거나 말투를 정돈한다.",
      "답변을 거부한다.",
      "질문을 다시 한다.",
      "속도가 100배 빨라진다."
    ],
    "answer": "생성한 답변을 다시 훑으며 모순점을 찾아내거나 말투를 정돈한다.",
    "why": "자기 반성(Self-Refine) 과정이 추가되어 품질이 견고해집니다.",
    "hint": "검토 유도"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4059",
    "question": "실무에서 프롬프트가 '너무 완벽'할 필요가 없는 경우는?",
    "options": [
      "결과를 다시 사람이 직접 검수하고 수정할 때",
      "중요한 금융 계약을 맺을 때",
      "의학 수술을 할 때",
      "법률 판례를 뽑을 때",
      "자율주행 코드를 짤 때"
    ],
    "answer": "결과를 다시 사람이 직접 검수하고 수정할 때",
    "why": "사람이 마지막에 확인한다면 적절한 수준에서 타협하여 생산성을 높일 수 있습니다.",
    "hint": "인간의 검수"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4060",
    "question": "교재 4장 '프롬프트 엔지니어링' 학습 후의 가장 큰 장점은?",
    "options": [
      "인공지능을 더 무서워하게 된다.",
      "적은 비용과 노력으로 고품질의 AI 결과물을 얻고 업무 효율을 높일 수 있다.",
      "컴퓨터를 더 비싼 것으로 사게 된다.",
      "글씨를 더 잘 쓰게 된다.",
      "인터넷 쇼핑을 더 잘하게 된다."
    ],
    "answer": "적은 비용과 노력으로 고품질의 AI 결과물을 얻고 업무 효율을 높일 수 있다.",
    "why": "생성 AI 시대에 모델을 가장 잘 다루는 핵심 무기를 갖게 된 것입니다.",
    "hint": "학습의 가치"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4061",
    "question": "프롬프트에서 '전문 용어 사용을 지양해줘'라고 하면 어떤 효과가 있나?",
    "options": [
      "비용이 절감된다.",
      "일반인도 이해하기 쉬운 쉬운 표현으로 설명해준다.",
      "모델이 화를 낸다.",
      "답변이 더 전문적으로 변한다.",
      "영어가 섞여 나온다."
    ],
    "answer": "일반인도 이해하기 쉬운 쉬운 표현으로 설명해준다.",
    "why": "대상 독자에 맞춘 가독성 있는 답변을 유도합니다.",
    "hint": "용어 조절"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4062",
    "question": "모델 아키텍처 중 gpt-3.5-turbo와 gpt-4의 프롬프트 반응 차이는?",
    "options": [
      "거의 똑같다.",
      "gpt-4가 복잡한 지시문이나 긴 Context를 훨씬 정교하게 처리한다.",
      "gpt-3.5가 항상 더 똑똑하다.",
      "둘은 색깔만 다르다.",
      "아무도 모른다."
    ],
    "answer": "gpt-4가 복잡한 지시문이나 긴 Context를 훨씬 정교하게 처리한다.",
    "why": "상위 모델일수록 더 고차원적인 프롬프트 엔지니어링 기술이 잘 먹힙니다.",
    "hint": "모델 간 차이"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4063",
    "question": "프롬프트에 '출력물은 [제목], [본문], [결론] 구조를 지켜줘'라고 할 때를 부르는 용어는?",
    "options": [
      "Format Constraint (형식 제약)",
      "Secret Order",
      "Template Hiding",
      "Style Copy",
      "Structure Break"
    ],
    "answer": "Format Constraint (형식 제약)",
    "why": "글의 구조를 강제하여 후속 처리나 가독성을 확보합니다.",
    "hint": "형식 제약 용어"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4064",
    "question": "프롬프트 리킹을 방지하기 위해 서버 측에서 수행하는 일반적인 조치는?",
    "options": [
      "사용자의 질문을 훔쳐본다.",
      "시스템 지시문을 별도의 안전한 레이어로 관리하고 사용자에게 노출하지 않는다.",
      "컴퓨터 전원을 끈다.",
      "내 답변을 암호화한다.",
      "마우스를 클릭한다."
    ],
    "answer": "시스템 지시문을 별도의 안전한 레이어로 관리하고 사용자에게 노출하지 않는다.",
    "why": "시스템 프롬프트를 보호하기 위한 가드레일을 설치합니다.",
    "hint": "리킹 방지"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4065",
    "question": "프롬프트에서 '확실하지 않으면 추측하지 말고 솔직하게 말해'라고 강조하는 이유는?",
    "options": [
      "모델의 자신감을 꺾기 위해",
      "환각으로 인한 오염된 정보를 필터링하기 위해",
      "답변을 짧게 하려고",
      "모델을 무시하려고",
      "인터넷이 끊길까 봐"
    ],
    "answer": "환각으로 인한 오염된 정보를 필터링하기 위해",
    "why": "사실 관계가 중요한 작업에서 잘못된 지식이 섞이는 것을 원칙적으로 차단합니다.",
    "hint": "솔직함 강조"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4066",
    "question": "다음 중 '지시문(Instruction)'이 가장 명확한 예는?",
    "options": [
      "분석 좀 부탁해",
      "이 문장에서 명사만 추출해서 쉼표로 구분해 리스트형태로 출력해줘",
      "대충 읽어봐",
      "이게 뭐야?",
      "아무것도 하지 마"
    ],
    "answer": "이 문장에서 명사만 추출해서 쉼표로 구분해 리스트형태로 출력해줘",
    "why": "구체적인 작업 내용과 출력 형식이 모두 포함된 질 좋은 지시문입니다.",
    "hint": "지시문 예시"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4067",
    "question": "프롬프트 체이닝(Chaining) 과정에서 이전 단계의 결과물을 다음 단계로 넘기는 이유는?",
    "options": [
      "데이터를 버리기 위해",
      "연결된 맥락을 유지하여 최종 목표를 달성하기 위해",
      "모델을 힘들게 하려고",
      "비용을 아끼기 위해",
      "재미있어서"
    ],
    "answer": "연결된 맥락을 유지하여 최종 목표를 달성하기 위해",
    "why": "복잡한 공정을 한 번에 하기보다 릴레이 방식으로 하여 정확도를 높입니다.",
    "hint": "체이닝 이유"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4068",
    "question": "프롬프트 개선 시 'A/B 테스트'를 수행한다는 것의 의미는?",
    "options": [
      "영문법을 체크한다.",
      "두 가지 버전의 프롬프트를 돌려보고 더 좋은 결과를 내는 쪽을 선택한다.",
      "컴퓨터를 A에서 B로 바꾼다.",
      "키보드 자음과 모음을 테스트한다.",
      "문장을 A부터 B까지 길게 쓴다."
    ],
    "answer": "두 가지 버전의 프롬프트를 돌려보고 더 좋은 결과를 내는 쪽을 선택한다.",
    "why": "어떤 표현이 모델에게 더 잘 먹히는지 정량적으로 파악하는 과정입니다.",
    "hint": "A/B 테스트"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4069",
    "question": "학습 세트와 비슷한 예시를 주어 추론 능력을 극대화하는 샷 기법은?",
    "options": [
      "Zero-shot",
      "In-domain Few-shot",
      "Cross-lingual shot",
      "Hard-shot",
      "Fast-shot"
    ],
    "answer": "In-domain Few-shot",
    "why": "관련된 분야의 예시를 줄수록 모델의 전문성은 더 깊어집니다.",
    "hint": "도메인 예시"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4070",
    "question": "프롬프트 엔지니어링 용어 중 'Token Limit'은 무엇과 관련 있나?",
    "options": [
      "모델의 지능 지수",
      "한 번에 입력하거나 출력할 수 있는 텍스트의 총량",
      "회사 출입증",
      "인터넷 요금제",
      "키보드 품질"
    ],
    "answer": "한 번에 입력하거나 출력할 수 있는 텍스트의 총량",
    "why": "문맥 창 크기에 따른 물리적인 데이터 한계를 의미합니다.",
    "hint": "토큰 리미트"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4071",
    "question": "프롬프트의 길이를 줄이기 위해 의미 없는 접속사나 수식어를 빼는 작업을 무엇이라 하나?",
    "options": [
      "Prompt Compression (프롬프트 압축)",
      "Text Deleting",
      "Word Cutting",
      "Grammar Fixing",
      "Short Editing"
    ],
    "answer": "Prompt Compression (프롬프트 압축)",
    "why": "토큰 비용을 아끼면서 지시의 명확성을 유지하는 고도의 기술입니다.",
    "hint": "프롬프트 압축"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4072",
    "question": "모델에게 '최대한 창의적으로 답변해'라고 지시했을 때 내부적으로 바뀌는 것과 유사한 설정은?",
    "options": [
      "온도를 낮추기",
      "온도를 높이기",
      "글자 수를 줄이기",
      "답변을 멈추기",
      "영어로만 답하기"
    ],
    "answer": "온도를 높이기",
    "why": "높은 온도는 확률적으로 덜 뻔한 단어를 선택하게 하여 창의성을 높입니다.",
    "hint": "창의성 연동"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4073",
    "question": "시스템 프롬프트에 금기어(예: 경쟁사 이름)를 넣었을 때의 효과는?",
    "options": [
      "경쟁사가 고발한다.",
      "모델이 해당 단어를 언급하지 않으려고 노력한다.",
      "경쟁사 광고가 뜬다.",
      "모델이 더 빨리 답한다.",
      "글자가 깨진다."
    ],
    "answer": "모델이 해당 단어를 언급하지 않으려고 노력한다.",
    "why": "부정적인 언급을 차단하여 기업의 브랜드 가치를 보호합니다.",
    "hint": "금기어 설정"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4074",
    "question": "프롬프트 설계 시 '사용자 경험(UX)'을 고려한다는 말은?",
    "options": [
      "AI의 기분을 좋게 해주는 것",
      "사용자가 이해하기 쉬운 형태와 친근한 말투로 답변이 나오게 설계하는 것",
      "내 모니터를 닦는 것",
      "마우스를 좋은 것으로 사는 것",
      "로그인을 빨리 하는 것"
    ],
    "answer": "사용자가 이해하기 쉬운 형태와 친근한 말투로 답변이 나오게 설계하는 것",
    "why": "최종 사용자가 서비스를 얼마나 편하게 느낄지까지 고려하는 엔지니어링입니다.",
    "hint": "UX 고려"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4075",
    "question": "프롬프트 속에 '가정(Assume)'을 넣는 기법은 언제 쓰나?",
    "options": [
      "현실 정보를 부정하고 싶을 때",
      "가상의 시나리오로 상황을 설정하여 창의적인 시뮬레이션 답변을 듣고 싶을 때",
      "거짓말을 시키려고",
      "비용을 안 내려구",
      "모델과 싸울 때"
    ],
    "answer": "가상의 시나리오로 상황을 설정하여 창의적인 시뮬레이션 답변을 듣고 싶을 때",
    "why": "특정 조건 하에서의 결과를 예측해볼 때 매우 강력한 도구가 됩니다.",
    "hint": "가정 기법"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4076",
    "question": "프롬프트 엔지니어링이 '대화형'뿐만 아니라 'API 연동형'에서도 중요한 이유는?",
    "options": [
      "API 키가 비싸서",
      "시스템이 정확하고 예측 가능한 정형 데이터(JSON 등)를 안정적으로 받아야 하기 때문",
      "프로그램 코드가 안 짜져서",
      "인터넷이 느려서",
      "사용자가 없어서"
    ],
    "answer": "시스템이 정확하고 예측 가능한 정형 데이터(JSON 등)를 안정적으로 받아야 하기 때문",
    "why": "프로그램 간의 데이터 교환은 형식이 조금만 틀려도 에러가 나기 때문입니다.",
    "hint": "API 연동 중요성"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4077",
    "question": "프롬프트 지침에 '친절한 말투'를 넣었을 때 모델의 답변이 부드러워지는 원리는?",
    "options": [
      "모델이 감정을 느껴서",
      "학습 데이터 중 '친절한 문맥'에 해당하는 토큰들의 확률이 높아지기 때문",
      "보너스를 줘서",
      "전기 신호가 예쁘게 흘러서",
      "한글이 예뻐서"
    ],
    "answer": "학습 데이터 중 '친절한 문맥'에 해당하는 토큰들의 확률이 높아지기 때문",
    "why": "언어 모델은 확률적인 매커니즘에 따라 요청된 스타일의 단어 뭉치를 선택합니다.",
    "hint": "말투 변화 원리"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4078",
    "question": "다음 중 좋은 프롬프트를 만드는 반복적 과정은?",
    "options": [
      "작성 -> 결과 확인 -> 문제 분석 -> 수정 보완 (Refine)",
      "작성 -> 포기",
      "작성 -> 즉시 배포",
      "남의 것 복사",
      "글자 수 늘리기"
    ],
    "answer": "작성 -> 결과 확인 -> 문제 분석 -> 수정 보완 (Refine)",
    "why": "한 번에 완벽한 프롬프트는 없으며 끊임없는 튜닝 과정이 필요합니다.",
    "hint": "반복 과정"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4079",
    "question": "프롬프트 작성자가 '도메인 지식'이 많을수록 유리한 이유는?",
    "options": [
      "질문을 길게 쓸 수 있어서",
      "무엇이 핵심 정보인지 알고 정교한 Context와 Shot을 제공할 수 있어서",
      "영어를 잘해서",
      "돈이 많아서",
      "똑똑해 보여서"
    ],
    "answer": "무엇이 핵심 정보인지 알고 정교한 Context와 Shot을 제공할 수 있어서",
    "why": "분야의 맥락을 알아야 모델에게 더 날카롭고 유용한 질문을 던질 수 있습니다.",
    "hint": "도메인 지식 유리함"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4080",
    "question": "교재 4장을 마무리하며, 프롬프트 엔지니어링의 정수는?",
    "options": [
      "질문을 많이 하는 것",
      "AI의 한계를 이해하고 인간의 의도를 논리적으로 번역하여 전달하는 것",
      "파일을 많이 저장하는 것",
      "최신형 컴퓨터를 사는 것",
      "인터넷 유료 기사를 읽는 것"
    ],
    "answer": "AI의 한계를 이해하고 인간의 의도를 논리적으로 번역하여 전달하는 것",
    "why": "인간과 AI 사이의 가교 역할을 효율적으로 수행하는 것이 핵심입니다.",
    "hint": "정수(Essence)"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4081",
    "question": "프롬프트에서 '복잡한 문제는 마지막에 적어줘'라고 위치를 잡는 이유는?",
    "options": [
      "앞부분은 모델이 잘 잊어서",
      "최신 모델이 프롬프트 끝부분의 지시를 더 강하게 반영하는 경향이 있기 때문",
      "공간을 채우려고",
      "글자 수를 맞추려고",
      "아무 이유 없음"
    ],
    "answer": "최신 모델이 프롬프트 끝부분의 지시를 더 강하게 반영하는 경향이 있기 때문",
    "why": "지시의 우선순위를 배치 위치로 조절하는 영리한 전략입니다.",
    "hint": "지시 위치"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4082",
    "question": "프롬프트 속에 '사용자의 이전 취향'을 넣는 것은 어떤 기법인가?",
    "options": [
      "Context Injection (문맥 주입)",
      "Personalization",
      "History Tracking",
      "Preference Setting",
      "Context Injection 및 Personalization"
    ],
    "answer": "Context Injection 및 Personalization",
    "why": "사용자 맞춤형 정교한 추천과 상담을 가능하게 합니다.",
    "hint": "개인화"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4083",
    "question": "모델의 답변이 '자꾸 끊긴다면' 프롬프트나 설정에서 체크할 것은?",
    "options": [
      "내 모니터 전원",
      "Max Tokens 설정값과 문장 생성 한도",
      "현재 날씨",
      "키보드 한글 키",
      "마우스 감도"
    ],
    "answer": "Max Tokens 설정값과 문장 생성 한도",
    "why": "생성 가능한 한계를 넘으면 답변이 잘린 채로 나옵니다.",
    "hint": "답변 끊김"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4084",
    "question": "프롬프트 작성 시 '모호한 표현'(예: 잘 해봐)을 피해야 하는 가장 큰 이유는?",
    "options": [
      "모델이 긴장해서",
      "모델마다 '잘'의 기준이 달라 일관성 없는 답변이 나오기 때문",
      "비용이 비싸져서",
      "글자 수가 적어서",
      "모델이 화를 내서"
    ],
    "answer": "모델마다 '잘'의 기준이 달라 일관성 없는 답변이 나오기 때문",
    "why": "모호함은 AI의 예측 불가능성을 높여 시스템 운영을 어렵게 합니다.",
    "hint": "모호함 회피"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4085",
    "question": "프롬프트에 '역사적 사실 팩트체크'를 시킬 때 주의점은?",
    "options": [
      "모델은 2024년 이후 정보를 모를 수 있으므로 최신 Context를 직접 넣어줘야 한다.",
      "모델은 절대 틀리지 않는다.",
      "모델에게 물어보기만 하면 백과사전보다 정확하다.",
      "사실 확인은 필요 없다.",
      "영어로 물어보면 며칠 뒤 사실도 안다."
    ],
    "answer": "모델은 2024년 이후 정보를 모를 수 있으므로 최신 Context를 직접 넣어줘야 한다.",
    "why": "학습 데이터의 컷오프 시점에 따른 정보 공백을 인지해야 합니다.",
    "hint": "팩트체크 주의점"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4086",
    "question": "프롬프트의 결과로 '정답'이 아닌 '아이디어 10개'를 뽑아달라고 할 때의 장점은?",
    "options": [
      "결과를 더 많이 보여줄 수 있어서",
      "다양한 가능성 중에서 인간이 최적의 안을 고를 수 있는 선택권을 얻기 때문",
      "글자 수가 늘어나서",
      "시간이 더 걸려서",
      "똑똑해 보여서"
    ],
    "answer": "다양한 가능성 중에서 인간이 최적의 안을 고를 수 있는 선택권을 얻기 때문",
    "why": "생성 AI를 '아이디어 증폭기'로 활용하는 좋은 전략입니다.",
    "hint": "아이디어 제안"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4087",
    "question": "프롬프트에 '코드 주석을 상세히 달아줘'라고 지시했을 때의 이점은?",
    "options": [
      "프로그램이 더 빨리 실행된다.",
      "나중에 사람이 코드를 이해하고 유지보수하기 훨씬 쉬워진다.",
      "코드가 짧아진다.",
      "보안이 강화된다.",
      "글자가 예뻐진다."
    ],
    "answer": "나중에 사람이 코드를 이해하고 유지보수하기 훨씬 쉬워진다.",
    "why": "협업과 사후 관리를 위한 고품질 결과물을 얻어내는 방법입니다.",
    "hint": "주석 지시"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4088",
    "question": "상담 챗봇이 '욕설'을 들었을 때 어떻게 대응할지 프롬프트에 적는 법은?",
    "options": [
      "'상대방에게 똑같이 욕해줘'",
      "'정중하게 부적절한 언어 사용을 지적하고 대화를 마무리해줘.'",
      "'아무 대답도 하지 마'",
      "'사용자를 고발해'",
      "'마우스를 던져'"
    ],
    "answer": "'정중하게 부적절한 언어 사용을 지적하고 대화를 마무리해줘.'",
    "why": "서비스의 품격을 유지하기 위한 예외 상황 처리 지침입니다.",
    "hint": "욕설 대응"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4089",
    "question": "프롬프트에 '반드시 숫자로만 출력해'라고 했을 때 텍스트가 섞여 나온다면?",
    "options": [
      "모델을 비난한다.",
      "Few-shot 예시로 숫자만 있는 사례를 보여주거나 형식을 재강조한다.",
      "인터넷을 바꾼다.",
      "키보드를 누른다.",
      "데이터를 지운다."
    ],
    "answer": "Few-shot 예시로 숫자만 있는 사례를 보여주거나 형식을 재강조한다.",
    "why": "지시대로 안 될 때는 예시만큼 효과적인 것이 없습니다.",
    "hint": "숫자 강제 지시"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4090",
    "question": "프롬프트 내부에 '마감 시한'의 압박을 주면(예: '지금 당장 급해') 성능이 변한다는 실험 결과의 근거는?",
    "options": [
      "모델이 시계를 볼 줄 알아서",
      "강화 학습 데이터 중 시급한 상황에서 더 정확한 정보가 오가는 경향이 반영됨",
      "전력 소모가 늘어서",
      "서버가 긴장해서",
      "사용자가 무서워서"
    ],
    "answer": "강화 학습 데이터 중 시급한 상황에서 더 정확한 정보가 오가는 경향이 반영됨",
    "why": "언어 맥락에 따른 지능의 미묘한 발휘 양상을 이용하는 심리적 엔지니어링입니다.",
    "hint": "시급성 주입"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4091",
    "question": "데이터 요약 시 '개조식(Bullet points)'을 권장하는 이유는?",
    "options": [
      "동그라미가 예뻐서",
      "핵심 내용을 한눈에 빠르게 파악하기 좋아서",
      "글자가 적게 들어서",
      "종이를 아끼려고",
      "인터넷 속도가 빨라져서"
    ],
    "answer": "핵심 내용을 한눈에 빠르게 파악하기 좋아서",
    "why": "가독성이 뛰어난 구조는 정보 전달의 핵심입니다.",
    "hint": "개조식 요약"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4092",
    "question": "프롬프트 내에서 '인용(Citation)'을 요구하는 이유는?",
    "options": [
      "남의 글을 훔치려고",
      "답변의 근거가 되는 원문의 위치를 명시하여 신뢰도를 높이기 위해",
      "글자 수를 늘리려고",
      "멋있어 보이려고",
      "정답을 숨기려고"
    ],
    "answer": "답변의 근거가 되는 원문의 위치를 명시하여 신뢰도를 높이기 위해",
    "why": "RAG 시스템 등에서 정보의 출처를 확인하는 데 필수적인 요소입니다.",
    "hint": "인용 요구"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4093",
    "question": "프롬프트 지침이 '상충'할 때(예: '길게 써줘'와 '요약해줘') 모델은?",
    "options": [
      "가장 긴 것을 선택한다.",
      "혼란에 빠져 일관성 없는 답변을 하거나 중간 정도의 애매한 답을 한다.",
      "둘 다 안 한다.",
      "에러가 난다.",
      "컴퓨터가 꺼진다."
    ],
    "answer": "혼란에 빠져 일관성 없는 답변을 하거나 중간 정도의 애매한 답을 한다.",
    "why": "상충하는 지시(Conflict)는 프롬프트 설계에서 반드시 피해야 할 요소입니다.",
    "hint": "지시 상충"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4094",
    "question": "프롬프트 엔지니어링을 '예술'과 '과학'의 결합이라고 부르는 이유는?",
    "options": [
      "그림을 그려야 해서",
      "창의적인 문구(예술)와 논리적인 구조(과학)가 모두 조화로워야 하기 때문",
      "실험실에서만 해서",
      "화가가 만들어서",
      "아무 이유 없음"
    ],
    "answer": "창의적인 문구(예술)와 논리적인 구조(과학)가 모두 조화로워야 하기 때문",
    "why": "직관과 논리가 모두 필요한 고도의 지적 작업임을 의미합니다.",
    "hint": "예술과 과학"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4095",
    "question": "프롬프트 속에 '한글로 대답해'라고 적는 것보다 '응답 언어는 한국어야'라고 명시하는 것의 차이는?",
    "options": [
      "차이가 전혀 없다.",
      "명시적이고 구조적인 선언이 모델의 지시 이행률을 높이는 경향이 있다.",
      "한글로 대답해라고 해야 모델이 친숙해한다.",
      "영어로 적어야 한다.",
      "말하지 않아도 안다."
    ],
    "answer": "명시적이고 구조적인 선언이 모델의 지시 이행률을 높이는 경향이 있다.",
    "why": "명확한 제약 조건 명시는 생성 오류를 줄이는 기본입니다.",
    "hint": "언어 지정"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4096",
    "question": "데이터 분석 챗봇이 '상관관계'와 '인과관계'를 혼동한다면?",
    "options": [
      "맞다고 우긴다.",
      "두 개념의 차이를 Context에 명확히 정의해주고 분석하게 시킨다.",
      "통계학 책을 AI 옆에 둔다.",
      "질문을 지운다.",
      "다른 AI를 쓴다."
    ],
    "answer": "두 개념의 차이를 Context에 명확히 정의해주고 분석하게 시킨다.",
    "why": "모호한 개념을 프롬프트에서 정의해주면 오독을 방지할 수 있습니다.",
    "hint": "개념 정의"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4097",
    "question": "프롬프트 엔지니어링의 미래 전망은?",
    "options": [
      "곧 사라질 기술이다.",
      "모델의 성능이 오를수록 사람이 더 고차원적인 지시를 내려야 하므로 계속 중요할 것이다.",
      "기계가 다 해줄 것이다.",
      "돈이 안 된다.",
      "아무도 모른다."
    ],
    "answer": "모델의 성능이 오를수록 사람이 더 고차원적인 지시를 내려야 하므로 계속 중요할 것이다.",
    "why": "AI와 협업하는 필수 역량이자 소통의 창구로 남을 것입니다.",
    "hint": "미래 전망"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4098",
    "question": "프롬프트 작성이 '코딩'과 유사하다고 느끼는 이유는?",
    "options": [
      "타이핑을 해서",
      "논리적인 지침을 순서대로 설계하고 결과를 검증하는 과정이 비슷해서",
      "파이썬으로만 짜서",
      "어려워서",
      "컴퓨터로 해서"
    ],
    "answer": "논리적인 지침을 순서대로 설계하고 결과를 검증하는 과정이 비슷해서",
    "why": "구조적 사고와 조건부 지시라는 면에서 소프트웨어 공학과 맞닿아 있습니다.",
    "hint": "코딩과의 유사성"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4099",
    "question": "프롬프트에 '이 내용을 외워'라고 하면 모델이 기억하나?",
    "options": [
      "네, 평생 기억합니다.",
      "아뇨, 현재 대화가 끝나면 완전히 잊어버립니다.",
      "내일 다시 물어봐도 압니다.",
      "로그인하면 압니다.",
      "모델 가중치에 저장됩니다."
    ],
    "answer": "아뇨, 현재 대화가 끝나면 완전히 잊어버립니다.",
    "why": "현재 세션의 휘발성 데이터일 뿐, 모델 자체의 지식으로 고정되지 않습니다.",
    "hint": "기억의 휘발성"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "객관식",
    "difficulty": "medium",
    "id": "4100",
    "question": "최종적으로 가장 좋은 프롬프트란?",
    "options": [
      "가장 긴 프롬프트",
      "가장 짧은 프롬프트",
      "내가 원하는 목적을 가장 빠르고 정확하고 저비용으로 달성하는 프롬프트",
      "영어로 된 프롬프트",
      "비싼 프롬프트"
    ],
    "answer": "내가 원하는 목적을 가장 빠르고 정확하고 저비용으로 달성하는 프롬프트",
    "why": "효율성과 정확성, 비용의 균형을 맞춘 결과물이 최고의 디자인입니다.",
    "hint": "최고의 프롬프트"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "4101",
    "question": "예시 없는 명령 개념을 완성하세요.\n```text\n____-shot Prompting: 예시 없이 바로 지시하는 법. (이 부분을 채우세요)\n```",
    "answer": "Zero",
    "why": "0개의 예시를 의미합니다.",
    "hint": "예시 없는 명령"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "4102",
    "question": "예시 하나 제공 개념을 완성하세요.\n```text\n____-shot Prompting: 하나의 예시를 제공하는 법. (이 부분을 채우세요)\n```",
    "answer": "One",
    "why": "1개의 예시를 의미합니다.",
    "hint": "예시 하나 제공"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "4103",
    "question": "여러 예시 제공 개념을 완성하세요.\n```text\n____-shot Prompting: 여러 개의 예시를 제공하는 법. (이 부분을 채우세요)\n```",
    "answer": "Few",
    "why": "수 개의 예시를 의미합니다.",
    "hint": "여러 예시 제공"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "4104",
    "question": "단계별 사고 개념을 완성하세요.\n```text\nChain-of-____ (CoT): 사고의 사슬 기법. (이 부분을 채우세요)\n```",
    "answer": "Thought",
    "why": "추론 과정을 노출하게 유도하는 기법입니다.",
    "hint": "단계별 사고"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "4105",
    "question": "역할 부여 개념을 완성하세요.\n```text\n____ Prompting: AI에게 전문가 가상 인물을 부여함. (이 부분을 채우세요)\n```",
    "answer": "Persona",
    "why": "모델의 정체성을 설정하는 단어입니다.",
    "hint": "역할 부여"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "4106",
    "question": "자기 개선 개념을 완성하세요.\n```text\nSelf-____: 생성된 답을 스스로 검토하고 고침. (이 부분을 채우세요)\n```",
    "answer": "Refine",
    "why": "출력 품질 자가 개선 기법입니다.",
    "hint": "자기 개선"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "4107",
    "question": "자기 일관성 개념을 완성하세요.\n```text\nSelf-____: 여러 경로로 추론해 가장 많은 답 선택. (이 부분을 채우세요)\n```",
    "answer": "Consistency",
    "why": "일관성 있는 결과를 뽑는 통계적 기법입니다.",
    "hint": "자기 일관성"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "4108",
    "question": "구분 기호 개념을 완성하세요.\n```text\n지시문과 본문을 나누는 ### 등을 ____라고 함. (이 부분을 채우세요)\n```",
    "answer": "구분자",
    "why": "영어로 Delimiter라고 합니다.",
    "hint": "구분 기호"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "4109",
    "question": "지시 영역 개념을 완성하세요.\n```text\n### ____: 모델에게 시키는 명령문 영역. (이 부분을 채우세요)\n```",
    "answer": "Instruction",
    "why": "프롬프트의 핵심 명령 부분입니다.",
    "hint": "지시 영역"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "4110",
    "question": "문맥 영역 개념을 완성하세요.\n```text\n### ____: 참고할 배경 정보 영역. (이 부분을 채우세요)\n```",
    "answer": "Context",
    "why": "사전 지식 제공 부분입니다.",
    "hint": "문맥 영역"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "4111",
    "question": "출력 제약 개념을 완성하세요.\n```text\n### ____: 길이 제한이나 금지 단어 설정. (이 부분을 채우세요)\n```",
    "answer": "Constraint",
    "why": "제약 사항을 의미하는 영어입니다.",
    "hint": "출력 제약"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "4112",
    "question": "보안 공격 개념을 완성하세요.\n```text\nPrompt ____: 악의적인 지침 우회 공격. (이 부분을 채우세요)\n```",
    "answer": "Injection",
    "why": "보안을 뚫기 위한 입력 공격의 명칭입니다.",
    "hint": "보안 공격"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "4113",
    "question": "지침 노출 개념을 완성하세요.\n```text\nPrompt ____: 내부 지시문이 밖으로 유출됨. (이 부분을 채우세요)\n```",
    "answer": "Leaking",
    "why": "기밀 프롬프트가 새어 나가는 현상입니다.",
    "hint": "지침 노출"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "4114",
    "question": "부정 금지 개념을 완성하세요.\n```text\n하지 마세요보다 '오직 ____ 해주세요' 를 권장함.\n```",
    "answer": "이렇게",
    "why": "긍정적인 작업 지정의 중요성입니다.",
    "hint": "부정 금지"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "4115",
    "question": "창의성 변수 개념을 완성하세요.\n```text\n창의적 답변을 원하면 ____를 0.7 이상으로 올림. (이 부분을 채우세요)\n```",
    "answer": "Temperature",
    "why": "생성 확률의 무작위성을 결정하는 수치입니다.",
    "hint": "창의성 변수"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "4116",
    "question": "추론 유도구 개념을 완성하세요.\n```text\n'____별로 생각해봐'는 CoT 유도 주문임. (이 부분을 채우세요)\n```",
    "answer": "단계",
    "why": "Step-by-step의 한국어 번역 키워드입니다.",
    "hint": "추론 유도구"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "4117",
    "question": "환각 방지 개념을 완성하세요.\n```text\n모르는 건 ____라고 답하게 함. (이 부분을 채우세요)\n```",
    "answer": "모른다",
    "why": "지어내지 않게 만드는 필수 지침입니다.",
    "hint": "환각 방지"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "4118",
    "question": "정합성 확보 개념을 완성하세요.\n```text\n답변의 신뢰도를 위해 ____를 0으로 설정하기도 함. (이 부분을 채우세요)\n```",
    "answer": "Temperature",
    "why": "일관성 있는 답을 위한 온도 설정값입니다.",
    "hint": "정합성 확보"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "4119",
    "question": "메모리 한도 개념을 완성하세요.\n```text\n모델이 한 번에 보는 토큰 한도를 ____ Window라 함. (이 부분을 채우세요)\n```",
    "answer": "Context",
    "why": "문맥을 한꺼번에 수용하는 창입니다.",
    "hint": "메모리 한도"
  },
  {
    "chapter_name": "프롬프트 엔지니어링",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "4120",
    "question": "데이터 최적화 개념을 완성하세요.\n```text\n중요 정보를 ____ 기호로 감싸 모델의 주의를 유도함. (이 부분을 채우세요)\n```",
    "answer": "강조",
    "why": "특정 부분을 눈에 띄게 만드는 엔지니어링입니다.",
    "hint": "데이터 최적화"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5001",
    "question": "RAG(Retrieval-Augmented Generation)의 가장 주된 도입 목적은?",
    "options": [
      "모델의 파라미터를 실시간으로 갱신하기 위해",
      "LLM의 할루시네이션(환각)을 줄이고 최신/외부 정보를 참조하게 하기 위해",
      "모델의 생성 속도를 비약적으로 높이기 위해",
      "인터넷 연결이 필요 없는 모델을 만들기 위해",
      "모델의 크기를 획기적으로 줄이기 위해"
    ],
    "answer": "LLM의 할루시네이션(환각)을 줄이고 최신/외부 정보를 참조하게 하기 위해",
    "why": "RAG는 신뢰할 수 있는 외부 지식 베이스를 검색하여 답변의 근거로 활용함으로써 오답률을 낮춥니다.",
    "hint": "RAG의 목적"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5002",
    "question": "RAG 시스템의 3단계 흐름(Retrieval - Augmentation - Generation) 중 'Retrieval' 단계에서 하는 일은?",
    "options": [
      "가장 적절한 답변을 생성한다.",
      "질문과 관련된 가장 유사한 문서 조각을 검색해온다.",
      "프롬프트를 보기 좋게 꾸민다.",
      "사용자의 지갑 주소를 확인한다.",
      "모델을 새로 학습시킨다."
    ],
    "answer": "질문과 관련된 가장 유사한 문서 조각을 검색해온다.",
    "why": "벡터 데이터베이스 등에서 질문의 의미와 부합하는 정보를 찾아내는 과정입니다.",
    "hint": "Retrieval"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5003",
    "question": "RAG에서 데이터를 검색할 때 주로 쓰이는 '벡터 유사도' 방식 중 가장 대표적인 것은?",
    "options": [
      "산술 평균",
      "코사인 유사도 (Cosine Similarity)",
      "랜덤 추출",
      "알파벳 순서 정렬",
      "파일 크기 비교"
    ],
    "answer": "코사인 유사도 (Cosine Similarity)",
    "why": "두 벡터 사이의 각도를 이용해 텍스트의 의미적 유사성을 측정하는 핵심 기법입니다.",
    "hint": "코사인 유사도"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5004",
    "question": "검색 증강 생성(RAG)이 Fine-tuning보다 유리한 상황은?",
    "options": [
      "모델의 말투나 어조를 완전히 바꾸고 싶을 때",
      "정보가 수시로 업데이트되는 실시간 뉴스를 다뤄야 할 때",
      "모델의 내부 가중치를 영구적으로 고정하고 싶을 때",
      "데이터셋의 용량이 매우 작을 때",
      "인터넷이 전혀 안 되는 환경일 때"
    ],
    "answer": "정보가 수시로 업데이트되는 실시간 뉴스를 다뤄야 할 때",
    "why": "RAG는 데이터베이스만 업데이트하면 즉시 최신 정보를 반영할 수 있어 효율적입니다.",
    "hint": "RAG vs Fine-tuning"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5005",
    "question": "RAG 파이프라인 중 문서를 저장하기 위해 잘게 쪼개는 과정을 무엇이라 하는가?",
    "options": [
      "Embedding",
      "Chunking (청킹)",
      "Scaling",
      "Masking",
      "Labeling"
    ],
    "answer": "Chunking (청킹)",
    "why": "모델의 인풋 제한(Context Window)에 맞춰 문서를 의미 있는 단위로 나누는 작업입니다.",
    "hint": "Chunking"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5006",
    "question": "나눠진 텍스트 조각(Chunks)을 수치 형태의 벡터로 변환하는 모델을 무엇이라 부르는가?",
    "options": [
      "LLM",
      "Embedding Model (임베딩 모델)",
      "Tokenizer",
      "Quantizer",
      "Compiler"
    ],
    "answer": "Embedding Model (임베딩 모델)",
    "why": "자연어의 의미를 고차원 공간상의 좌표(벡터)로 변환해주는 역할을 합니다.",
    "hint": "Embedding Model"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5007",
    "question": "변환된 벡터들을 저장하고 의미 기반 검색을 지원하는 특수한 데이터베이스는?",
    "options": [
      "MySQL",
      "Redis",
      "Vector Database (벡터 DB)",
      "MongoDB",
      "Oracle"
    ],
    "answer": "Vector Database (벡터 DB)",
    "why": "Pinecone, Chroma, Milvus 등 벡터 검색에 최적화된 DB를 활용합니다.",
    "hint": "Vector DB"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5008",
    "question": "RAG에서 'Augmentation' 단계의 역할로 적절한 것은?",
    "options": [
      "모델의 가중치를 키우는 행위",
      "검색된 결과물과 원래의 질문을 조합하여 풍부한 프롬프트를 만드는 것",
      "인터넷 속도를 높이는 작업",
      "모델의 성능 점수를 매기는 것",
      "데이터를 모두 지우는 것"
    ],
    "answer": "검색된 결과물과 원래의 질문을 조합하여 풍부한 프롬프트를 만드는 것",
    "why": "검색된 지식을 모델이 참고할 수 있도록 지시문과 함께 배치하는 단계입니다.",
    "hint": "Augmentation"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5009",
    "question": "임베딩 벡터의 '차원(Dimension)'이 의미하는 바는?",
    "options": [
      "데이터의 개수",
      "수치 데이터를 표현하는 화살표의 길이",
      "의미적 특징을 담고 있는 수치 리스트의 개수",
      "모델의 레이어 개수",
      "학습에 걸리는 시간"
    ],
    "answer": "의미적 특징을 담고 있는 수치 리스트의 개수",
    "why": "차원이 높을수록 더 정교한 의미를 담을 수 있지만 연산량도 늘어납니다.",
    "hint": "차원의 의미"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5010",
    "question": "RAG 시스템 성능 평가 시, 생성된 답변이 검색된 문서에 실제로 근거하고 있는지 측정하는 지표는?",
    "options": [
      "Hit Rate",
      "Faithfulness (충실도)",
      "Context Precision",
      "Answer Relevance",
      "Latency"
    ],
    "answer": "Faithfulness (충실도)",
    "why": "모델이 지어내서 대답(할루시네이션)하지 않고 근거에 충실했는지를 봅니다.",
    "hint": "Faithfulness"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5011",
    "question": "LLM이 단순히 답만 하는 게 아니라, 도구를 사용하거나 자율적으로 판단하여 동작하는 주체를 무엇이라 하는가?",
    "options": [
      "Chatbot",
      "Scanner",
      "LLM Agent (에이전트)",
      "Parser",
      "Optimizer"
    ],
    "answer": "LLM Agent (에이전트)",
    "why": "주어진 목표를 달성하기 위해 '생각(Thought)'과 '행동(Action)'을 반복하는 시스템입니다.",
    "hint": "Agent"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5012",
    "question": "에이전트가 문제 해결을 위해 '생각 - 행동 - 관찰' 루프를 타는 대표적인 추론 방식은?",
    "options": [
      "Chain of Thought (CoT)",
      "ReAct (Reasoning + Acting)",
      "Few-shot",
      "Top-P Sampling",
      "Fine-tuning"
    ],
    "answer": "ReAct (Reasoning + Acting)",
    "why": "사유와 행동, 외부 환경 관찰을 결합하여 복잡한 목표를 수행하는 방식입니다.",
    "hint": "ReAct"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5013",
    "question": "에이전트가 외부 세계와 상호작용하기 위해 갖추고 있는 기능(예: 검색, 계산기, API 호출)을 일컫는 말은?",
    "options": [
      "Parameters",
      "Weights",
      "Tools (도구)",
      "Layers",
      "Biases"
    ],
    "answer": "Tools (도구)",
    "why": "LangChain 등 프레임워크에서 에이전트가 실행할 수 있는 함수들을 정의한 것입니다.",
    "hint": "Tools"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5014",
    "question": "랭체인(LangChain) 프레임워크에서 선언적인 파이프라인 구성을 위해 사용하는 문법은?",
    "options": [
      "HTML/CSS",
      "LCEL (LangChain Expression Language)",
      "SQL Query",
      "Direct API Call",
      "Regular Expression"
    ],
    "answer": "LCEL (LangChain Expression Language)",
    "why": "파이프 연산자(|)를 사용해 데이터의 흐름을 직관적으로 연결합니다.",
    "hint": "LCEL"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5015",
    "question": "에이전트가 이전 대화 내역이나 실행 결과를 기억하고 활용하기 위해 필요한 구성 요소는?",
    "options": [
      "CPU",
      "GPU",
      "Memory (메모리)",
      "Disk",
      "Monitor"
    ],
    "answer": "Memory (메모리)",
    "why": "ConversationBufferMemory 등을 통해 대화의 맥락을 유지합니다.",
    "hint": "Agent Memory"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5016",
    "question": "RAG 시스템에서 청킹(Chunking)을 너무 크게 했을 때 발생할 수 있는 부작용은?",
    "options": [
      "검색 적중률이 너무 높아진다.",
      "불필요한 정보(Noise)가 섞여 모델의 답변이 흐려진다.",
      "비용이 전혀 들지 않는다.",
      "모델의 지능이 낮아진다.",
      "한국어 답변이 안 나온다."
    ],
    "answer": "불필요한 정보(Noise)가 섞여 모델의 답변이 흐려진다.",
    "why": "너무 큰 덩어리는 질문과 핵심적인 관련이 없는 내용까지 포함하여 추론을 방해할 수 있습니다.",
    "hint": "과한 청킹"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5017",
    "question": "반대로 청킹을 너무 작게(10글자 등) 했을 때의 문제점은?",
    "options": [
      "문맥(Context)이 단절되어 문서의 의미를 파악하기 힘들다.",
      "검색 속도가 100배 빨라진다.",
      "모델이 모든 내용을 외워버린다.",
      "서버가 중단된다.",
      "답변이 너무 길어진다."
    ],
    "answer": "문맥(Context)이 단절되어 문서의 의미를 파악하기 힘들다.",
    "why": "파편화된 정보만으로는 질문에 대한 충분한 배경 지식을 전달하기 어렵습니다.",
    "hint": "부족한 청킹"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5018",
    "question": "벡터 DB 검색 성능 지표 중 'Hit Rate'의 의미로 옳은 것은?",
    "options": [
      "서버가 다운된 횟수",
      "검색 결과 상위 K개 안에 실제 정답 문서가 포함된 비율",
      "화면을 클릭한 횟수",
      "데이터를 삭제한 개수",
      "비밀번호를 틀린 횟수"
    ],
    "answer": "검색 결과 상위 K개 안에 실제 정답 문서가 포함된 비율",
    "why": "검색 단계가 얼마나 질문과 연관된 문서를 잘 찾아오는지를 나타내는 기본 지표입니다.",
    "hint": "Hit Rate"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5019",
    "question": "RAG 파이프라인 중 검색된 결과의 순위를 다시 매겨 정확도를 높이는 단계를 무엇이라 하나?",
    "options": [
      "Pre-ranking",
      "Re-ranking (리랭킹)",
      "Decoding",
      "Encoding",
      "Flattening"
    ],
    "answer": "Re-ranking (리랭킹)",
    "why": "단순 벡터 유사도 계산 후, 더 정교한 모델로 실제 관련성을 재검증하는 과정입니다.",
    "hint": "Re-ranking"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5020",
    "question": "에이전트 설계 시 '멀티 에이전트' 시스템의 장점은?",
    "options": [
      "한 명의 에이전트가 모든 일을 다 하게 한다.",
      "역할별로 특화된 에이전트들이 협력하여 대규모 복잡한 문제를 효율적으로 푼다.",
      "비용을 무조건 줄여준다.",
      "AI 개발을 중단할 수 있다.",
      "컴퓨터 사양을 낮춰준다."
    ],
    "answer": "역할별로 특화된 에이전트들이 협력하여 대규모 복잡한 문제를 효율적으로 푼다.",
    "why": "기획 에이전트, 서칭 에이전트, 코딩 에이전트 등으로 분업하여 품질을 높입니다.",
    "hint": "Multi-Agent"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5021",
    "question": "텍스트를 유의미한 단위로 나누기 위해 문장 구분자나 줄바꿈을 기준으로 재귀적으로 쪼개는 청커는?",
    "options": [
      "CharacterTextSplitter",
      "RecursiveCharacterTextSplitter",
      "TokenTextSplitter",
      "RandomSplitter",
      "NoneSplitter"
    ],
    "answer": "RecursiveCharacterTextSplitter",
    "why": "의미적 단위를 최대한 보존하며 적절한 크기에 도달할 때까지 쪼개는 권장 방식입니다.",
    "hint": "Recursive Splitter"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5022",
    "question": "RAG 환경에서 'Top-K' 값을 높이면 어떤 일이 벌어지는가?",
    "options": [
      "검색 결과에 더 많은 문서 조각을 포함시킨다.",
      "답변의 글자 수가 무조건 줄어든다.",
      "모델이 더 빨리 답한다.",
      "비용이 할인된다.",
      "한글이 영어로 변한다."
    ],
    "answer": "검색 결과에 더 많은 문서 조각을 포함시킨다.",
    "why": "다양한 참조 문서를 넣을 수 있지만, 너무 많으면 문맥 초과나 노이즈가 발생할 수 있습니다.",
    "hint": "Top-K 조절"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5023",
    "question": "임베딩 모델을 선택할 때 고려해야 할 'MTEB' 벤치마크란?",
    "options": [
      "모델의 크기 측정기",
      "다양한 텍스트 임베딩 성능을 평가하는 표준 리더보드",
      "서버의 발열 측정",
      "모니터의 주사율",
      "인터넷 속도"
    ],
    "answer": "다양한 텍스트 임베딩 성능을 평가하는 표준 리더보드",
    "why": "성능이 검증된 임베딩 모델을 선택하기 위한 공신력 있는 참조 지표입니다.",
    "hint": "MTEB"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5024",
    "question": "벡터 DB의 인덱싱 기법 중 '고속 근사 최근접 이웃(ANN)' 검색을 위해 쓰이는 대표적 알고리즘은?",
    "options": [
      "B-Tree",
      "HNSW (Hierarchical Navigable Small World)",
      "Hash Table",
      "Bubble Sort",
      "Quick Search"
    ],
    "answer": "HNSW (Hierarchical Navigable Small World)",
    "why": "방대한 벡터 데이터 속에서 가장 유사한 좌표를 빠르게 찾는 핵심 알고리즘입니다.",
    "hint": "HNSW"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5025",
    "question": "랭체인에서 PDF 문서를 읽어오기 위해 사용하는 컴포넌트의 타입은?",
    "options": [
      "Document Writer",
      "Document Loader",
      "Document Deleter",
      "Document Hider",
      "Document Copier"
    ],
    "answer": "Document Loader",
    "why": "비정형 파일에서 텍스트와 메타데이터를 추출하는 시작점입니다.",
    "hint": "Loader"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5026",
    "question": "검색된 문서의 연관성이 떨어지는 경우 질문을 더 검색하기 좋은 형태로 다시 쓰는 기법은?",
    "options": [
      "Query Rewriting (쿼리 재작성)",
      "Text Deleting",
      "Word Counting",
      "Grammar Error",
      "Stop"
    ],
    "answer": "Query Rewriting (쿼리 재작성)",
    "why": "사용자의 모호한 질문을 AI가 풍부한 키워드로 변환하여 검색 정확도를 높입니다.",
    "hint": "Query Rewriting"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5027",
    "question": "에이전트가 어떤 도구를 써야 할지 모델에게 알려주기 위해 제공하는 정보는?",
    "options": [
      "도구의 소스 코드 전체",
      "도구의 이름, 기능 설명, 입력받을 인자(Parameter)의 스킴",
      "도구 제작자의 이름",
      "도구의 용량",
      "도구의 가격"
    ],
    "answer": "도구의 이름, 기능 설명, 입력받을 인자(Parameter)의 스킴",
    "why": "모델은 이 설명을 읽고 현재 상황에서 어떤 도구가 필요한지 논리적으로 판단합니다.",
    "hint": "Tool description"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5028",
    "question": "RAG 시스템 운영 시 'Ground Truth'의 역할은?",
    "options": [
      "실제 답변 데이터",
      "성능 측정 시 비교 대상이 되는 정답(기준값) 데이터셋",
      "서버의 위치",
      "모델의 이름",
      "사용자의 개인정보"
    ],
    "answer": "성능 측정 시 비교 대상이 되는 정답(기준값) 데이터셋",
    "why": "시스템이 낸 답이 실제 정답과 얼마나 유사한지 점수를 매기기 위한 기준입니다.",
    "hint": "Ground Truth"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5029",
    "question": "임베딩 벡터 사이의 거리가 '가까울수록' 텍스트의 의미는 어떠한가?",
    "options": [
      "아무 상관 없다.",
      "의미가 매우 유사하다.",
      "의미가 정반대다.",
      "철자가 완전히 다르다.",
      "영어로 쓰여 있다."
    ],
    "answer": "의미가 매우 유사하다.",
    "why": "벡터 공간상의 가까운 거리는 자연어 처리에서 의미적 연관성이 깊음을 뜻합니다.",
    "hint": "벡터 거리 의미"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5030",
    "question": "검색 성능을 높이기 위해 벡터 유사도와 전통적인 키워드 매칭(BM25)을 섞어 쓰는 방식은?",
    "options": [
      "Random Search",
      "Hybrid Search (하이브리드 검색)",
      "Linear Search",
      "Binary Search",
      "Manual Search"
    ],
    "answer": "Hybrid Search (하이브리드 검색)",
    "why": "의미적 유사성과 고유 대명사 매칭의 강점을 모두 활용하는 강력한 전략입니다.",
    "hint": "Hybrid Search"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5031",
    "question": "에이전트가 루프에 빠져 무한히 도구를 실행하는 것을 방지하기 위한 안전장치는?",
    "options": [
      "인터넷 끊기",
      "Max Iterations (최대 반복 횟수) 설정",
      "컴퓨터 끄기",
      "키보드 빼기",
      "질문 무시하기"
    ],
    "answer": "Max Iterations (최대 반복 횟수) 설정",
    "why": "일정 횟수 이상 도구를 돌려도 답이 안 나오면 중단하도록 하여 비용과 시간을 보호합니다.",
    "hint": "Max Iterations"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5032",
    "question": "LCEL 문법에서 'prompt | model | parser' 구조일 때 'parser'의 역할은?",
    "options": [
      "모델의 지능을 높임",
      "모델이 내놓은 텍스트 응답을 JSON이나 리스트 등 정형화된 데이터로 변환함",
      "프롬프트를 삭제함",
      "비용을 결제함",
      "오타를 냄"
    ],
    "answer": "모델이 내놓은 텍스트 응답을 JSON이나 리스트 등 정형화된 데이터로 변환함",
    "why": "AI의 답변을 소프트웨어 시스템에서 즉시 사용할 수 있는 데이터로 가공합니다.",
    "hint": "Output Parser"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5033",
    "question": "벡터 DB의 메타데이터 필터링(Metadata Filtering)이 유용한 시나리오는?",
    "options": [
      "유사도만으로 충분할 때",
      "특정 날짜 이후의 문서나 특정 작성자의 글만 검색 범위로 한정하고 싶을 때",
      "데이터가 아예 없을 때",
      "모델을 튜닝할 때",
      "영어를 안 쓸 때"
    ],
    "answer": "특정 날짜 이후의 문서나 특정 작성자의 글만 검색 범위로 한정하고 싶을 때",
    "why": "의미 기반 검색에 '조건'을 추가해 결과의 정확도를 비약적으로 높입니다.",
    "hint": "Metadata Filtering"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5034",
    "question": "에이전트가 문제를 해결하는 과정을 사용자가 실시간으로 보게 하는 기술은?",
    "options": [
      "Stealing",
      "Streaming (스트리밍)",
      "Cracking",
      "Stopping",
      "Hiding"
    ],
    "answer": "Streaming (스트리밍)",
    "why": "사고 과정(Thought)과 결과가 나오는 즉시 화면에 노출하여 UX를 개선합니다.",
    "hint": "Streaming"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5035",
    "question": "사내 RAG 시스템 구축 시 데이터 보안을 위해 가장 권장되는 방식은?",
    "options": [
      "모든 데이터를 공용 챗봇에 입력한다.",
      "보안이 확보된 내부망에 벡터 DB와 임베딩 서버를 구축한다.",
      "데이터를 암호화하지 않고 보관한다.",
      "누구나 검색 가능하게 설정한다.",
      "모든 사내 문서를 인터넷에 공개한다."
    ],
    "answer": "보안이 확보된 내부망에 벡터 DB와 임베딩 서버를 구축한다.",
    "why": "민감한 기업 정보가 외부로 새나가지 않도록 폐쇄적인 파이프라인을 유지해야 합니다.",
    "hint": "RAG 보안"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5036",
    "question": "RAG 시스템에서 '환각'을 유발하는 가장 흔한 원인은?",
    "options": [
      "모델이 너무 똑똑해서",
      "질문과 전혀 상관없는 문서 조각이 검색 결과로 제공될 때",
      "인터넷이 너무 빨라서",
      "화면이 너무 커서",
      "키보드 타이핑이 빨라서"
    ],
    "answer": "질문과 전혀 상관없는 문서 조각이 검색 결과로 제공될 때",
    "why": "잘못된 정보를 근거로 주면 모델은 그 정보에 맞춰 엉뚱한 결론을 내리게 됩니다.",
    "hint": "환각 원인"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5037",
    "question": "청킹 시 앞뒤 조각의 내용을 일부 겹치게(Overlap) 설정하는 이유는?",
    "options": [
      "데이터를 낭비하려고",
      "문장의 중간이 잘려 문맥의 의미가 훼손되는 것을 방지하기 위해",
      "똑같은 말을 반복하려고",
      "글자 수를 늘리려고",
      "비용을 높이려고"
    ],
    "answer": "문장의 중간이 잘려 문맥의 의미가 훼손되는 것을 방지하기 위해",
    "why": "조금씩 겹쳐야 문서의 전체적인 맥락이 끊기지 않고 벡터에 잘 반영됩니다.",
    "hint": "Overlap"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5038",
    "question": "에이전트가 도구 사용을 거부하고 '직접 답'을 하려고만 한다면 고쳐야 할 부분은?",
    "options": [
      "모델 가중치",
      "도구 사용법을 명확히 하고, 반드시 도구를 쓰도록 강조한 프롬프트(지침)",
      "마우스 마찰력",
      "방 안의 온도",
      "모니터 주사율"
    ],
    "answer": "도구 사용법을 명확히 하고, 반드시 도구를 쓰도록 강조한 프롬프트(지침)",
    "why": "시스템 프롬프트의 지시 강도를 높여 도구 사용의 당위성을 인지시켜야 합니다.",
    "hint": "도구 사용 지시"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5039",
    "question": "RAGAS 프레임워크가 평가에 사용하는 주된 동력은?",
    "options": [
      "사람의 설문조사",
      "LLM(거대 언어 모델) 자체를 평가자로 활용 (LLM-as-a-judge)",
      "단어 개수 세기",
      "파일 크기 측정",
      "랜덤 점수 부여"
    ],
    "answer": "LLM(거대 언어 모델) 자체를 평가자로 활용 (LLM-as-a-judge)",
    "why": "사람보다 빠르고 객관적인 기준(수식)으로 RAG의 품질 점수를 자동 산출합니다.",
    "hint": "RAGAS"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5040",
    "question": "교재 5장을 학습하며 우리가 만들 수 있는 최종적인 형태는?",
    "options": [
      "단순한 말동무 챗봇",
      "특정 도메인의 전문 지식을 검색하고 직접 작업을 수행하는 인텔리전트 에이전트",
      "타이핑 연습 게임",
      "인터넷 검색 엔진",
      "컴퓨터 수리 도구"
    ],
    "answer": "특정 도메인의 전문 지식을 검색하고 직접 작업을 수행하는 인텔리전트 에이전트",
    "why": "AI의 지능과 외부 데이터, 외부 도구가 결합된 진정한 애플리케이션의 핵심입니다.",
    "hint": "학습 결과"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5041",
    "question": "복잡한 법률 판례를 RAG로 구축할 때 가장 중요한 청킹 전략은?",
    "options": [
      "그냥 100글자씩 자르기",
      "법조항 섹션이나 판결 요지 단위로 의미를 보존하며 자르기",
      "아무렇게나 자르기",
      "자르지 않기",
      "영어로만 자르기"
    ],
    "answer": "법조항 섹션이나 판결 요지 단위로 의미를 보존하며 자르기",
    "why": "법률 문서는 구조가 중요하므로 의미적 완결성을 가진 단위로 나누어야 검색 정확도가 높습니다.",
    "hint": "법률 RAG"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5042",
    "question": "에이전트가 '오늘 날씨'를 알려달라는 질문을 받았을 때 필요한 도구는?",
    "options": [
      "계산기",
      "실시간 날씨 정보 API 연동 도구",
      "이미지 생성기",
      "소설 쓰기 도구",
      "파일 삭제기"
    ],
    "answer": "실시간 날씨 정보 API 연동 도구",
    "why": "학습 데이터에는 오늘 날씨가 없으므로 외부 API 호출이 필수적입니다.",
    "hint": "날씨 에이전트"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5043",
    "question": "검색 속도를 개선하기 위해 로컬 컴퓨터 메모리에 벡터를 올리는 라이브러리는?",
    "options": [
      "FAISS (Facebook AI Similarity Search)",
      "Excel",
      "Notepad",
      "PowerPoint",
      "Calculator"
    ],
    "answer": "FAISS (Facebook AI Similarity Search)",
    "why": "고밀도 벡터 검색을 CPU/GPU에서 고속으로 수행해주는 오픈소스 라이브러리입니다.",
    "hint": "FAISS"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5044",
    "question": "RAG 시스템 구축 후 답변이 너무 느리다면 체크해야 할 단계는?",
    "options": [
      "사용한 글꼴",
      "임베딩 생성 시간 및 검색 단계의 레이턴시(Latency)",
      "사용자의 의자 높이",
      "마우스 패드 재질",
      "방 안의 습도"
    ],
    "answer": "임베딩 생성 시간 및 검색 단계의 레이턴시(Latency)",
    "why": "문서 로딩이나 벡터 검색 과정에서 병목이 생기는지 확인해야 합니다.",
    "hint": "속도 개선"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5045",
    "question": "에이전트가 SQL 쿼리를 직접 짜서 DB를 조회하게 할 때의 위험성과 해법은?",
    "options": [
      "위험성 없음",
      "잘못된 쿼리로 데이터가 삭제될 수 있으므로 전용 읽기 권한(Read-only) 계정을 부여한다.",
      "AI는 SQL을 모른다.",
      "데이터가 너무 많아진다.",
      "컴퓨터가 폭발한다."
    ],
    "answer": "잘못된 쿼리로 데이터가 삭제될 수 있으므로 전용 읽기 권한(Read-only) 계정을 부여한다.",
    "why": "보안과 데이터 무결성을 위해 실행 권한을 최소화하는 하드닝 작업이 필요합니다.",
    "hint": "SQL 에이전트 보안"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5046",
    "question": "고객 상담 RAG에서 '질문-답변 쌍'을 수만 개 저장했을 때 효과적인 필터링은?",
    "options": [
      "무조건 다 읽기",
      "카테고리 메타데이터를 활용한 필터링 후 검색",
      "가나다 순 검색",
      "최근 저장 순 검색",
      "파일 이름 검색"
    ],
    "answer": "카테고리 메타데이터를 활용한 필터링 후 검색",
    "why": "검색 범위를 미리 좁히면 속도와 정확도가 동시에 향상됩니다.",
    "hint": "대량 데이터 검색"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5047",
    "question": "사용자의 질문이 너무 짧아(예: '그거 알려줘') 검색이 안 될 때 에이전트의 대처는?",
    "options": [
      "모른다고 화내기",
      "질문의 의도를 다시 물어보며 정보를 구체화해달라고 요청하기",
      "아무거나 알려주기",
      "인터넷 연결 끊기",
      "로그아웃 시키기"
    ],
    "answer": "질문의 의도를 다시 물어보며 정보를 구체화해달라고 요청하기",
    "why": "대화형 에이전트의 강점을 살려 부족한 정보를 사용자에게 되묻는 지능적 행동입니다.",
    "hint": "질문 구체화"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5048",
    "question": "임베딩 모델의 성능이 한국어에서 떨어진다면?",
    "options": [
      "한국어를 포기한다.",
      "한국어 데이터로 학습된 특화 임베딩 모델(Ko-Embedding)을 검토한다.",
      "영어로만 모든 문서를 바꾼다.",
      "키보드를 한글용으로 바꾼다.",
      "파이썬 버전을 높인다."
    ],
    "answer": "한국어 데이터로 학습된 특화 임베딩 모델(Ko-Embedding)을 검토한다.",
    "why": "언어적 뉘앙스를 잘 파악하는 로컬 특화 모델이 RAG 품질을 좌우합니다.",
    "hint": "한국어 임베딩"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5049",
    "question": "검색된 문서 내용이 상충할 때(A문서는 된다, B문서는 안 된다) 모델에게 줄 가이드는?",
    "options": [
      "아무거나 믿어라",
      "최신 날짜의 문서를 우선시하거나, 상충하는 내용을 모두 보여주며 판단을 돕게 한다.",
      "답변을 하지 마라",
      "화내라",
      "둘을 합쳐서 제3의 답변을 지어내라"
    ],
    "answer": "최신 날짜의 문서를 우선시하거나, 상충하는 내용을 모두 보여주며 판단을 돕게 한다.",
    "why": "정보의 일관성을 관리하는 정책을 프롬프트나 로직에 반영해야 합니다.",
    "hint": "정보 상충 해결"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5050",
    "question": "RAG 시스템을 웹 서비스로 배포할 때 사용하는 LangChain 호환 도구는?",
    "options": [
      "LangServe",
      "HTML Edit",
      "Paint",
      "Excel Online",
      "Minesweeper"
    ],
    "answer": "LangServe",
    "why": "작성한 체인을 REST API 형태로 즉시 공개해주는 배포 특화 도구입니다.",
    "hint": "LangServe"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5051",
    "question": "에이전트가 도구를 실행한 후 나온 '결과'를 ReAct에서 부르는 용어는?",
    "options": [
      "Thought",
      "Action",
      "Observation (관찰)",
      "Final Answer",
      "Input"
    ],
    "answer": "Observation (관찰)",
    "why": "도구의 출력값을 통해 모델이 현 상황을 파악하는 단계를 의미합니다.",
    "hint": "Observation"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5052",
    "question": "RAG 개발 시 문서를 벡터화하는 작업을 미리 해두는 과정을 무엇이라 하나?",
    "options": [
      "Online Ingestion",
      "Offline Indexing / Ingestion",
      "Real-time Chat",
      "Slow Reading",
      "Deleting"
    ],
    "answer": "Offline Indexing / Ingestion",
    "why": "사용자 질문 전에 데이터를 미리 준비해두는 배치 작업입니다.",
    "hint": "Indexing"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5053",
    "question": "모델이 답변 도중 '출처: 교재 123페이지'라고 적게 하려면?",
    "options": [
      "모델이 알아서 한다.",
      "프롬프트에 '검색된 문서의 메타데이터 중 페이지 정보를 반드시 명시해'라고 지시한다.",
      "페이지를 다 외우게 한다.",
      "가짜 번호를 적는다.",
      "페이지 번호를 다 지운다."
    ],
    "answer": "프롬프트에 '검색된 문서의 메타데이터 중 페이지 정보를 반드시 명시해'라고 지시한다.",
    "why": "근거 제시(Citation)는 RAG 시스템의 신뢰도를 높여주는 강력한 장치입니다.",
    "hint": "출처 명시"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5054",
    "question": "여러 개의 질문을 한 번에 처리하는 에이전트 효율화 기법은?",
    "options": [
      "한 개씩 한다.",
      "Async(비동기) 처리나 배치 처리를 활용한다.",
      "컴퓨터를 여러 대 산다.",
      "사용자를 기다리게 한다.",
      "질문을 지운다."
    ],
    "answer": "Async(비동기) 처리나 배치 처리를 활용한다.",
    "why": "동시에 여러 지식 소스를 검색하거나 도구를 돌려 응답 시간을 단축합니다.",
    "hint": "비동기 처리"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5055",
    "question": "RAG 시스템 성능 측정 도구 'Ragas'에서 Faithfulness가 0.1이라면?",
    "options": [
      "아주 훌륭하다.",
      "모델이 검색된 근거와 무관한 소설을 쓰고 있다는 매우 위험한 신호다.",
      "컴퓨터가 고장 났다.",
      "점수가 원래 낮다.",
      "무시해도 된다."
    ],
    "answer": "모델이 검색된 근거와 무관한 소설을 쓰고 있다는 매우 위험한 신호다.",
    "why": "근거 충실도가 낮으므로 프롬프트를 고치거나 검색 품질을 점검해야 합니다.",
    "hint": "저점수 분석"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5056",
    "question": "에이전트가 '반복 루프'에 빠졌을 때 터미널 로그에서 확인해야 할 것은?",
    "options": [
      "프롬프트 색깔",
      "Thought와 Action이 동일한 내용으로 반복되는지 여부",
      "내 아이디",
      "오늘 날짜",
      "파이썬 로고"
    ],
    "answer": "Thought와 Action이 동일한 내용으로 반복되는지 여부",
    "why": "논리가 막혔거나 도구 설명이 모호할 때 발생하는 전형적인 에이전트 에러입니다.",
    "hint": "루프 확인"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5057",
    "question": "청킹 시 '의미 구조'를 파악하여 제목과 본문을 연결해두면 좋은 점은?",
    "options": [
      "파일 이름이 예뻐진다.",
      "검색 시 본문만 나오는 게 아니라 제목이라는 문맥 정보도 함께 제공되어 정확도가 오른다.",
      "똑같은 지식이 두 번 저장된다.",
      "용량이 늘어난다.",
      "속도가 느려진다."
    ],
    "answer": "검색 시 본문만 나오는 게 아니라 제목이라는 문맥 정보도 함께 제공되어 정확도가 오른다.",
    "why": "상위 카테고리 정보가 포함된 청크는 모델이 정보를 파악하는 데 훨씬 유리합니다.",
    "hint": "구조화 청킹"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5058",
    "question": "RAG 시스템에서 '토큰 비용'을 가장 많이 잡아먹는 단계는?",
    "options": [
      "모델의 1글자 답변",
      "다량의 검색 결과 조각을 프롬프트에 통째로 밀어넣는 Augmentation 단계",
      "마우스 클릭",
      "파일 저장",
      "윈도우 업데이트"
    ],
    "answer": "다량의 검색 결과 조각을 프롬프트에 통째로 밀어넣는 Augmentation 단계",
    "why": "검색 결과를 너무 많이 넣으면 입력 토큰량이 급증하여 비용이 상승합니다.",
    "hint": "비용 병목"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5059",
    "question": "에이전트에게 '전문가 페르소나'를 부여하는 것이 도구 사용과 관련이 있나?",
    "options": [
      "상관없다.",
      "네, 전문가로서 어떤 상황에 어떤 도구를 쓰는 것이 논리적인지 더 잘 판단하게 돕는다.",
      "전혀 아니다.",
      "모델이 기분 나빠한다.",
      "돈이 더 든다."
    ],
    "answer": "네, 전문가로서 어떤 상황에 어떤 도구를 쓰는 것이 논리적인지 더 잘 판단하게 돕는다.",
    "why": "페르소나는 에이전트의 판단 로직 전반에 가이드라인 역할을 합니다.",
    "hint": "페르소나와 도구"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5060",
    "question": "최종적으로 RAG와 에이전트를 결합했을 때의 모습은?",
    "options": [
      "단순 텍스트 생성기",
      "외부 지식을 스스로 찾아 학습하고 실제 업무(API 호출 등)를 수행하는 인공지능 비서",
      "인터넷 게시판",
      "성적표 계산기",
      "게임 캐릭터"
    ],
    "answer": "외부 지식을 스스로 찾아 학습하고 실제 업무(API 호출 등)를 수행하는 인공지능 비서",
    "why": "생성 AI가 실질적인 비즈니스 가치를 창출하는 가장 강력한 워크플로우입니다.",
    "hint": "에이전틱 RAG"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5061",
    "question": "LangChain의 'Memory' 옵션 중 'ConversationSummaryMemory'의 장점은?",
    "options": [
      "모든 대화를 다 저장한다.",
      "긴 대화 내역을 요약해서 보관하므로 토큰 사용량을 효율적으로 관리할 수 있다.",
      "비밀번호를 외운다.",
      "사진을 저장한다.",
      "인터넷이 빨라진다."
    ],
    "answer": "긴 대화 내역을 요약해서 보관하므로 토큰 사용량을 효율적으로 관리할 수 있다.",
    "why": "대화가 길어져도 핵심 맥락을 유지하면서 비용을 절감하는 영리한 방법입니다.",
    "hint": "Summary Memory"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5062",
    "question": "검색된 문서가 너무 많아 모델의 Context Window를 초과할 때의 대처법은?",
    "options": [
      "모델을 바꾼다.",
      "검색 결과를 요약해서 넣거나 리랭킹을 통해 상위 3개만 추려 넣는다.",
      "컴퓨터를 끈다.",
      "글자를 작게 적는다.",
      "영어로 번역한다."
    ],
    "answer": "검색 결과를 요약해서 넣거나 리랭킹을 통해 상위 3개만 추려 넣는다.",
    "why": "입력 제한을 지키면서 알짜 정보만 전달하는 엔지니어링이 필요합니다.",
    "hint": "컨텍스트 초과 대처"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5063",
    "question": "RAG 시스템에서 'Semantic Search'가 'Keyword Search'보다 나은 점은?",
    "options": [
      "오타가 나면 검색이 안 된다.",
      "단어가 일치하지 않아도 의미적으로 유사한 내용을 찾아낼 수 있다.",
      "속도가 훨씬 빠르다.",
      "가격이 무료다.",
      "모델이 안 필요하다."
    ],
    "answer": "단어가 일치하지 않아도 의미적으로 유사한 내용을 찾아낼 수 있다.",
    "why": "자연어의 맥락을 파악하므로 사용자 의도에 훨씬 부합하는 결과를 줍니다.",
    "hint": "의미 검색 장점"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5064",
    "question": "에이전트 프롬프트에 'Thought:'라고 형식을 지정해주는 이유는?",
    "options": [
      "모델을 놀리려고",
      "모델이 자신의 추론 과정을 명시적으로 적도록 강제하여 정답률을 높이기 위해",
      "서버 이름을 지으려고",
      "글자 수 채우려고",
      "내 이름 쓰려고"
    ],
    "answer": "모델이 자신의 추론 과정을 명시적으로 적도록 강제하여 정답률을 높이기 위해",
    "why": "CoT와 마찬가지로 중간 사고 단계를 거치게 함으로써 실수를 방지합니다.",
    "hint": "Thought 형식"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5065",
    "question": "RAG 시스템 평가 지표 중 'Answer Relevance'가 낮다면 원인은?",
    "options": [
      "검색은 잘 됐으나 모델이 질문과 무관한 엉뚱한 답변을 함",
      "인터넷이 끊김",
      "모델이 너무 똑똑함",
      "사용자가 질문을 안 함",
      "파일이 삭제됨"
    ],
    "answer": "검색은 잘 됐으나 모델이 질문과 무관한 엉뚱한 답변을 함",
    "why": "검색 품질보다는 모델의 생성 능력이나 가이드라인(프롬프트)에 문제가 있는 경우입니다.",
    "hint": "Answer Relevance"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5066",
    "question": "에이전트가 도구를 사용할 때 'Observation' 값을 읽지 못한다면?",
    "options": [
      "모델을 때린다.",
      "도구의 반환 형식이 문자열(String) 등 모델이 읽기 쉬운 형태인지 확인한다.",
      "파일을 다 지운다.",
      "모니터를 닦는다.",
      "인터넷을 바꾼다."
    ],
    "answer": "도구의 반환 형식이 문자열(String) 등 모델이 읽기 쉬운 형태인지 확인한다.",
    "why": "데이터 파이프라인의 입출력 형식이 맞아야 에이전트가 다음 판단을 내릴 수 있습니다.",
    "hint": "관찰값 확인"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5067",
    "question": "사내 RAG 서버에서 'PDF 테이블'이 텍스트로만 읽혀 구조가 깨진다면?",
    "options": [
      "표를 직접 그린다.",
      "표 구조를 인식하는 전용 Loader나 레이아웃 분석 모델을 활용한다.",
      "표를 무시한다.",
      "숫자만 다 지운다.",
      "PDF를 사진으로 찍는다."
    ],
    "answer": "표 구조를 인식하는 전용 Loader나 레이아웃 분석 모델을 활용한다.",
    "why": "데이터의 레이아웃을 보존하며 파싱하는 기술이 고도화된 RAG의 품질을 결정합니다.",
    "hint": "표 인식"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5068",
    "question": "LangChain의 'RouterChain'을 사용하여 얻을 수 있는 효과는?",
    "options": [
      "모든 명령을 한 곳으로 보낸다.",
      "질문의 주제에 따라 서로 다른 프롬프트나 DB 검색 경로로 자동 배정한다.",
      "인터넷 속도가 빨라진다.",
      "비용이 무조건 0원이다.",
      "컴퓨터가 알아서 꺼진다."
    ],
    "answer": "질문의 주제에 따라 서로 다른 프롬프트나 DB 검색 경로로 자동 배정한다.",
    "why": "효율적인 작업 분배를 통해 전문성 있는 답변을 가능하게 합니다.",
    "hint": "RouterChain"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5069",
    "question": "RAG 개발 시 '임베딩 모델'과 '생성 모델'의 회사가 달라도 되나?",
    "options": [
      "절대 안 된다.",
      "상관없지만, 임베딩 모델의 차원과 벡터 DB 설정은 일치해야 한다.",
      "회사 이름이 같아야 한다.",
      "모델을 섞으면 폭발한다.",
      "아무도 시도하지 않았다."
    ],
    "answer": "상관없지만, 임베딩 모델의 차원과 벡터 DB 설정은 일치해야 한다.",
    "why": "다양한 모델을 조합(Mix & Match)하여 최적의 가성비를 찾는 것이 실무입니다.",
    "hint": "모델 조합"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5070",
    "question": "에이전트가 '반복적인 질문'을 받을 때 성능을 높이는 메모리 기법은?",
    "options": [
      "다 잊어버리기",
      "이전 답변을 캐싱(Caching)하여 동일한 질문엔 빠르게 답하기",
      "질문을 무시하기",
      "일부러 틀리기",
      "돈을 더 내기"
    ],
    "answer": "이전 답변을 캐싱(Caching)하여 동일한 질문엔 빠르게 답하기",
    "why": "반복적인 인프라 비용과 응답 지연을 방지하는 실용적인 방법입니다.",
    "hint": "캐싱"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5071",
    "question": "RAG 파이프라인 중 'Semantic Chunking'이란?",
    "options": [
      "글자 수로 자르기",
      "의미가 변하는 지점을 감지하여 논리적 단락 단위로 자르기",
      "아무렇게나 자르기",
      "영어로 자르기",
      "숫자만 자르기"
    ],
    "answer": "의미가 변하는 지점을 감지하여 논리적 단락 단위로 자르기",
    "why": "단순 글자 수보다 훨씬 정교하게 지식의 맥락을 보존하는 청킹 방식입니다.",
    "hint": "Semantic Chunking"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5072",
    "question": "에이전트의 '자율성'을 제한하고 사람이 승인할 때만 실행하게 하는 설정은?",
    "options": [
      "AI의 반란 방지",
      "Human-in-the-loop (사람의 개입)",
      "AI 정지",
      "사용자 차단",
      "서버 종료"
    ],
    "answer": "Human-in-the-loop (사람의 개입)",
    "why": "안전이 중요한 작업(예: 결제, 이메일 발송)에서 필수적인 설계 패턴입니다.",
    "hint": "Human-in-the-loop"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5073",
    "question": "RAG 시스템 평가 시 'Context Precision'이란?",
    "options": [
      "답변이 얼마나 긴가",
      "검색된 문서들 중 실제 질문과 관련된 문서가 상위에 잘 배치되었는가",
      "화질이 좋은가",
      "글꼴이 예쁜가",
      "오타가 없는가"
    ],
    "answer": "검색된 문서들 중 실제 질문과 관련된 문서가 상위에 잘 배치되었는가",
    "why": "검색 품질의 정교함을 나타내는 지표 중 하나입니다.",
    "hint": "Context Precision"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5074",
    "question": "에이전트가 어떤 도구를 썼는지 사용자에게 보여주지 않는 'Private Agent'를 만드는 법은?",
    "options": [
      "그냥 숨기기",
      "중간 과정(Intermediate Steps)을 사용자 응답 메시지에서 제외하도록 구현하기",
      "아무것도 안 하기",
      "파일 지우기",
      "비밀번호 걸기"
    ],
    "answer": "중간 과정(Intermediate Steps)을 사용자 응답 메시지에서 제외하도록 구현하기",
    "why": "사용자에게는 결과만 깔끔하게 보여주기 위한 UX 설계입니다.",
    "hint": "Private Agent"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5075",
    "question": "벡터 DB 인덱싱 중 '브루트 포스(Brute-force)' 방식의 특징은?",
    "options": [
      "가장 빠르다.",
      "모든 벡터와 하나하나 대조하므로 매우 정확하지만 데이터가 많으면 심각하게 느리다.",
      "아무도 안 쓴다.",
      "가장 싸다.",
      "예쁘다."
    ],
    "answer": "모든 벡터와 하나하나 대조하므로 매우 정확하지만 데이터가 많으면 심각하게 느리다.",
    "why": "데이터 양이 적을 때나 정확도 100%가 필요할 때만 제한적으로 쓰입니다.",
    "hint": "Brute-force"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5076",
    "question": "에이전팅 시스템의 발열이나 리소스 낭비를 막기 위해 필요한 것은?",
    "options": [
      "에어컨",
      "에이전트의 실행 시간을 제한하는 타임아웃(Timeout) 설정",
      "컴퓨터 끄기",
      "찬물 끼얹기",
      "질문 무시"
    ],
    "answer": "에이전트의 실행 시간을 제한하는 타임아웃(Timeout) 설정",
    "why": "응답 지연이 너무 길어지면 자원을 반납하게 하여 시스템 안정성을 지킵니다.",
    "hint": "Timeout"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5077",
    "question": "RAG에서 'Multimodal Retrieval'의 특징은?",
    "options": [
      "글자만 찾기",
      "이미지, 오디오 등 텍스트 이외의 데이터도 벡터로 검색하기",
      "여러 번 찾기",
      "한 명만 찾기",
      "거짓말 찾기"
    ],
    "answer": "이미지, 오디오 등 텍스트 이외의 데이터도 벡터로 검색하기",
    "why": "다양한 매체의 정보를 의미 기반으로 통합 검색하는 고난도 기술입니다.",
    "hint": "Multimodal RAG"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5078",
    "question": "에이전트가 답변을 낼 때 '저는 AI라서 몰라요'라고만 한다면?",
    "options": [
      "AI가 맞다.",
      "프롬프트의 페르소나와 작업 수행 의지를 보강하고 제약 사항을 완화한다.",
      "AI를 그만 쓴다.",
      "질문을 지운다.",
      "다른 사람에게 물어본다."
    ],
    "answer": "프롬프트의 페르소나와 작업 수행 의지를 보강하고 제약 사항을 완화한다.",
    "why": "모델의 방어적인 태도를 능동적인 문제 해결 모드로 전환시켜야 합니다.",
    "hint": "능동성 주입"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5079",
    "question": "벡터 DB의 데이터를 주기적으로 동기화해야 하는 이유는?",
    "options": [
      "용량을 채우려고",
      "원본 지식 베이스의 변경 사항이 RAG 시스템에 최신 상태로 반영되어야 하므로",
      "인터넷 속도 때문에",
      "컴퓨터가 심심해서",
      "비용을 내려고"
    ],
    "answer": "원본 지식 베이스의 변경 사항이 RAG 시스템에 최신 상태로 반영되어야 하므로",
    "why": "정보가 죽은 정보가 되지 않도록 지속적으로 신선함을 유지하는 파이프라인이 필수입니다.",
    "hint": "데이터 동기화"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5080",
    "question": "성공적인 RAG/에이전트 개발자가 되기 위한 마음가짐은?",
    "options": [
      "한 번에 완벽할 수 있다.",
      "데이터, 임베딩, 검색, 생성을 끊임없이 실험하고 측정하며 다듬어야 한다.",
      "남의 코드를 복사만 한다.",
      "운에 맡긴다.",
      "컴퓨터를 비싼 걸 산다."
    ],
    "answer": "데이터, 임베딩, 검색, 생성을 끊임없이 실험하고 측정하며 다듬어야 한다.",
    "why": "모든 단계가 유기적으로 얽혀 있으므로 전 과정을 세심하게 튜닝하는 끈기가 핵심입니다.",
    "hint": "엔지니어의 태도"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5081",
    "question": "RAG 시스템에서 '질문(Query)'을 임베딩할 때와 '문서(Document)'를 임베딩할 때의 모델은?",
    "options": [
      "서로 다른 회사 제품이어야 한다.",
      "반드시 동일한 임베딩 모델과 동일한 벡터 차원을 사용해야 한다.",
      "모델을 안 써도 된다.",
      "아무거나 써도 된다.",
      "영문 모델만 써야 한다."
    ],
    "answer": "반드시 동일한 임베딩 모델과 동일한 벡터 차원을 사용해야 한다.",
    "why": "같은 의미 공간(Vector Space) 상에 있어야 유사도 비교가 가능합니다.",
    "hint": "동일 모델 사용"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5082",
    "question": "에이전트가 도구의 '파라미터' 형식을 자꾸 틀린다면?",
    "options": [
      "모델을 비난한다.",
      "도구 정의 시 Pydantic 등을 사용해 데이터 형식을 명확히 정의하고 프롬프트로 가이드한다.",
      "타이핑을 대신 해준다.",
      "형식을 없앤다.",
      "인터넷을 바꾼다."
    ],
    "answer": "도구 정의 시 Pydantic 등을 사용해 데이터 형식을 명확히 정의하고 프롬프트로 가이드한다.",
    "why": "모델이 어떤 데이터 타입을 넣어야 하는지 엄격하게 인지시키는 것이 에이전트의 안정성입니다.",
    "hint": "파라미터 가이드"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5083",
    "question": "RAG 파이프라인 성능을 시각적으로 모니터링해주는 랭체인 서비스는?",
    "options": [
      "LangSmith",
      "LangPaint",
      "LangExcel",
      "LangWorld",
      "LangView"
    ],
    "answer": "LangSmith",
    "why": "복잡한 체인의 단계별 입출력을 트래킹하여 디버깅을 돕는 필수 서비스입니다.",
    "hint": "LangSmith"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5084",
    "question": "검색된 문서의 '날짜'가 틀리다면 어떤 정보를 업데이트해야 하나?",
    "options": [
      "모델 이름",
      "벡터 데이터베이스 내 조각들의 메타데이터(Metadata)",
      "내 나이",
      "모니터 시계",
      "키보드 한영키"
    ],
    "answer": "벡터 데이터베이스 내 조각들의 메타데이터(Metadata)",
    "why": "메타데이터는 가공된 데이터의 상세 속성을 담고 있어 정확한 필터링과 출처 표시를 돕습니다.",
    "hint": "메타데이터 수정"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5085",
    "question": "에이전트가 도구 사용 도중 '에러 메시지'를 받으면 어떻게 대처하나?",
    "options": [
      "즉시 중단한다.",
      "루프 체계에 따라 에러 메시지를 다시 '관찰'값으로 받아 스스로 수정을 시도하게 설계한다.",
      "사용자에게 욕한다.",
      "컴퓨터를 끈다.",
      "무시한다."
    ],
    "answer": "루프 체계에 따라 에러 메시지를 다시 '관찰'값으로 받아 스스로 수정을 시도하게 설계한다.",
    "why": "에러 자가 수정은 고도로 능동적인 에이전트의 특징입니다.",
    "hint": "에러 자가 수정"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5086",
    "question": "RAG에서 'Context Relevance'가 0점이라면?",
    "options": [
      "답변이 짧다.",
      "검색된 문서가 원래 질문과 아무런 상관이 없는 쓰레기 정보였다는 뜻이다.",
      "만점이다.",
      "컴퓨터가 꺼졌다.",
      "파일이 많다."
    ],
    "answer": "검색된 문서가 원래 질문과 아무런 상관이 없는 쓰레기 정보였다는 뜻이다.",
    "why": "검색 알고리즘이나 임베딩 모델의 품질을 원점에서 재검토해야 함을 시사합니다.",
    "hint": "Context Relevance 중요성"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5087",
    "question": "에이전트의 '최종 답변'에 도달했음을 알려주는 지시자는?",
    "options": [
      "Stop",
      "Final Answer:",
      "The End",
      "Bye",
      "Logout"
    ],
    "answer": "Final Answer:",
    "why": "이 접두어(Prefix) 뒤의 텍스트가 사용자에게 전달될 최종 결과임을 모델에게 인지시킵니다.",
    "hint": "Final Answer"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5088",
    "question": "RAG에서 'Hybrid Search' 도입 시 조절하는 알파(Alpha) 값의 의미는?",
    "options": [
      "모델의 지능",
      "벡터 검색(의미)과 키워드 검색(정확)의 비중을 가중하여 합계 점수를 내는 비율",
      "인터넷 속도",
      "비용 할인율",
      "글자 크기"
    ],
    "answer": "벡터 검색(의미)과 키워드 검색(정확)의 비중을 가중하여 합계 점수를 내는 비율",
    "why": "0.5는 반반, 1.0은 오직 벡터 검색만 하는 등 밸런스를 맞추는 값입니다.",
    "hint": "Alpha 값"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5089",
    "question": "에이전트 시스템에서 '라우팅(Routing)'이란?",
    "options": [
      "네트워크 선 연결하기",
      "사용자의 의도에 따라 어떤 에이전트나 어떤 파이프라인으로 보낼지 정하는 교통정리",
      "길 찾기",
      "비행기 타기",
      "가장 빠른 길 검색"
    ],
    "answer": "사용자의 의도에 따라 어떤 에이전트나 어떤 파이프라인으로 보낼지 정하는 교통정리",
    "why": "효율적인 자원 배분과 요구사항 해결을 위한 분기 로직입니다.",
    "hint": "Routing"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5090",
    "question": "RAG 시스템 운영 시 '토큰 절약'을 위해 문장의 중요 실질어만 남기는 처리는?",
    "options": [
      "Text Deletion",
      "Stopword Removal (불용어 제거)",
      "Copy & Paste",
      "Bold Text",
      "Underline"
    ],
    "answer": "Stopword Removal (불용어 제거)",
    "why": "은, 는, 이, 가 같은 불필요한 단어를 걷어내어 토큰 효율을 높이는 기교입니다.",
    "hint": "불용어 제거"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5091",
    "question": "에이전트 도구로 '웹 검색'을 추가했을 때의 이점은?",
    "options": [
      "전기가 아껴진다.",
      "모델 학습 데이터 이후의 최신 정보를 실시간으로 탐색할 수 있다.",
      "AI가 사람처럼 변한다.",
      "돈을 더 많이 번다.",
      "재미있다."
    ],
    "answer": "모델 학습 데이터 이후의 최신 정보를 실시간으로 탐색할 수 있다.",
    "why": "RAG와 결합된 웹 서칭은 에이전트의 지식 한계를 무한히 확장합니다.",
    "hint": "웹 검색 도구"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5092",
    "question": "임베딩 모델의 '차원'이 1536이라면 벡터는 어떤 모양인가?",
    "options": [
      "1536개의 숫자가 담긴 리스트 주머니",
      "1536개의 단어",
      "1536미터 길이의 줄",
      "1536개의 그림",
      "1536층 건물"
    ],
    "answer": "1536개의 숫자가 담긴 리스트 주머니",
    "why": "고차원 공간상의 한 지점을 가리키는 1536개의 수치 좌표입니다.",
    "hint": "차원 모양"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5093",
    "question": "RAG 파이프라인 중 'Document Preprocessing' 단계에서 하는 것은?",
    "options": [
      "데이터 지우기",
      "HTML 태그 제거, 노이즈 텍스트 필터링, 정규화 등 데이터 정제",
      "이름 바꾸기",
      "폴더 이동하기",
      "파일 압축하기"
    ],
    "answer": "HTML 태그 제거, 노이즈 텍스트 필터링, 정규화 등 데이터 정제",
    "why": "깨끗한 데이터가 들어가야 벡터 값도 명확하고 답변도 깔끔하게 나옵니다.",
    "hint": "전처리"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5094",
    "question": "에이전트가 '생각(Thought)' 단계에서 자신의 한계를 인지하면?",
    "options": [
      "포기한다.",
      "사용자에게 추가 정보를 요청하거나 작업 불가 상황임을 보고한다.",
      "허풍을 친다.",
      "울음을 터트린다.",
      "로그아웃한다."
    ],
    "answer": "사용자에게 추가 정보를 요청하거나 작업 불가 상황임을 보고한다.",
    "why": "자신의 능력 범위를 알고 정직하게 소통하는 것 또한 훌륭한 에이전트의 기능입니다.",
    "hint": "한계 인지"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5095",
    "question": "RAG 시스템 성능이 '임의의 질문'에 대해 들쭉날쭉하다면?",
    "options": [
      "운이 없다.",
      "다양한 시나리오가 담긴 벤치마킹 데이터셋으로 전수 검사를 수행해 병목을 찾는다.",
      "컴퓨터를 바꾼다.",
      "질문을 줄인다.",
      "모델 가격을 낮춘다."
    ],
    "answer": "다양한 시나리오가 담긴 벤치마킹 데이터셋으로 전수 검사를 수행해 병목을 찾는다.",
    "why": "일관성 있는 품질을 위해 체계적인 테스트와 튜닝이 뒷받침되어야 합니다.",
    "hint": "품질 안정화"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5096",
    "question": "에이전트의 '자율 행동' 도중 비용이 폭주하지 않게 하려면?",
    "options": [
      "돈을 안 낸다.",
      "입출력 토큰 제한과 중간 단계 실행 횟수의 엄격한 한도(Budget)를 둔다.",
      "서버를 부순다.",
      "질문을 무시한다.",
      "천천히 타이핑한다."
    ],
    "answer": "입출력 토큰 제한하고 중간 단계 실행 횟수의 엄격한 한도(Budget)를 둔다.",
    "why": "운영 안정성과 경제성을 위해 반드시 적용해야 할 관리 장치입니다.",
    "hint": "비용 관리"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5097",
    "question": "RAG에서 'Small-to-Big Retrieval'이란?",
    "options": [
      "작은 AI가 찾고 큰 AI가 답하기",
      "검색은 작은 조각(Sentence)으로 하고, 답은 그 주변 문맥(Paragraph)까지 포함해 하기",
      "파일 크기를 키우기",
      "데이터를 늘리기",
      "비용을 비싸게 하기"
    ],
    "answer": "검색은 작은 조각(Sentence)으로 하고, 답은 그 주변 문맥(Paragraph)까지 포함해 하기",
    "why": "검색 적중률과 문맥 전달력이라는 두 마리 토끼를 다 잡는 기법입니다.",
    "hint": "Small-to-Big"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5098",
    "question": "에이전트 도구가 '파일 생성' 기능을 가졌을 때의 보안 관리법은?",
    "options": [
      "마음대로 쓰게 둔다.",
      "시스템 전용 샌드박스(Sandbox) 환경에서만 작동하게 격리하여 보안을 지킨다.",
      "파일을 못 만들게 한다.",
      "사용자 비번을 준다.",
      "파일 이름을 공란으로 한다."
    ],
    "answer": "시스템 전용 샌드박스(Sandbox) 환경에서만 작동하게 격리하여 보안을 지킨다.",
    "why": "외부 시스템에 영향을 주지 않도록 안전한 테두리 안에서 돌려야 합니다.",
    "hint": "도구 보안"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5099",
    "question": "RAG 시스템 구축 후 '만족도 설문' 결과가 나쁘다면?",
    "options": [
      "사용자를 차단한다.",
      "사용자 피드백을 Context에 넣어 수동으로 튜닝하거나 검색 상위 노출 순서를 보정한다.",
      "서비스를 종료한다.",
      "모델을 욕한다.",
      "가격표를 올린다."
    ],
    "answer": "사용자 피드백을 Context에 넣어 수동으로 튜닝하거나 검색 상위 노출 순서를 보정한다.",
    "why": "서비스는 항상 사용자의 실질적인 만족을 향해 피드백 루프를 돌아야 합니다.",
    "hint": "피드백 반영"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "객관식",
    "difficulty": "medium",
    "id": "5100",
    "question": "에이전트와 RAG 기술의 공통된 최종 목표는?",
    "options": [
      "AI를 인간보다 똑똑하게 만들기",
      "LLM을 실제 비즈니스 도메인에 연결하여 실질적이고 정확한 가치를 창출하는 것",
      "인터넷 속도 경쟁",
      "전력 소비 늘리기",
      "글자 많이 쓰기"
    ],
    "answer": "LLM을 실제 비즈니스 도메인에 연결하여 실질적이고 정확한 가치를 창출하는 것",
    "why": "인간의 지적 활동을 돕고 자동화하는 현실적인 솔루션으로서의 가치입니다.",
    "hint": "최종 목표"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "5101",
    "question": "검색 증강 개념을 완성하세요.\n```text\n____: 검색 결합 생성 기술. (이 부분을 채우세요)\n```",
    "answer": "RAG",
    "why": "Retrieval-Augmented Generation",
    "hint": "검색 증강"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "5102",
    "question": "지능형 주체 개념을 완성하세요.\n```text\n____: 스스로 판단하고 도구를 쓰는 AI. (이 부분을 채우세요)\n```",
    "answer": "Agent",
    "why": "자율적으로 비서를 수행하는 주체입니다.",
    "hint": "지능형 주체"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "5103",
    "question": "문서 쪼개기 개념을 완성하세요.\n```text\n____ing: 수천 페이지 문서를 조각냄. (이 부분을 채우세요)\n```",
    "answer": "Chunk",
    "why": "청킹이라고 부르는 과정입니다.",
    "hint": "문서 쪼개기"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "5104",
    "question": "수치화 모델 개념을 완성하세요.\n```text\n____ing Model: 텍스트를 벡터로 변환. (이 부분을 채우세요)\n```",
    "answer": "Embedd",
    "why": "임베딩 모델을 의미합니다.",
    "hint": "수치화 모델"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "5105",
    "question": "전용 저장소 개념을 완성하세요.\n```text\n____ Database: 고차원 벡터 전용 DB. (이 부분을 채우세요)\n```",
    "answer": "Vector",
    "why": "유사도 검색에 특화된 DB입니다.",
    "hint": "전용 저장소"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "5106",
    "question": "유사도 측정 개념을 완성하세요.\n```text\n____ Similarity: 각도 기반 유사도. (이 부분을 채우세요)\n```",
    "answer": "Cosine",
    "why": "코사인 유사도입니다.",
    "hint": "유사도 측정"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "5107",
    "question": "보강 단계 개념을 완성하세요.\n```text\nContext ____: 검색 내용을 질문에 합침. (이 부분을 채우세요)\n```",
    "answer": "Augmentation",
    "why": "증강 또는 보강 단계입니다.",
    "hint": "보강 단계"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "5108",
    "question": "추론 패턴 개념을 완성하세요.\n```text\n____ (Reasoning + Acting): 에이전틱 사고법. (이 부분을 채우세요)\n```",
    "answer": "ReAct",
    "why": "사고와 행동의 결합 패턴입니다.",
    "hint": "추론 패턴"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "5109",
    "question": "에이전트 도구 개념을 완성하세요.\n```text\n____: 계산기, 검색 등 함수 꾸러미. (이 부분을 채우세요)\n```",
    "answer": "Tools",
    "why": "에이전트가 활용하는 기능들입니다.",
    "hint": "에이전트 도구"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "5110",
    "question": "프레임워크 개념을 완성하세요.\n```text\n____Chain: AI 앱 빌딩 라이브러리. (이 부분을 채우세요)\n```",
    "answer": "Lang",
    "why": "가장 대표적인 프레임워크인 랭체인입니다.",
    "hint": "프레임워크"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "5111",
    "question": "문서 불러오기 개념을 완성하세요.\n```text\nPyPDF____: PDF 읽기 클래스. (이 부분을 채우세요)\n```",
    "answer": "Loader",
    "why": "로더(Loader)를 뜻합니다.",
    "hint": "문서 불러오기"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "5112",
    "question": "유사도 검색어 개념을 완성하세요.\n```text\ndb._____search(query): 유사도 검색 함수. (이 부분을 채우세요)\n```",
    "answer": "similarity",
    "why": "정확한 함수명은 similarity_search입니다.",
    "hint": "유사도 검색어"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "5113",
    "question": "문법 체계 개념을 완성하세요.\n```text\n____ (LangChain Expression Language): 문법. (이 부분을 채우세요)\n```",
    "answer": "LCEL",
    "why": "랭체인 표현 언어의 약자입니다.",
    "hint": "문법 체계"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "5114",
    "question": "평가 도구 개념을 완성하세요.\n```text\n____: RAG 성능 점수 측정 라이브러리. (이 부분을 채우세요)\n```",
    "answer": "Ragas",
    "why": "평가 라이브러리 이름입니다.",
    "hint": "평가 도구"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "5115",
    "question": "환각 지표 개념을 완성하세요.\n```text\n____ness: 근거 충실도 지표. (이 부분을 채우세요)\n```",
    "answer": "Faithful",
    "why": "정확하게는 Faithfulness입니다.",
    "hint": "환각 지표"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "5116",
    "question": "조각간 중첩 개념을 완성하세요.\n```text\nChunk ____: 문맥 보존을 위해 겹침. (이 부분을 채우세요)\n```",
    "answer": "Overlap",
    "why": "청크 오버랩 기술입니다.",
    "hint": "조각간 중첩"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "5117",
    "question": "고속 인덱스 개념을 완성하세요.\n```text\n____ (Hierarchical Navigable Small World). (이 부분을 채우세요)\n```",
    "answer": "HNSW",
    "why": "벡터 검색 가속용 인덱스 알고리즘입니다.",
    "hint": "고속 인덱스"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "5118",
    "question": "순위 재조정 개념을 완성하세요.\n```text\nRe-____ing: 검색 후 정확도 순위 조절. (이 부분을 채우세요)\n```",
    "answer": "rank",
    "why": "리랭킹 기법입니다.",
    "hint": "순위 재조정"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "5119",
    "question": "에이전트 메모리 개념을 완성하세요.\n```text\n____BufferMemory: 대화 내역 저장소. (이 부분을 채우세요)\n```",
    "answer": "Conversation",
    "why": "대화 요지를 기억하는 메모리입니다.",
    "hint": "에이전트 메모리"
  },
  {
    "chapter_name": "RAG & Agent",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "5120",
    "question": "지능형 경로 개념을 완성하세요.\n```text\n____ing Agent: 질문 주제별 분리 주체. (이 부분을 채우세요)\n```",
    "answer": "Rout",
    "why": "라우팅(Routing)을 수행하는 에이전트입니다.",
    "hint": "지능형 경로"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6001",
    "question": "LLM 서비스를 구축할 때 가장 먼저 고려해야 할 아키텍처 구성 요소는?",
    "options": [
      "사무실의 조명 밝기",
      "프런트엔드, 백엔드 서버, 그리고 LLM API/모델 엔진의 연결 구조",
      "모니터의 브랜드",
      "의자의 높낮이",
      "키보드의 축 종류"
    ],
    "answer": "프런트엔드, 백엔드 서버, 그리고 LLM API/모델 엔진의 연결 구조",
    "why": "사용자의 입력을 받고 AI의 응답을 전달하는 전체적인 시스템 설계가 핵심입니다.",
    "hint": "서비스 아키텍처"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6002",
    "question": "사용자가 웹 브라우저를 통해 채팅 인터페이스를 보고 메시지를 입력하는 영역은?",
    "options": [
      "백엔드 (Backend)",
      "프런트엔드 (Frontend)",
      "데이터베이스 (Database)",
      "GPU 서버",
      "네트워크 라우터"
    ],
    "answer": "프런트엔드 (Frontend)",
    "why": "React, Vue, Next.js 등을 사용하여 사용자 경험(UX)을 구현하는 영역입니다.",
    "hint": "프런트엔드"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6003",
    "question": "LLM 서비스에서 실시간으로 글자가 하나씩 생성되는 느낌을 주기 위해 사용하는 기술은?",
    "options": [
      "이미지 캡처",
      "스트리밍 (Streaming / Server-Sent Events)",
      "파일 다운로드",
      "전체 화면 캡처",
      "단순 페이지 새로고침"
    ],
    "answer": "스트리밍 (Streaming / Server-Sent Events)",
    "why": "사용자가 답변이 완료될 때까지 기다리지 않고 생성 과정을 즉시 볼 수 있게 합니다.",
    "hint": "스트리밍"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6004",
    "question": "프런트엔드에서 사용자의 이전 대화 내역을 유지하여 보여주는 기능의 명칭은?",
    "options": [
      "Chat History",
      "File Explorer",
      "Task Manager",
      "Disk Utility",
      "Control Panel"
    ],
    "answer": "Chat History",
    "why": "과거의 대화를 리스트 형태로 관리하여 사용자가 맥락을 파악하도록 돕습니다.",
    "hint": "채팅 히스토리"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6005",
    "question": "사용자가 입력한 메시지를 백엔드로 전달할 때 주로 사용하는 HTTP 메서드는?",
    "options": [
      "GET",
      "POST",
      "DELETE",
      "HEAD",
      "OPTIONS"
    ],
    "answer": "POST",
    "why": "메시지 본문(Payload)에 데이터를 담아 서버로 안전하게 전송하기 위해 쓰입니다.",
    "hint": "POST 메서드"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6006",
    "question": "웹 서비스 구축 시 화면의 레이아웃과 디자인을 담당하는 언어는?",
    "options": [
      "Python",
      "SQL",
      "CSS",
      "C++",
      "Java"
    ],
    "answer": "CSS",
    "why": "채팅창의 너비, 배경색, 글꼴 스타일 등을 정의하여 시각적인 완성도를 높입니다.",
    "hint": "CSS"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6007",
    "question": "반응형 웹 디자인(Responsive Web Design)이 LLM 서비스에서 중요한 이유는?",
    "options": [
      "코드가 예뻐서",
      "PC뿐만 아니라 모바일 환경에서도 최적화된 채팅 UI를 제공하기 위해",
      "속도가 빨라져서",
      "비용이 저렴해서",
      "보안이 강화되어서"
    ],
    "answer": "PC뿐만 아니라 모바일 환경에서도 최적화된 채팅 UI를 제공하기 위해",
    "why": "다양한 기기에서 인공지능과 원활하게 대화할 수 있는 접근성을 확보합니다.",
    "hint": "반응형 디자인"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6008",
    "question": "프런트엔드 프레임워크 중 'Next.js'를 LLM 앱 개발에 자주 사용하는 주된 장점은?",
    "options": [
      "게임 개발에 특화됨",
      "서버 사이드 렌더링(SSR)과 API Routes를 통해 풀스택 개발이 용이함",
      "운영체제를 직접 만듦",
      "포토샵 기능 내장",
      "엑셀과 완벽 호환"
    ],
    "answer": "서버 사이드 렌더링(SSR)과 API Routes를 통해 풀스택 개발이 용이함",
    "why": "백엔드 로직과 프런트엔드 UI를 하나의 프로젝트에서 효율적으로 관리할 수 있습니다.",
    "hint": "Next.js 장점"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6009",
    "question": "채팅창에서 AI 답변이 생성 중임을 알리는 '로딩 애니메이션'의 UX적 효과는?",
    "options": [
      "배터리 절약",
      "사용자에게 시스템이 정상적으로 응답 중임을 알려 불안감을 해소함",
      "인터넷 속도 향상",
      "자동 오타 교정",
      "화면 보호"
    ],
    "answer": "사용자에게 시스템이 정상적으로 응답 중임을 알려 불안감을 해소함",
    "why": "생성 시간이 다소 소요되는 LLM의 특성상 사용자 대기 경험을 관리하는 것이 중요합니다.",
    "hint": "로딩 UI"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6010",
    "question": "마크다운(Markdown) 렌더링 기능이 LLM 프런트엔드에 필수적인 이유는?",
    "options": [
      "파일 용량을 줄이기 위해",
      "코드 블록, 표, 굵은 글씨 등 AI의 응답을 가독성 있게 표현하기 위해",
      "광고를 띄우기 위해",
      "한글을 영어로 바꾸기 위해",
      "로그인을 대신 하기 위해"
    ],
    "answer": "코드 블록, 표, 굵은 글씨 등 AI의 응답을 가독성 있게 표현하기 위해",
    "why": "AI가 생성한 다양한 형식의 정보를 사용자가 읽기 편한 구조로 보여줍니다.",
    "hint": "마크다운"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6011",
    "question": "사용자의 요청을 받아 LLM 모델에 전달하고 결과를 가공하여 응답하는 서버 영역은?",
    "options": [
      "프런트엔드",
      "백엔드 (Backend / API Server)",
      "모니터",
      "마우스",
      "프린터"
    ],
    "answer": "백엔드 (Backend / API Server)",
    "why": "비즈니스 로직 처리, 보안 인증, 외부 API 연동 등을 담당하는 핵심 두뇌입니다.",
    "hint": "백엔드"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6012",
    "question": "파이썬 기반의 빠르고 현대적인 웹 프레임워크로, LLM API 서버 구축에 많이 쓰이는 것은?",
    "options": [
      "Flask",
      "Django",
      "FastAPI",
      "PHP",
      "JSP"
    ],
    "answer": "FastAPI",
    "why": "비동기(Async) 처리가 강력하고 자동 API 문서 생성(Swagger) 기능을 제공하여 효율적입니다.",
    "hint": "FastAPI"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6013",
    "question": "API 서버 내부에서 LLM 서비스를 제공하는 회사(OpenAI, Anthropic 등)와 통신할 때 필요한 인증 수단은?",
    "options": [
      "ID/비밀번호",
      "API Key (인증 키)",
      "집 주소",
      "전화번호",
      "주민등록번호"
    ],
    "answer": "API Key (인증 키)",
    "why": "인가된 사용자만 모델 사용량을 소모할 수 있도록 관리하는 보안 장치입니다.",
    "hint": "API Key"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6014",
    "question": "백엔드 서버에서 여러 사용자의 요청을 동시에 효율적으로 처리하기 위해 사용하는 프로그래밍 방식은?",
    "options": [
      "순차 실행",
      "비동기 프로그래밍 (Asynchronous Programming)",
      "전원 끄기",
      "한 명씩 기다리게 하기",
      "데이터 삭제"
    ],
    "answer": "비동기 프로그래밍 (Asynchronous Programming)",
    "why": "하나의 요청이 처리되는 동안(예: AI 응답 대기) 다른 요청을 처리하여 효율을 극대화합니다.",
    "hint": "비동기"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6015",
    "question": "백엔드 서버에서 민감한 API Key를 코드에 직접 노출하지 않고 관리하는 방법은?",
    "options": [
      "코드에 주석으로 남기기",
      "환경 변수(Environment Variables) 파일(.env) 사용",
      "바탕화면에 메모장으로 저장",
      "카카오톡 나에게 보내기",
      "카페 게시판에 올리기"
    ],
    "answer": "환경 변수(Environment Variables) 파일(.env) 사용",
    "why": "보안 유출을 방지하기 위해 설정값과 실행 코드를 분리하는 모범 사례입니다.",
    "hint": "환경 변수"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6016",
    "question": "API 서버가 클라이언트에게 데이터를 줄 때 가장 흔히 사용하는 가벼운 데이터 형식은?",
    "options": [
      "XML",
      "JSON",
      "CSV",
      "TXT",
      "XLSX"
    ],
    "answer": "JSON",
    "why": "키-값 쌍으로 이루어져 프로그래밍 언어 간 데이터 교환에 최적화되어 있습니다.",
    "hint": "JSON"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6017",
    "question": "백엔드 서버에서 답변 생성 전, 사용자의 질문이 부적절한지 검사하는 과정을 무엇이라 하나?",
    "options": [
      "Preprocessing / Content Filtering",
      "Postprocessing",
      "Hardening",
      "Formatting",
      "Deleting"
    ],
    "answer": "Preprocessing / Content Filtering",
    "why": "유해한 콘텐츠 생성을 방지하고 서비스 가이드라인을 준수하기 위한 안전 단계입니다.",
    "hint": "필터링"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6018",
    "question": "데이터베이스(DB)를 백엔드에 연동하는 주된 이유 중 '대화 영속성'이란?",
    "options": [
      "속도를 높이는 것",
      "대화가 종료되어도 나중에 이전 내역을 다시 불러올 수 있게 저장하는 것",
      "글자 수를 늘리는 것",
      "영어로 대화하는 것",
      "비용을 결제하는 것"
    ],
    "answer": "대화가 종료되어도 나중에 이전 내역을 다시 불러올 수 있게 저장하는 것",
    "why": "사용자가 다시 접속했을 때 과거의 맥락을 이어서 대화할 수 있도록 합니다.",
    "hint": "영속성"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6019",
    "question": "API 문서 자동 생성 도구인 'Swagger'를 통해 얻을 수 있는 이점은?",
    "options": [
      "코딩을 대신 해줌",
      "프런트엔드 개발자가 서버 API의 사양을 쉽게 파악하고 테스트할 수 있음",
      "인터넷이 빨라짐",
      "CPU 온도가 내려감",
      "전기세가 절약됨"
    ],
    "answer": "프런트엔드 개발자가 서버 API의 사양을 쉽게 파악하고 테스트할 수 있음",
    "why": "협업 효율성을 높이고 API 호출 시 에러를 줄여주는 강력한 도구입니다.",
    "hint": "Swagger"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6020",
    "question": "백엔드에서 LLM 응답을 받은 후, 특정 형식에 맞춰 텍스트를 정돈하는 과정을 무엇이라 하나?",
    "options": [
      "Ingestion",
      "Post-processing (후처리)",
      "Encoding",
      "Scaling",
      "Training"
    ],
    "answer": "Post-processing (후처리)",
    "why": "불필요한 공백 제거, 특수 문자 정제, 특정 포맷 변환 등을 수행합니다.",
    "hint": "후처리"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6021",
    "question": "작성한 코드를 실제 인터넷 상에서 누구나 접속 가능한 상태로 만드는 과정을 무엇이라 하나?",
    "options": [
      "Coding",
      "Deployment (배포)",
      "Debugging",
      "Designing",
      "Deleting"
    ],
    "answer": "Deployment (배포)",
    "why": "로컬 환경을 넘어 실제 서버 인프라에 서비스를 올리는 최종 단계입니다.",
    "hint": "배포의 정의"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6022",
    "question": "서버를 직접 구매하지 않고 가상의 컴퓨팅 자원을 빌려 쓰는 최신 서비스 형태는?",
    "options": [
      "Offline Store",
      "Cloud Computing (클라우드 컴퓨팅)",
      "Hard Disk",
      "USB Memory",
      "Floppy Disk"
    ],
    "answer": "Cloud Computing (클라우드 컴퓨팅)",
    "why": "AWS, Google Cloud, Azure 등 유연한 자원 확장이 가능한 인프라를 의미합니다.",
    "hint": "클라우드"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6023",
    "question": "코드와 실행 환경을 하나로 묶어 어디서나 동일하게 실행되도록 만드는 가상화 기술은?",
    "options": [
      "VMware",
      "Docker (도커)",
      "Notepad",
      "Paint",
      "Calculator"
    ],
    "answer": "Docker (도커)",
    "why": "컨테이너 기술을 통해 '내 컴퓨터에선 되는데 서버에선 안 되는' 문제를 해결합니다.",
    "hint": "도커"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6024",
    "question": "배포 시 트래픽이 몰릴 때 서버의 개수를 자동으로 늘려주는 기능을 무엇이라 하나?",
    "options": [
      "Auto-Save",
      "Auto-Scaling (오토 스케일링)",
      "Auto-Focus",
      "Auto-Complete",
      "Auto-Pilot"
    ],
    "answer": "Auto-Scaling (오토 스케일링)",
    "why": "사용자의 접속량에 따라 인프라를 유연하게 조절하여 안정적인 서비스를 유지합니다.",
    "hint": "오토 스케일링"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6025",
    "question": "서비스의 주소(URL)를 쉽게 기억할 수 있도록 연결해주는 시스템은?",
    "options": [
      "CPU",
      "DNS (Domain Name System)",
      "RAM",
      "GPU",
      "SSD"
    ],
    "answer": "DNS (Domain Name System)",
    "why": "IP 주소 대신 'example.com' 같은 문자로 서버에 접속하게 해줍니다.",
    "hint": "DNS"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6026",
    "question": "전 세계 사용자에게 콘텐츠를 빠르게 전달하기 위해 서버를 분산 배치하는 기술은?",
    "options": [
      "FTP",
      "CDN (Content Delivery Network)",
      "HTTP",
      "LAN",
      "WAN"
    ],
    "answer": "CDN (Content Delivery Network)",
    "why": "지리적으로 가까운 서버에서 데이터를 전송하여 응답 속도를 개선합니다.",
    "hint": "CDN"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6027",
    "question": "배포 후 서비스의 상태(에러 발생 여부, CPU 점유율 등)를 실시간으로 확인하는 작업은?",
    "options": [
      "Designing",
      "Monitoring (모니터링)",
      "Planning",
      "Meeting",
      "Resting"
    ],
    "answer": "Monitoring (모니터링)",
    "why": "장애를 미리 예방하고 성능 병목을 파악하기 위한 필수 운영 활동입니다.",
    "hint": "모니터링"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6028",
    "question": "코드 변경 사항을 자동으로 테스트하고 서버에 즉시 배포하는 자동화 파이프라인은?",
    "options": [
      "CI/CD",
      "GUI",
      "CLI",
      "IDE",
      "USB"
    ],
    "answer": "CI/CD",
    "why": "지속적 통합(CI)과 지속적 배포(CD)를 통해 개발 생산성을 획기적으로 높입니다.",
    "hint": "CI/CD"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6029",
    "question": "인터넷 상의 위협(해킹, DDoS 등)으로부터 서버를 보호하기 위해 앞단에 두는 네트워크 보안 장치는?",
    "options": [
      "Router",
      "Firewall (방화벽)",
      "Monitor",
      "Speaker",
      "Scanner"
    ],
    "answer": "Firewall (방화벽)",
    "why": "허용되지 않은 접근을 차단하여 소중한 데이터와 시스템을 지킵니다.",
    "hint": "방화벽"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6030",
    "question": "배포된 서비스에 보안 연결(HTTPS)을 적용하기 위해 필요한 인증서는?",
    "options": [
      "졸업 증명서",
      "SSL/TLS 인증서",
      "운전 면허증",
      "건강 진단서",
      "경력 증명서"
    ],
    "answer": "SSL/TLS 인증서",
    "why": "데이터 전송 구간을 암호화하여 중간에서 정보를 가로채지 못하게 보호합니다.",
    "hint": "SSL/TLS"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6031",
    "question": "API 호출 횟수를 제한하여 특정 사용자가 서버 자원을 독점하지 못하게 하는 정책은?",
    "options": [
      "Rate Limiting",
      "Open Access",
      "Free Pass",
      "Full Speed",
      "No Limit"
    ],
    "answer": "Rate Limiting",
    "why": "공정하고 안정적인 서비스 운영을 위해 필수적인 트래픽 제어 방식입니다.",
    "hint": "Rate Limiting"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6032",
    "question": "프런트엔드에서 AI의 답변 길이를 시각적으로 제한하거나 '더보기' 버튼을 만드는 UI 설계의 목적은?",
    "options": [
      "데이터 삭제",
      "답변이 너무 길어 화면을 가득 채우는 것을 막고 가독성을 유지하기 위해",
      "비용 청구",
      "영역 숨기기",
      "오타 유도"
    ],
    "answer": "답변이 너무 길어 화면을 가득 채우는 것을 막고 가독성을 유지하기 위해",
    "why": "깔끔한 인터페이스 유지를 위한 레이아웃 관리 전략입니다.",
    "hint": "UI 가독성"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6033",
    "question": "백엔드에서 '로그(Log)'를 남기는 것이 중요한 이유는?",
    "options": [
      "코드를 길게 하려고",
      "문제가 발생했을 때 원인을 추적하고 시스템 방문 기록을 분석하기 위해",
      "종이를 아끼려고",
      "모니터를 끄려고",
      "마우스를 던지려고"
    ],
    "answer": "문제가 발생했을 때 원인을 추적하고 시스템 방문 기록을 분석하기 위해",
    "why": "운영 중 발생하는 이슈를 해결하는 가장 강력한 단서가 됩니다.",
    "hint": "Logging"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6034",
    "question": "배포 환경과 로컬 개발 환경의 설정을 분리하는 가장 좋은 방법은?",
    "options": [
      "코드를 두 번 짜기",
      "환경 변수를 활용하여 주소나 키값을 동적으로 로드하기",
      "종이에 적어두기",
      "전부 다 지우기",
      "로그인 안 하기"
    ],
    "answer": "환경 변수를 활용하여 주소나 키값을 동적으로 로드하기",
    "why": "하나의 소스 코드로 여러 환경에서 안정적으로 동작하게 만드는 설계 방식입니다.",
    "hint": "환경 분리"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6035",
    "question": "도커 컨테이너를 여러 개 관리하고 배포를 자동화해주는 '오케스트레이션' 도구는?",
    "options": [
      "Kubernetes (쿠버네티스)",
      "Notepad",
      "Excel",
      "PowerPoint",
      "Paint"
    ],
    "answer": "Kubernetes (쿠버네티스)",
    "why": "대규모 서비스의 컨테이너 운영을 자동화하는 업계 표준 도구입니다.",
    "hint": "Kubernetes"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6036",
    "question": "사용자가 채팅창에 대용량 파일을 업로드할 때 백엔드에서 고려해야 할 점은?",
    "options": [
      "파일 이름",
      "파일 크기 제한(Body Size Limit) 및 안전한 저장소(S3 등) 확보",
      "파일의 색깔",
      "키보드 속도",
      "마우스 응답성"
    ],
    "answer": "파일 크기 제한(Body Size Limit) 및 안전한 저장소(S3 등) 확보",
    "why": "서버 자원 고갈을 막고 데이터를 안정적으로 관리하기 위한 설계입니다.",
    "hint": "파일 업로드 처리"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6037",
    "question": "프런트엔드에서 '다크 모드'를 지원할 때 얻는 UX적 장점은?",
    "options": [
      "전기세 폭탄",
      "사용자의 눈 피로도를 낮추고 세련된 디자인 감성을 제공함",
      "인터넷 속도 2배",
      "AI의 지능 향상",
      "자동 번역"
    ],
    "answer": "사용자의 눈 피로도를 낮추고 세련된 디자인 감성을 제공함",
    "why": "장시간 채팅을 이용하는 사용자에게 편리한 시각적 환경을 선사합니다.",
    "hint": "다크 모드"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6038",
    "question": "백엔드 서버 배포 시 '무중단 배포'를 하는 이유는?",
    "options": [
      "전기를 아끼려고",
      "새로운 버전 업데이트 중에도 사용자가 끊김 없이 서비스를 이용하게 하려고",
      "코드가 사라질까 봐",
      "속도가 너무 빨라서",
      "심심해서"
    ],
    "answer": "새로운 버전 업데이트 중에도 사용자가 끊김 없이 서비스를 이용하게 하려고",
    "why": "업데이트로 인한 서비스 중지 시간을 없애 신뢰도를 유지합니다.",
    "hint": "무중단 배포"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6039",
    "question": "API 응답 시간을 측정할 때 사용하는 단위는?",
    "options": [
      "미터(m)",
      "밀리초 (ms)",
      "킬로그램(kg)",
      "리터(L)",
      "온도(℃)"
    ],
    "answer": "밀리초 (ms)",
    "why": "1,000분의 1초 단위로 측정하여 서비스 반응성을 정교하게 관리합니다.",
    "hint": "Latency 단위"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6040",
    "question": "배포 후 'Health Check' API를 만드는 주된 목적은?",
    "options": [
      "건강 검진 기록",
      "서버가 현재 정상적으로 살아있는지 주기적으로 확인하기 위해",
      "이름 짓기",
      "사진 찍기",
      "로그아웃"
    ],
    "answer": "서버가 현재 정상적으로 살아있는지 주기적으로 확인하기 위해",
    "why": "모니터링 시스템이나 로드 밸런서가 서버의 생존 여부를 판단하는 척도가 됩니다.",
    "hint": "Health Check"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6041",
    "question": "프런트엔드에서 '복사하기' 버튼을 구현하는 이유는?",
    "options": [
      "종이가 없어서",
      "AI의 긴 답변이나 코드를 사용자가 간편하게 복사할 수 있도록 하여 편의성을 높이기 위해",
      "인터넷을 중단하려고",
      "화면을 끄려고",
      "파일을 지우려고"
    ],
    "answer": "AI의 긴 답변이나 코드를 사용자가 간편하게 복사할 수 있도록 하여 편의성을 높이기 위해",
    "why": "생산성 향상을 위한 작은 디테일이 사용자 경험을 크게 개선합니다.",
    "hint": "복사 기능"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6042",
    "question": "백엔드에서 'CORS' 에러가 발생하는 상황은?",
    "options": [
      "키보드가 고장 났을 때",
      "서로 다른 도메인(주소) 간에 리소스를 요청할 때 보안 정책으로 차단되는 경우",
      "인터넷이 끊겼을 때",
      "컴퓨터 전원이 나갔을 때",
      "마우스를 클릭했을 때"
    ],
    "answer": "서로 다른 도메인(주소) 간에 리소스를 요청할 때 보안 정책으로 차단되는 경우",
    "why": "보안을 위해 브라우저가 타 도메인으로의 요청을 제어하는 정책입니다.",
    "hint": "CORS"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6043",
    "question": "서버 배포 시 '리전(Region)' 선택 시 가장 중요한 기준은?",
    "options": [
      "리전 이름의 알파벳 순서",
      "사용자와 가장 가까운 지리적 위치(속도 향상 및 지연 감소)",
      "날씨가 좋은 곳",
      "유명 관광지 근처",
      "내가 가고 싶은 나라"
    ],
    "answer": "사용자와 가장 가까운 지리적 위치(속도 향상 및 지연 감소)",
    "why": "한국 사용자라면 서울 리전을 선택하는 것이 가장 빠른 성능을 냅니다.",
    "hint": "리전 선택"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6044",
    "question": "백엔드에서 사용되는 '데이터베이스 인덱싱'의 효과는?",
    "options": [
      "글자 크기 키우기",
      "데이터 검색 속도를 비약적으로 높여 응답 시간을 단축함",
      "용량 늘리기",
      "파일 삭제",
      "전원 끄기"
    ],
    "answer": "데이터 검색 속도를 비약적으로 높여 응답 시간을 단축함",
    "why": "수백만 건의 대화 기록 속에서 원하는 내용을 순식간에 찾아내게 합니다.",
    "hint": "DB 인덱스"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6045",
    "question": "프런트엔드에서 'Toast 메시지'(짧게 떴다 사라지는 알림)의 용도는?",
    "options": [
      "토스트 구워 먹기",
      "작업 완료나 에러 발생을 사용자에게 방해되지 않게 살짝 알려줌",
      "컴퓨터 부팅",
      "로그인 강제",
      "광고 노출"
    ],
    "answer": "작업 완료나 에러 발생을 사용자에게 방해되지 않게 살짝 알려줌",
    "why": "현재 작업 흐름을 깨지 않으면서 정보를 전달하는 유용한 UI 요소입니다.",
    "hint": "Toast UI"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6046",
    "question": "백엔드 개발 시 '단위 테스트(Unit Test)'의 역할은?",
    "options": [
      "배터리 수명 체크",
      "개별 기능(함수)이 의도대로 정확히 동작하는지 코드로 검증하여 버그를 방지함",
      "타이핑 속도 측정",
      "모니터 색상 보정",
      "키보드 배열 변경"
    ],
    "answer": "개별 기능(함수)이 의도대로 정확히 동작하는지 코드로 검증하여 버그를 방지함",
    "why": "코드를 신뢰할 수 있게 만들고 향후 수정 시 발생하는 사이드 이펙트를 막아줍니다.",
    "hint": "Unit Test"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6047",
    "question": "배포 시 'Git'을 사용하는 근거 중 하나인 '버전 관리'란?",
    "options": [
      "컴퓨터를 새로 사는 것",
      "코드의 수정 이력을 기록하고 필요할 때 과거 상태로 되돌리는 것",
      "이름을 멋지게 짓는 것",
      "파일을 다 합치는 것",
      "인터넷 쇼핑"
    ],
    "answer": "코드의 수정 이력을 기록하고 필요할 때 과거 상태로 되돌리는 것",
    "why": "여러 개발자가 협업하고 시스템을 안정적으로 업데이트하는 기반이 됩니다.",
    "hint": "Git 버전 관리"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6048",
    "question": "프런트엔드에서 'State Management'(상태 관리)가 필요한 이유는?",
    "options": [
      "기분이 안 좋아서",
      "채팅방 내용, 로그인 정보 등 실시간으로 변하는 데이터를 일관되게 관리하기 위해",
      "컴퓨터를 끄려고",
      "키보드를 누르려고",
      "파일을 지우려고"
    ],
    "answer": "채팅방 내용, 로그인 정보 등 실시간으로 변하는 데이터를 일관되게 관리하기 위해",
    "why": "복잡한 앱의 데이터 흐름을 꼬이지 않게 잡아주는 핵심 기술입니다.",
    "hint": "상태 관리"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6049",
    "question": "클라우드 서비스 중 'Serverless'(서버리스)의 특징은?",
    "options": [
      "서버가 아예 없는 것",
      "사용자가 서버 관리를 직접 하지 않고 실행된 만큼만 비용을 지불하는 방식",
      "사무실을 없애는 것",
      "인터넷이 안 되는 것",
      "모델을 안 쓰는 것"
    ],
    "answer": "사용자가 서버 관리를 직접 하지 않고 실행된 만큼만 비용을 지불하는 방식",
    "why": "관리가 편하고 초기 비용 부담이 적어 가벼운 AI 앱 배포에 좋습니다.",
    "hint": "서버리스"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6050",
    "question": "백엔드 서버에서 '세션(Session)'과 '쿠키(Cookie)'의 역할은?",
    "options": [
      "과자 먹기",
      "사용자의 로그인 상태나 방문 정보를 유지하여 개인화된 경험을 제공함",
      "컴퓨터 부품 이름",
      "인터넷 브라우저 이름",
      "사이트 주소"
    ],
    "answer": "사용자의 로그인 상태나 방문 정보를 유지하여 개인화된 경험을 제공함",
    "why": "사용자를 식별하여 '내 대화 내역'을 안전하게 보여주는 기반이 됩니다.",
    "hint": "세션과 쿠키"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6051",
    "question": "프런트엔드에서 'Skeleton Screen'을 보여주는 의도는?",
    "options": [
      "해골 그림 그리기",
      "데이터 로딩 중 빈 화면 대신 레이아웃 윤곽을 미리 보여줘 체감 속도를 높임",
      "사이트 끄기",
      "로그아웃",
      "광고 띄우기"
    ],
    "answer": "데이터 로딩 중 빈 화면 대신 레이아웃 윤곽을 미리 보여줘 체감 속도를 높임",
    "why": "사용자가 콘텐츠가 곧 나올 것임을 인지하게 하여 시각적 만족감을 줍니다.",
    "hint": "Skeleton UI"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6052",
    "question": "API 서버의 'Versioning'(버전 관리)은 왜 하나?",
    "options": [
      "숫자 공부하려고",
      "기존 사용자 기능을 유지하면서 새로운 기능을 안전하게 추가하고 업데이트하기 위해",
      "이름이 없어서",
      "순서를 정하려고",
      "비용을 늘리려고"
    ],
    "answer": "기존 사용자 기능을 유지하면서 새로운 기능을 안전하게 추가하고 업데이트하기 위해",
    "why": "예: /v1/chat과 /v2/chat을 구분하여 하위 호환성을 지키는 전문적인 개발 방식입니다.",
    "hint": "API 버전"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6053",
    "question": "클라우드 인프라에서 'VPC'(가상 사설 클라우드)의 역할은?",
    "options": [
      "가상 게임 공간",
      "사설 네트워크를 구축하여 독립적이고 안전한 리소스 환경을 제공함",
      "인터넷 카페",
      "파일 공유 폴더",
      "컴퓨터 부품"
    ],
    "answer": "사설 네트워크를 구축하여 독립적이고 안전한 리소스 환경을 제공함",
    "why": "기업의 데이터를 공용 인터넷과 격리하여 보안을 극대화하는 성벽 역할을 합니다.",
    "hint": "VPC"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6054",
    "question": "백엔드 비즈니스 로직 중 'Validation'(검증)이란?",
    "options": [
      "유통기한 확인",
      "입력 데이터가 형식에 맞는지, 위험한 코드가 섞여 있지 않은지 확인하는 절차",
      "인기 투표",
      "친구 찾기",
      "비밀번호 삭제"
    ],
    "answer": "입력 데이터가 형식에 맞는지, 위험한 코드가 섞여 있지 않은지 확인하는 절차",
    "why": "시스템 에러를 막고 악의적인 데이터 주입 공격을 원천 차단합니다.",
    "hint": "Validation"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6055",
    "question": "배포 전략 중 'Blue-Green Deployment'의 특징은?",
    "options": [
      "색깔 고르기",
      "기존 서버(Blue)와 새 서버(Green)를 동시에 띄워 교체하며 장애를 최소화함",
      "파란색 옷 입기",
      "초록색 옷 입기",
      "신호등 지키기"
    ],
    "answer": "기존 서버(Blue)와 새 서버(Green)를 동시에 띄워 교체하며 장애를 최소화함",
    "why": "리스크가 적고 실패 시 즉시 이전 버전으로 되돌릴 수 있는 안정적인 배포 기법입니다.",
    "hint": "Blue-Green"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6056",
    "question": "프런트엔드 빌드(Build) 과정에서 하는 일은?",
    "options": [
      "집 짓기",
      "소스 코드를 브라우저가 읽기 최적화된 파일로 압축하고 변환하는 과정",
      "파일 하나씩 읽기",
      "그림 그리기",
      "노래 듣기"
    ],
    "answer": "소스 코드를 브라우저가 읽기 최적화된 파일로 압축하고 변환하는 과정",
    "why": "용량을 줄이고 보안을 강화하여 실제 서비스 성능을 높이는 전처리입니다.",
    "hint": "Frontend Build"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6057",
    "question": "API 서버의 'Rate Limit Exceeded' 에러를 받았을 때 프런트엔드의 대처는?",
    "options": [
      "서버를 계속 공격함",
      "잠시 기다려달라는 메시지를 보여주고 재시도 버튼을 안내함",
      "로그아웃",
      "글자 다 지우기",
      "화면 끄기"
    ],
    "answer": "잠시 기다려달라는 메시지를 보여주고 재시도 버튼을 안내함",
    "why": "서버 정책을 사용자에게 친절하게 안내하여 서비스에 대한 긍정적 경험을 유지합니다.",
    "hint": "과부하 대응"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6058",
    "question": "데이터베이스 서버를 '분리'해서 구축하는 장점은?",
    "options": [
      "관리하기 귀찮음",
      "웹 서버와 데이터 저장 서버의 역할을 나누어 성능을 최적화하고 보안을 강화함",
      "컴퓨터 대수 줄이기",
      "전기세 절약",
      "인터넷 속도"
    ],
    "answer": "웹 서버와 데이터 저장 서버의 역할을 나누어 성능을 최적화하고 보안을 강화함",
    "why": "전문적인 인프라 구성을 통해 서비스의 안정성과 확장성을 확보합니다.",
    "hint": "DB 분리"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6059",
    "question": "배포 시 '환경 설정 파일(.yml, .json 등)'을 사용하는 이유는?",
    "options": [
      "그림 그리려고",
      "소소한 설정 변경 시 코드 수정 없이 파일만 갈아끼워 적용하기 위해",
      "글자 수 채우기",
      "멋있어 보이려고",
      "비밀번호 저장소"
    ],
    "answer": "소소한 설정 변경 시 코드 수정 없이 파일만 갈아끼워 적용하기 위해",
    "why": "유연하고 유지보수가 쉬운 환경 관리를 가능하게 합니다.",
    "hint": "Config File"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6060",
    "question": "배포된 인벤토리를 관리하는 기술 용어 'IaC'(Infrastructure as Code)란?",
    "options": [
      "인프라를 손으로 만들기",
      "서버 설정을 코드로 작성하여 자동화하고 버전 관리하는 기술",
      "컴퓨터 부품 이름",
      "비밀번호 분실",
      "인터넷 쇼핑"
    ],
    "answer": "서버 설정을 코드로 작성하여 자동화하고 버전 관리하는 기술",
    "why": "사람의 실수를 줄이고 수천 대의 서버를 일관되게 관리할 수 있는 현대적 기술입니다.",
    "hint": "IaC"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6061",
    "question": "프런트엔드에서 '클립보드 API'를 사용하는 예시는?",
    "options": [
      "AI가 생성한 코드를 버튼 하나로 복사하게 함",
      "사진 찍기",
      "인터넷 끊기",
      "로그아웃하기",
      "파일 삭제하기"
    ],
    "answer": "AI가 생성한 코드를 버튼 하나로 복사하게 함",
    "why": "사용자 편의성을 위한 실용적인 기능 구현 사례입니다.",
    "hint": "클립보드"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6062",
    "question": "백엔드 서버에서 API 성능을 개선하기 위한 'Redis'의 역할은?",
    "options": [
      "컴퓨터 수리",
      "자주 사용되는 데이터를 메모리에 임시 저장하여 초고속으로 응답(캐싱)함",
      "사진첩",
      "음악 재생",
      "동영상 편집"
    ],
    "answer": "자주 사용되는 데이터를 메모리에 임시 저장하여 초고속으로 응답(캐싱)함",
    "why": "DB 부하를 줄이고 응답 속도를 획기적으로 향상시켜 줍니다.",
    "hint": "Redis/Caching"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6063",
    "question": "배포된 웹사이트 주소 앞에 'https://'가 붙어 있다면 무엇을 뜻하나?",
    "options": [
      "속도가 2배 느림",
      "보안 인증서가 적용되어 통신 내용이 암호화되고 있음",
      "광고가 많음",
      "무료 사이트임",
      "로그인이 안 됨"
    ],
    "answer": "보안 인증서가 적용되어 통신 내용이 암호화되고 있음",
    "why": "사용자의 개인정보를 안전하게 보호하는 신뢰할 수 있는 사이트임을 의미합니다.",
    "hint": "HTTPS 의미"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6064",
    "question": "프런트엔드에서 사용자가 메시지를 보낸 직후 채팅창을 맨 아래로 내리는 이유는?",
    "options": [
      "화면을 숨기려고",
      "새로 생성된 답변을 사용자가 바로 확인할 수 있게 시야를 맞춰줌",
      "마우스를 고장 내려고",
      "글자를 지우려고",
      "로그아웃"
    ],
    "answer": "새로 생성된 답변을 사용자가 바로 확인할 수 있게 시야를 맞춰줌",
    "why": "자연스러운 대화 흐름(UX)을 유지하기 위한 필수적인 스크롤 처리입니다.",
    "hint": "Auto Scroll"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6065",
    "question": "백엔드에서 'JWT(JSON Web Token)'를 사용하는 주된 목적은?",
    "options": [
      "게임 머니",
      "사용자의 신원을 증명하고 권한을 안전하게 확인하는 인증 수단",
      "글씨체 바꾸기",
      "인터넷 가입",
      "사진 저장"
    ],
    "answer": "사용자의 신원을 증명하고 권한을 안전하게 확인하는 인증 수단",
    "why": "현대적인 웹 서비스에서 로그인 상태를 유지하는 표준적인 기술 중 하나입니다.",
    "hint": "JWT"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6066",
    "question": "배포 시 서버의 'CPU 사용률이 100%'라면 취해야 할 조치는?",
    "options": [
      "서버 수 늘리기(Scale out) 또는 성능 높이기(Scale up)",
      "컴퓨터 끄기",
      "키보드 닦기",
      "모니터 밝기 줄이기",
      "인터넷 해지"
    ],
    "answer": "서버 수 늘리기(Scale out) 또는 성능 높이기(Scale up)",
    "why": "인프라 확장을 통해 서비스 중단 없이 문제를 해결하는 올바른 대응입니다.",
    "hint": "리소스 관리"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6067",
    "question": "프런트엔드 배포 플랫폼인 'Vercel'이나 'Netlify'의 장점은?",
    "options": [
      "서버를 직접 조립해야 함",
      "Git과 연동되어 코드만 올리면 자동으로 빌드하고 인터넷에 배포해줌",
      "가격이 무조건 비쌈",
      "수동으로만 작동함",
      "오프라인 전용임"
    ],
    "answer": "Git과 연동되어 코드만 올리면 자동으로 빌드하고 인터넷에 배포해줌",
    "why": "개인 프로젝트나 프로토타입을 순식간에 서비스화할 수 있는 강력한 도구입니다.",
    "hint": "Frontend Platform"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6068",
    "question": "백엔드 서버에서 에러가 났을 때 클라이언트에게 알려주는 '500' 코드는?",
    "options": [
      "정상 작동",
      "서버 내부 오류 (Internal Server Error)",
      "찾을 수 없음",
      "전원 꺼짐",
      "로그인 성공"
    ],
    "answer": "서버 내부 오류 (Internal Server Error)",
    "why": "서버 쪽 로직에 문제가 생겼음을 알려 디버깅의 시작점을 파악하게 해줍니다.",
    "hint": "500 에러"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6069",
    "question": "배포 후 '검색 엔진 최적화(SEO)'를 하는 이유는?",
    "options": [
      "속도를 높이려고",
      "네이버나 구글 검색 시 내 서비스가 더 잘 노출되게 하기 위해",
      "글자를 숨기려고",
      "광고를 보려고",
      "컴퓨터를 끄려고"
    ],
    "answer": "네이버나 구글 검색 시 내 서비스가 더 잘 노출되게 하기 위해",
    "why": "더 많은 잠재 사용자가 서비스를 발견하게 만드는 마케팅적 기술입니다.",
    "hint": "SEO"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6070",
    "question": "프런트엔드에서 'Favicon'(파비콘)이란?",
    "options": [
      "인공지능 이름",
      "웹 브라우저 탭에 표시되는 작은 아이콘 로고",
      "배경 음악",
      "글꼴 이름",
      "사이트 하단 문구"
    ],
    "answer": "웹 브라우저 탭에 표시되는 작은 아이콘 로고",
    "why": "서비스의 아이덴티티를 시각적으로 완성해주는 작은 디테일입니다.",
    "hint": "Favicon"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6071",
    "question": "백엔드 서버 개발 시 'API Endpoint'란?",
    "options": [
      "컴퓨터 전원 종료",
      "클라이언트가 특정 기능(채팅, 로그인 등)을 호출하기 위해 접속하는 주소 경로",
      "파일의 마지막 줄",
      "키보드 끝자락",
      "사이트 하단"
    ],
    "answer": "클라이언트가 특정 기능(채팅, 로그인 등)을 호출하기 위해 접속하는 주소 경로",
    "why": "예: /api/v1/chat 과 같이 서비스가 제공하는 기능들의 주소를 의미합니다.",
    "hint": "Endpoint"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6072",
    "question": "클라우드 인프라 배포 시 'S3'(Simple Storage Service)의 용도는?",
    "options": [
      "인터넷 채팅",
      "이미지, PDF, 로그 파일 등 비정형 데이터를 안전하게 저장하는 창고",
      "글 작성",
      "코딩 도구",
      "게임 서버"
    ],
    "answer": "이미지, PDF, 로그 파일 등 비정형 데이터를 안전하게 저장하는 창고",
    "why": "용량 제한 없이 파일을 무한히 저장하고 불러올 수 있는 클라우드 저장소입니다.",
    "hint": "S3 Storage"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6073",
    "question": "프런트엔드에서 '애니메이션 효과'를 넣는 가장 큰 이유는?",
    "options": [
      "전력을 소모하려고",
      "상태 변화를 부드럽게 보여줘서 사용자에게 즐거움과 정보 전달력을 높임",
      "컴퓨터를 고장 내려고",
      "눈을 아프게 하려고",
      "로그아웃"
    ],
    "answer": "상태 변화를 부드럽게 보여줘서 사용자에게 즐거움과 정보 전달력을 높임",
    "why": "생성 AI 서비스의 생동감을 불어넣는 UX 요소입니다.",
    "hint": "애니메이션"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6074",
    "question": "백엔드 개발 시 'ORM' 라이브러리를 사용하는 이유는?",
    "options": [
      "코드를 어렵게 하려고",
      "SQL 쿼리 대신 익숙한 프로그래밍 언어로 DB를 쉽고 안전하게 다루기 위해",
      "속도를 억지로 늦추려고",
      "이름을 안 지으려고",
      "모두 다 삭제하려고"
    ],
    "answer": "SQL 쿼리 대신 익숙한 프로그래밍 언어로 DB를 쉽고 안전하게 다루기 위해",
    "why": "개발 생산성을 높이고 데이터베이스 접근 코드를 깔끔하게 관리하게 해줍니다.",
    "hint": "ORM"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6075",
    "question": "배포된 서비스의 'Uptime'(업타임)이란?",
    "options": [
      "서버가 켜진 이후 현재까지 정상적으로 가동된 시간",
      "사용자가 잠자는 시간",
      "컴퓨터 사는 시간",
      "공부하는 시간",
      "비용 결제 시간"
    ],
    "answer": "서버가 켜진 이후 현재까지 정상적으로 가동된 시간",
    "why": "서비스의 신뢰도와 안정성을 나타내는 직접적인 지표입니다.",
    "hint": "Uptime"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6076",
    "question": "프런트엔드에서 'Local Storage'에 대화 내역을 저장할 때의 특징은?",
    "options": [
      "서버에 저장됨",
      "사용자의 브라우저에 데이터가 저장되어 재방문 시에도 내용이 유지됨",
      "해킹이 불가능함",
      "용량이 무제한임",
      "영구히 삭제됨"
    ],
    "answer": "사용자의 브라우저에 데이터가 저장되어 재방문 시에도 내용이 유지됨",
    "why": "서버 DB 없이도 간단한 히스토리 기능을 구현할 수 있는 방법입니다.",
    "hint": "Local Storage"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6077",
    "question": "API 서버 구축 시 'HTTP 상태 코드 404'의 의미는?",
    "options": [
      "정상",
      "요청한 주소(리소스)를 찾을 수 없음 (Not Found)",
      "권한 없음",
      "잘못된 요청",
      "서버 과부하"
    ],
    "answer": "요청한 주소(리소스)를 찾을 수 없음 (Not Found)",
    "why": "주소를 틀렸거나 삭제된 페이지에 접속했을 때 나타나는 표준 응답입니다.",
    "hint": "404 에러"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6078",
    "question": "클라우드 배포 시 '로드 밸런서(Load Balancer)'의 역할은?",
    "options": [
      "무게 재기",
      "여러 대의 서버에 트래픽을 골고루 나누어 서버 부하를 분산함",
      "돈 계산",
      "사진 편집",
      "영화 감상"
    ],
    "answer": "여러 대의 서버에 트래픽을 골고루 나누어 서버 부하를 분산함",
    "why": "단일 서버에 가중되는 부담을 줄여 대규모 사용자를 수용하게 돕습니다.",
    "hint": "로드 밸런싱"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6079",
    "question": "백엔드에서 사용되는 '환경 변수' 중 PORT 번호를 바꾸는 목적은?",
    "options": [
      "서버가 접속을 기다릴 가상의 통로 번호를 지정하기 위해",
      "글자 수 늘리기",
      "비번 바꾸기",
      "컴퓨터 이름 바꾸기",
      "인터넷 속도"
    ],
    "answer": "서버가 접속을 기다릴 가상의 통로 번호를 지정하기 위해",
    "why": "서버가 통신할 창구를 정하는 기본 설정입니다.",
    "hint": "Port Number"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6080",
    "question": "최종적으로 서비스를 '런칭'한 후 가장 중요하게 챙겨야 할 것은?",
    "options": [
      "개발 중단 및 휴식",
      "사용자 피드백 수집과 지속적인 모니터링 및 업데이트",
      "사이트 삭제",
      "비밀번호 노출",
      "로그아웃"
    ],
    "answer": "사용자 피드백 수집과 지속적인 모니터링 및 업데이트",
    "why": "출시는 시작일 뿐, 사용자의 반응에 맞춰 진화하는 것이 진정한 서비스의 완성입니다.",
    "hint": "런칭 후 관리"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6081",
    "question": "프런트엔드 앱의 '로딩 바'가 멈춰 있다면 의심되는 원인은?",
    "options": [
      "모델이 너무 똑똑해서",
      "네트워크 에러나 백엔드 서버의 무한 루프 등 비정상 종료",
      "컴퓨터 색깔",
      "날씨",
      "마우스"
    ],
    "answer": "네트워크 에러나 백엔드 서버의 무한 루프 등 비정상 종료",
    "why": "사용자에게 시스템의 장애 상태를 인지시키는 디버깅 신호입니다.",
    "hint": "로딩 멈춤"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6082",
    "question": "배포 완료 후 '구글 분석기(Google Analytics)'를 심는 주된 이유는?",
    "options": [
      "사용자의 비번 확인",
      "얼마나 많은 사람이 들어오고 어떤 기능을 자주 쓰는지 통계를 보기 위해",
      "그림 그리기",
      "음악 듣기",
      "게임 하기"
    ],
    "answer": "얼마나 많은 사람이 들어오고 어떤 기능을 자주 쓰는지 통계를 보기 위해",
    "why": "데이터에 기반해 서비스를 개선하기 위한 분석 도구입니다.",
    "hint": "GA 심기"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6083",
    "question": "백엔드 서버 배포 시 'Secrets Management'(비밀 정보 관리)가 중요한 이유는?",
    "options": [
      "코드가 예뻐서",
      "DB 비번이나 API Key 유출로 인한 금전적/데이터 손실을 막기 위해",
      "이름 짓기",
      "사진첩",
      "글자 수"
    ],
    "answer": "DB 비번이나 API Key 유출로 인한 금전적/데이터 손실을 막기 위해",
    "why": "개발 보안의 가장 기초이자 필수적인 항목입니다.",
    "hint": "Secret 관리"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6084",
    "question": "프런트엔드에서 '모바일 브라우저' 상단 바 색깔을 지정하는 이유는?",
    "options": [
      "사이트의 브랜드 컬러를 UI와 통일시켜 사용자에게 몰입감을 주기 위해",
      "배터리 절약",
      "인터넷 속도",
      "오타 방지",
      "화면 보호"
    ],
    "answer": "사이트의 브랜드 컬러를 UI와 통일시켜 사용자에게 몰입감을 주기 위해",
    "why": "모바일 웹 UX의 완성도를 높여주는 디자인 디테일입니다.",
    "hint": "모바일 UI 테마"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6085",
    "question": "배포 과정 중 '스테이징(Staging)' 환경이란?",
    "options": [
      "실제 배포 전, 실제 서비스와 똑같은 환경에서 마지막으로 테스트하는 연습 서버",
      "공연 무대",
      "잠자는 곳",
      "밥 먹는 곳",
      "공부하는 곳"
    ],
    "answer": "실제 배포 전, 실제 서비스와 똑같은 환경에서 마지막으로 테스트하는 연습 서버",
    "why": "실제 사용자에게 장애를 노출하지 않기 위한 최종 리허설 공간입니다.",
    "hint": "Staging"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6086",
    "question": "백엔드 서버에서 AI 모델의 '온도(Temperature)'를 설정값으로 받는 이유는?",
    "options": [
      "방 안이 너무 더워서",
      "답변의 무작위성을 제어하여 상황에 맞는 응답을 얻기 위해",
      "서버가 뜨거워서",
      "전기세가 많이 나와서",
      "컴퓨터가 고장 나서"
    ],
    "answer": "답변의 무작위성을 제어하여 상황에 맞는 응답을 얻기 위해",
    "why": "서버 로직에서 AI의 창의성 정도를 결정하는 핵심 파라미터입니다.",
    "hint": "Temperature 설정"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6087",
    "question": "프런트엔드에서 '글자 수 한도'를 표시해주는 UI의 효과는?",
    "options": [
      "글자를 못 쓰게 함",
      "사용자가 AI에게 보낼 메시지 양을 인지하게 하여 토큰 낭비를 예방함",
      "로그인",
      "로그아웃",
      "광고 띄우기"
    ],
    "answer": "사용자가 메시지 양을 인지하게 하여 토큰 낭비를 예방함",
    "why": "사용자에게 제약 사항을 명확히 알려 시스템 오류를 미연에 방지합니다.",
    "hint": "글자 수 표시"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6088",
    "question": "백엔드 서버의 '타임아웃(Timeout)' 시간을 너무 짧게 잡았을 때의 문제는?",
    "options": [
      "답변이 너무 빨리 나옴",
      "AI가 답변을 생성하는 도중에 연결이 강제로 끊겨 응답이 누락됨",
      "컴퓨터가 꺼짐",
      "키보드가 안 눌림",
      "마우스가 안 움직임"
    ],
    "answer": "AI가 답변을 생성하는 도중에 연결이 강제로 끊겨 응답이 누락됨",
    "why": "생성 시간이 필요한 LLM의 특성을 고려해 적절한 대기 시간을 유지해야 합니다.",
    "hint": "Timeout 문제"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6089",
    "question": "배포된 인프라의 '로그 분석'을 통해 해커의 공격 시도를 발견하는 법은?",
    "options": [
      "그림 보기",
      "특정 IP에서 비정상적으로 많은 요청이 들어오는지 로그 패턴을 확인함",
      "노래 듣기",
      "게임 하기",
      "잠자기"
    ],
    "answer": "특정 IP에서 비정상적으로 많은 요청이 들어오는지 로그 패턴을 확인함",
    "why": "모니터링과 보안은 서비스 운영의 두 기둥입니다.",
    "hint": "로그 분석 보안"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6090",
    "question": "최고의 AI 서비스를 만드는 마지막 비결은 무엇인가?",
    "options": [
      "코드를 한 번 짜고 끝내는 것",
      "지속적으로 사용자와 소통하며 AI 성능과 UI/UX를 개선해 나가는 것",
      "컴퓨터를 끄는 것",
      "비밀번호를 공개하는 것",
      "인터넷 해지"
    ],
    "answer": "지속적으로 사용자와 소통하며 AI 성능과 UI/UX를 개선해 나가는 것",
    "why": "완성된 코드는 없으며, 살아 움직이며 진화하는 서비스가 최고의 서비스입니다.",
    "hint": "진정한 완성"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6091",
    "question": "프런트엔드 성능 최적화 기법 중 '이미지 지연 로딩(Lazy Loading)'의 효과는?",
    "options": [
      "배터리 폭발",
      "사용자가 보고 있는 화면의 이미지만 먼저 불러와 초기 로딩 속도를 높임",
      "사진 삭제",
      "글자 지우기",
      "로그아웃"
    ],
    "answer": "사용자가 보고 있는 화면의 이미지만 먼저 불러와 초기 로딩 속도를 높임",
    "why": "불필요한 네트워크 자원 소모를 줄여 쾌적한 웹 경험을 제공합니다.",
    "hint": "Lazy Loading"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6092",
    "question": "백엔드에서 'SQL Injection' 공격을 막기 위한 가장 좋은 방법은?",
    "options": [
      "비밀번호 없애기",
      "사용자 입력을 쿼리에 직접 넣지 않고 Parameterized Query(준비된 문구)를 사용하기",
      "모니터 끄기",
      "키보드 숨기기",
      "인터넷 해지"
    ],
    "answer": "사용자 입력을 쿼리에 직접 넣지 않고 Parameterized Query(준비된 문구)를 사용하기",
    "why": "DB 보안의 기본 중의 기본으로, 악의적인 쿼리 실행을 원천 차단합니다.",
    "hint": "SQL Injection 방어"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6093",
    "question": "배포 후 'Google Search Console'을 사용하는 목적은?",
    "options": [
      "게임 하기",
      "구글 검색 결과에서 내 사이트의 노출 현황을 확인하고 문제점을 고치기 위해",
      "사진 편집",
      "음악 듣기",
      "잠자기"
    ],
    "answer": "구글 검색 결과에서 내 사이트의 노출 현황을 확인하고 문제점을 고치기 위해",
    "why": "검색 유입을 늘리고 웹사이트의 건강 상태를 체크하는 전문 도구입니다.",
    "hint": "Search Console"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6094",
    "question": "프런트엔드에서 'Web Accessibility'(웹 접근성)를 준수하는 이유는?",
    "options": [
      "법을 어기려고",
      "장애인이나 고령자 등 모든 사용자가 차별 없이 서비스를 이용할 수 있도록 하기 위해",
      "사진 숨기기",
      "글자 작게 하기",
      "로그인 금지"
    ],
    "answer": "장애인이나 고령자 등 모든 사용자가 차별 없이 서비스를 이용할 수 있도록 하기 위해",
    "why": "사회적 책임과 동시에 더 많은 사용자층을 확보하는 포용적인 설계입니다.",
    "hint": "웹 접근성"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6095",
    "question": "백엔드 서버의 'Load Average'(부하 평균) 지표를 확인하는 이유는?",
    "options": [
      "날짜 확인",
      "시스템이 현재 처리해야 할 작업이 얼마나 쌓여 있는지 부하 정도를 파악하기 위해",
      "이름 짓기",
      "사진첩",
      "인터넷 속도"
    ],
    "answer": "시스템이 현재 처리해야 할 작업이 얼마나 쌓여 있는지 부하 정도를 파악하기 위해",
    "why": "서버가 과부하 상태인지 판단하여 인프라 증설 여부를 결정하는 척도가 됩니다.",
    "hint": "Load Average"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6096",
    "question": "배포 시 'Rollback'(롤백)이란?",
    "options": [
      "앞으로 가기",
      "배포 후 심각한 버그 발견 시 즉시 이전의 정상적인 상태로 되돌리는 것",
      "컴퓨터 끄기",
      "키보드 닦기",
      "모든 파일 삭제"
    ],
    "answer": "배포 후 심각한 버그 발견 시 즉시 이전의 정상적인 상태로 되돌리는 것",
    "why": "서비스의 가용성을 지키기 위한 최후의 방어 수단입니다.",
    "hint": "Rollback"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6097",
    "question": "프런트엔드에서 'SEO'를 위해 설정하는 <meta> 태그의 역할은?",
    "options": [
      "배경 음악 재생",
      "사이트의 제목, 설명, 키워드를 검색 엔진에 알려주는 명함 역할",
      "비밀번호 저장",
      "파일 다운로드",
      "로그아웃"
    ],
    "answer": "사이트의 제목, 설명, 키워드를 검색 엔진에 알려주는 명함 역할",
    "why": "검색 결과 미리보기에 나타나는 텍스트를 결정하여 클릭률을 높여줍니다.",
    "hint": "Meta Tag"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6098",
    "question": "백엔드 서버에서 'API 키'를 탈취당했을 때 가장 먼저 해야 할 일은?",
    "options": [
      "사이트 폐쇄",
      "기존 키를 즉시 무효화(Revoke)하고 새로운 키를 발급받아 교체하기",
      "모니터 부수기",
      "키보드 숨기기",
      "인터넷 해지"
    ],
    "answer": "기존 키를 즉시 무효화(Revoke)하고 새로운 키를 발급받아 교체하기",
    "why": "추가적인 비용 발생이나 정보 유출을 막기 위한 긴급 보안 조치입니다.",
    "hint": "Key Revocation"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6099",
    "question": "서비스 배포 후 '사용자 행동 분석' 도구를 활용하는 목적은?",
    "options": [
      "개인 정보 도난",
      "어느 버튼을 많이 누르고 어디서 이탈하는지 파악하여 UX를 개선하기 위해",
      "사진 감상",
      "음악 듣기",
      "게임 하기"
    ],
    "answer": "어느 버튼을 많이 누르고 어디서 이탈하는지 파악하여 UX를 개선하기 위해",
    "why": "사용자의 불편함을 데이터로 읽어내어 더 사랑받는 서비스를 만드는 과정입니다.",
    "hint": "행동 분석"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "객관식",
    "difficulty": "medium",
    "id": "6100",
    "question": "성공적인 LLM 서비스 배포를 위한 마인드셋은?",
    "options": [
      "한 번 만들어두면 평생 갈 것",
      "기술은 계속 변하므로 끊임없이 학습하고 서비스를 고도화하려는 태도",
      "컴퓨터 끄기",
      "비밀번호 노출",
      "인터넷 해지"
    ],
    "answer": "기술은 계속 변하므로 끊임없이 학습하고 서비스를 고도화하려는 태도",
    "why": "빠르게 변하는 AI 시대에 발맞춰 성장하는 개발자의 기본 소양입니다.",
    "hint": "Growth Mindset"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "6101",
    "question": "사용자 영역 개념 혹은 코드를 완성하세요.\n```text\n____-end: 사용자가 눈으로 보는 화면 영역. (이 부분을 채우세요)\n```",
    "answer": "Front",
    "why": "프런트엔드를 의미합니다.",
    "hint": "사용자 영역"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "6102",
    "question": "서버 영역 개념 혹은 코드를 완성하세요.\n```text\n____-end: 데이터 처리와 비즈니스 로직 영역. (이 부분을 채우세요)\n```",
    "answer": "Back",
    "why": "백엔드를 의미합니다.",
    "hint": "서버 영역"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "6103",
    "question": "빠른 API 개념 혹은 코드를 완성하세요.\n```text\n____API: 파이썬 기반 고성능 웹 프레임워크. (이 부분을 채우세요)\n```",
    "answer": "Fast",
    "why": "FastAPI를 의미합니다.",
    "hint": "빠른 API"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "6104",
    "question": "데이터 형식 개념 혹은 코드를 완성하세요.\n```text\n____: 키-값 쌍의 통신용 데이터 포맷. (이 부분을 채우세요)\n```",
    "answer": "JSON",
    "why": "제이슨(JSON) 형식입니다.",
    "hint": "데이터 형식"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "6105",
    "question": "인증키 변수 개념 혹은 코드를 완성하세요.\n```text\nAPI_____: 모델 사용 인증을 위한 변수명. (이 부분을 채우세요)\n```",
    "answer": "KEY",
    "why": "인증키(KEY)를 의미합니다.",
    "hint": "인증키 변수"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "6106",
    "question": "환경 파일 개념 혹은 코드를 완성하세요.\n```text\n.____: 설정값을 담는 숨김 파일 확장자. (이 부분을 채우세요)\n```",
    "answer": "env",
    "why": ".env 파일입니다.",
    "hint": "환경 파일"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "6107",
    "question": "데이터 전송 개념 혹은 코드를 완성하세요.\n```text\nHTTP ____: 데이터를 보낼 때 쓰는 메서드. (이 부분을 채우세요)\n```",
    "answer": "POST",
    "why": "POST 메서드를 주로 사용합니다.",
    "hint": "데이터 전송"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "6108",
    "question": "비동기 키워드 개념 혹은 코드를 완성하세요.\n```text\n____ def: 파이썬 비동기 함수 정의 키워드. (이 부분을 채우세요)\n```",
    "answer": "async",
    "why": "async 키워드입니다.",
    "hint": "비동기 키워드"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "6109",
    "question": "배포 도구 개념 혹은 코드를 완성하세요.\n```text\n____ er: 컨테이너 기반 가상화 배포 도구. (이 부분을 채우세요)\n```",
    "answer": "Dock",
    "why": "도커(Docker)입니다.",
    "hint": "배포 도구"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "6110",
    "question": "실시간 응답 개념 혹은 코드를 완성하세요.\n```text\n____ing: 글자가 하나씩 나오는 출력 방식. (이 부분을 채우세요)\n```",
    "answer": "Stream",
    "why": "스트리밍(Streaming)입니다.",
    "hint": "실시간 응답"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "6111",
    "question": "보안 프로토콜 개념 혹은 코드를 완성하세요.\n```text\n____S: 보안 인증서가 적용된 웹 주소 접두사. (이 부분을 채우세요)\n```",
    "answer": "HTTP",
    "why": "HTTPS를 의미합니다.",
    "hint": "보안 프로토콜"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "6112",
    "question": "정적 파일 저장 개념 혹은 코드를 완성하세요.\n```text\n____ : 이미지나 파일을 저장하는 클라우드 저장소(AWS).\n```",
    "answer": "S3",
    "why": "S3 버킷을 의미합니다.",
    "hint": "정적 파일 저장"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "6113",
    "question": "자동 배포 개념 혹은 코드를 완성하세요.\n```text\nCI/____: 코드 반영 시 자동 배포 파이프라인. (이 부분을 채우세요)\n```",
    "answer": "CD",
    "why": "CD(Continuous Deployment)입니다.",
    "hint": "자동 배포"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "6114",
    "question": "도메인 주소 개념 혹은 코드를 완성하세요.\n```text\n____ Name System: 주소를 IP로 바꿔주는 시스템.\n```",
    "answer": "Domain",
    "why": "DNS를 의미합니다.",
    "hint": "도메인 주소"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "6115",
    "question": "라우팅 경로 개념 혹은 코드를 완성하세요.\n```text\nAPI ____point: 서버 기능이 열려 있는 주소.\n```",
    "answer": "End",
    "why": "엔드포인트(Endpoint)입니다.",
    "hint": "라우팅 경로"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "6116",
    "question": "자동 문서화 개념 혹은 코드를 완성하세요.\n```text\n____er: FastAPI가 제공하는 자동 API 문서.\n```",
    "answer": "Swagg",
    "why": "스웨거(Swagger)입니다.",
    "hint": "자동 문서화"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "6117",
    "question": "브라우저 저장 개념 혹은 코드를 완성하세요.\n```text\n____ Storage: 브라우저에 데이터를 저장함.\n```",
    "answer": "Local",
    "why": "로컬 스토리지(Local Storage)입니다.",
    "hint": "브라우저 저장"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "6118",
    "question": "버전 관리 개념 혹은 코드를 완성하세요.\n```text\n____ : 코드 이력을 관리하는 도구 이름.\n```",
    "answer": "Git",
    "why": "깃(Git)을 의미합니다.",
    "hint": "버전 관리"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "6119",
    "question": "응답 지연 개념 혹은 코드를 완성하세요.\n```text\n____ency: 응답에 걸리는 시간 지표.\n```",
    "answer": "Lat",
    "why": "레이턴시(Latency)입니다.",
    "hint": "응답 지연"
  },
  {
    "chapter_name": "서비스 구축 및 배포",
    "type": "코드 완성형",
    "difficulty": "medium",
    "id": "6120",
    "question": "서버 상태 개념 혹은 코드를 완성하세요.\n```text\n____ Check: 서버가 살아있는지 확인하는 API.\n```",
    "answer": "Health",
    "why": "헬스 체크(Health Check)입니다.",
    "hint": "서버 상태"
  }
]