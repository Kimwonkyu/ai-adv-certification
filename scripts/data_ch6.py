
chapter_name = "서비스 구축 및 배포"

questions = []

# --- 100 MCQs ---
mcq_data = [
    # 1. 서비스 구축 아키텍처 및 프런트엔드 (1-30)
    ("LLM 서비스를 구축할 때 가장 먼저 고려해야 할 아키텍처 구성 요소는?", ["사무실의 조명 밝기", "프런트엔드, 백엔드 서버, 그리고 LLM API/모델 엔진의 연결 구조", "모니터의 브랜드", "의자의 높낮이", "키보드의 축 종류"], "프런트엔드, 백엔드 서버, 그리고 LLM API/모델 엔진의 연결 구조", "사용자의 입력을 받고 AI의 응답을 전달하는 전체적인 시스템 설계가 핵심입니다.", "서비스 아키텍처", "6001"),
    ("사용자가 웹 브라우저를 통해 채팅 인터페이스를 보고 메시지를 입력하는 영역은?", ["백엔드 (Backend)", "프런트엔드 (Frontend)", "데이터베이스 (Database)", "GPU 서버", "네트워크 라우터"], "프런트엔드 (Frontend)", "React, Vue, Next.js 등을 사용하여 사용자 경험(UX)을 구현하는 영역입니다.", "프런트엔드", "6002"),
    ("LLM 서비스에서 실시간으로 글자가 하나씩 생성되는 느낌을 주기 위해 사용하는 기술은?", ["이미지 캡처", "스트리밍 (Streaming / Server-Sent Events)", "파일 다운로드", "전체 화면 캡처", "단순 페이지 새로고침"], "스트리밍 (Streaming / Server-Sent Events)", "사용자가 답변이 완료될 때까지 기다리지 않고 생성 과정을 즉시 볼 수 있게 합니다.", "스트리밍", "6003"),
    ("프런트엔드에서 사용자의 이전 대화 내역을 유지하여 보여주는 기능의 명칭은?", ["Chat History", "File Explorer", "Task Manager", "Disk Utility", "Control Panel"], "Chat History", "과거의 대화를 리스트 형태로 관리하여 사용자가 맥락을 파악하도록 돕습니다.", "채팅 히스토리", "6004"),
    ("사용자가 입력한 메시지를 백엔드로 전달할 때 주로 사용하는 HTTP 메서드는?", ["GET", "POST", "DELETE", "HEAD", "OPTIONS"], "POST", "메시지 본문(Payload)에 데이터를 담아 서버로 안전하게 전송하기 위해 쓰입니다.", "POST 메서드", "6005"),
    ("웹 서비스 구축 시 화면의 레이아웃과 디자인을 담당하는 언어는?", ["Python", "SQL", "CSS", "C++", "Java"], "CSS", "채팅창의 너비, 배경색, 글꼴 스타일 등을 정의하여 시각적인 완성도를 높입니다.", "CSS", "6006"),
    ("반응형 웹 디자인(Responsive Web Design)이 LLM 서비스에서 중요한 이유는?", ["코드가 예뻐서", "PC뿐만 아니라 모바일 환경에서도 최적화된 채팅 UI를 제공하기 위해", "속도가 빨라져서", "비용이 저렴해서", "보안이 강화되어서"], "PC뿐만 아니라 모바일 환경에서도 최적화된 채팅 UI를 제공하기 위해", "다양한 기기에서 인공지능과 원활하게 대화할 수 있는 접근성을 확보합니다.", "반응형 디자인", "6007"),
    ("프런트엔드 프레임워크 중 'Next.js'를 LLM 앱 개발에 자주 사용하는 주된 장점은?", ["게임 개발에 특화됨", "서버 사이드 렌더링(SSR)과 API Routes를 통해 풀스택 개발이 용이함", "운영체제를 직접 만듦", "포토샵 기능 내장", "엑셀과 완벽 호환"], "서버 사이드 렌더링(SSR)과 API Routes를 통해 풀스택 개발이 용이함", "백엔드 로직과 프런트엔드 UI를 하나의 프로젝트에서 효율적으로 관리할 수 있습니다.", "Next.js 장점", "6008"),
    ("채팅창에서 AI 답변이 생성 중임을 알리는 '로딩 애니메이션'의 UX적 효과는?", ["배터리 절약", "사용자에게 시스템이 정상적으로 응답 중임을 알려 불안감을 해소함", "인터넷 속도 향상", "자동 오타 교정", "화면 보호"], "사용자에게 시스템이 정상적으로 응답 중임을 알려 불안감을 해소함", "생성 시간이 다소 소요되는 LLM의 특성상 사용자 대기 경험을 관리하는 것이 중요합니다.", "로딩 UI", "6009"),
    ("마크다운(Markdown) 렌더링 기능이 LLM 프런트엔드에 필수적인 이유는?", ["파일 용량을 줄이기 위해", "코드 블록, 표, 굵은 글씨 등 AI의 응답을 가독성 있게 표현하기 위해", "광고를 띄우기 위해", "한글을 영어로 바꾸기 위해", "로그인을 대신 하기 위해"], "코드 블록, 표, 굵은 글씨 등 AI의 응답을 가독성 있게 표현하기 위해", "AI가 생성한 다양한 형식의 정보를 사용자가 읽기 편한 구조로 보여줍니다.", "마크다운", "6010"),

    # 2. 백엔드 및 API 개발 (31-60)
    ("사용자의 요청을 받아 LLM 모델에 전달하고 결과를 가공하여 응답하는 서버 영역은?", ["프런트엔드", "백엔드 (Backend / API Server)", "모니터", "마우스", "프린터"], "백엔드 (Backend / API Server)", "비즈니스 로직 처리, 보안 인증, 외부 API 연동 등을 담당하는 핵심 두뇌입니다.", "백엔드", "6011"),
    ("파이썬 기반의 빠르고 현대적인 웹 프레임워크로, LLM API 서버 구축에 많이 쓰이는 것은?", ["Flask", "Django", "FastAPI", "PHP", "JSP"], "FastAPI", "비동기(Async) 처리가 강력하고 자동 API 문서 생성(Swagger) 기능을 제공하여 효율적입니다.", "FastAPI", "6012"),
    ("API 서버 내부에서 LLM 서비스를 제공하는 회사(OpenAI, Anthropic 등)와 통신할 때 필요한 인증 수단은?", ["ID/비밀번호", "API Key (인증 키)", "집 주소", "전화번호", "주민등록번호"], "API Key (인증 키)", "인가된 사용자만 모델 사용량을 소모할 수 있도록 관리하는 보안 장치입니다.", "API Key", "6013"),
    ("백엔드 서버에서 여러 사용자의 요청을 동시에 효율적으로 처리하기 위해 사용하는 프로그래밍 방식은?", ["순차 실행", "비동기 프로그래밍 (Asynchronous Programming)", "전원 끄기", "한 명씩 기다리게 하기", "데이터 삭제"], "비동기 프로그래밍 (Asynchronous Programming)", "하나의 요청이 처리되는 동안(예: AI 응답 대기) 다른 요청을 처리하여 효율을 극대화합니다.", "비동기", "6014"),
    ("백엔드 서버에서 민감한 API Key를 코드에 직접 노출하지 않고 관리하는 방법은?", ["코드에 주석으로 남기기", "환경 변수(Environment Variables) 파일(.env) 사용", "바탕화면에 메모장으로 저장", "카카오톡 나에게 보내기", "카페 게시판에 올리기"], "환경 변수(Environment Variables) 파일(.env) 사용", "보안 유출을 방지하기 위해 설정값과 실행 코드를 분리하는 모범 사례입니다.", "환경 변수", "6015"),
    ("API 서버가 클라이언트에게 데이터를 줄 때 가장 흔히 사용하는 가벼운 데이터 형식은?", ["XML", "JSON", "CSV", "TXT", "XLSX"], "JSON", "키-값 쌍으로 이루어져 프로그래밍 언어 간 데이터 교환에 최적화되어 있습니다.", "JSON", "6016"),
    ("백엔드 서버에서 답변 생성 전, 사용자의 질문이 부적절한지 검사하는 과정을 무엇이라 하나?", ["Preprocessing / Content Filtering", "Postprocessing", "Hardening", "Formatting", "Deleting"], "Preprocessing / Content Filtering", "유해한 콘텐츠 생성을 방지하고 서비스 가이드라인을 준수하기 위한 안전 단계입니다.", "필터링", "6017"),
    ("데이터베이스(DB)를 백엔드에 연동하는 주된 이유 중 '대화 영속성'이란?", ["속도를 높이는 것", "대화가 종료되어도 나중에 이전 내역을 다시 불러올 수 있게 저장하는 것", "글자 수를 늘리는 것", "영어로 대화하는 것", "비용을 결제하는 것"], "대화가 종료되어도 나중에 이전 내역을 다시 불러올 수 있게 저장하는 것", "사용자가 다시 접속했을 때 과거의 맥락을 이어서 대화할 수 있도록 합니다.", "영속성", "6018"),
    ("API 문서 자동 생성 도구인 'Swagger'를 통해 얻을 수 있는 이점은?", ["코딩을 대신 해줌", "프런트엔드 개발자가 서버 API의 사양을 쉽게 파악하고 테스트할 수 있음", "인터넷이 빨라짐", "CPU 온도가 내려감", "전기세가 절약됨"], "프런트엔드 개발자가 서버 API의 사양을 쉽게 파악하고 테스트할 수 있음", "협업 효율성을 높이고 API 호출 시 에러를 줄여주는 강력한 도구입니다.", "Swagger", "6019"),
    ("백엔드에서 LLM 응답을 받은 후, 특정 형식에 맞춰 텍스트를 정돈하는 과정을 무엇이라 하나?", ["Ingestion", "Post-processing (후처리)", "Encoding", "Scaling", "Training"], "Post-processing (후처리)", "불필요한 공백 제거, 특수 문자 정제, 특정 포맷 변환 등을 수행합니다.", "후처리", "6020"),

    # 3. 배포 및 클라우드 인프라 (61-100)
    ("작성한 코드를 실제 인터넷 상에서 누구나 접속 가능한 상태로 만드는 과정을 무엇이라 하나?", ["Coding", "Deployment (배포)", "Debugging", "Designing", "Deleting"], "Deployment (배포)", "로컬 환경을 넘어 실제 서버 인프라에 서비스를 올리는 최종 단계입니다.", "배포의 정의", "6021"),
    ("서버를 직접 구매하지 않고 가상의 컴퓨팅 자원을 빌려 쓰는 최신 서비스 형태는?", ["Offline Store", "Cloud Computing (클라우드 컴퓨팅)", "Hard Disk", "USB Memory", "Floppy Disk"], "Cloud Computing (클라우드 컴퓨팅)", "AWS, Google Cloud, Azure 등 유연한 자원 확장이 가능한 인프라를 의미합니다.", "클라우드", "6022"),
    ("코드와 실행 환경을 하나로 묶어 어디서나 동일하게 실행되도록 만드는 가상화 기술은?", ["VMware", "Docker (도커)", "Notepad", "Paint", "Calculator"], "Docker (도커)", "컨테이너 기술을 통해 '내 컴퓨터에선 되는데 서버에선 안 되는' 문제를 해결합니다.", "도커", "6023"),
    ("배포 시 트래픽이 몰릴 때 서버의 개수를 자동으로 늘려주는 기능을 무엇이라 하나?", ["Auto-Save", "Auto-Scaling (오토 스케일링)", "Auto-Focus", "Auto-Complete", "Auto-Pilot"], "Auto-Scaling (오토 스케일링)", "사용자의 접속량에 따라 인프라를 유연하게 조절하여 안정적인 서비스를 유지합니다.", "오토 스케일링", "6024"),
    ("서비스의 주소(URL)를 쉽게 기억할 수 있도록 연결해주는 시스템은?", ["CPU", "DNS (Domain Name System)", "RAM", "GPU", "SSD"], "DNS (Domain Name System)", "IP 주소 대신 'example.com' 같은 문자로 서버에 접속하게 해줍니다.", "DNS", "6025"),
    ("전 세계 사용자에게 콘텐츠를 빠르게 전달하기 위해 서버를 분산 배치하는 기술은?", ["FTP", "CDN (Content Delivery Network)", "HTTP", "LAN", "WAN"], "CDN (Content Delivery Network)", "지리적으로 가까운 서버에서 데이터를 전송하여 응답 속도를 개선합니다.", "CDN", "6026"),
    ("배포 후 서비스의 상태(에러 발생 여부, CPU 점유율 등)를 실시간으로 확인하는 작업은?", ["Designing", "Monitoring (모니터링)", "Planning", "Meeting", "Resting"], "Monitoring (모니터링)", "장애를 미리 예방하고 성능 병목을 파악하기 위한 필수 운영 활동입니다.", "모니터링", "6027"),
    ("코드 변경 사항을 자동으로 테스트하고 서버에 즉시 배포하는 자동화 파이프라인은?", ["CI/CD", "GUI", "CLI", "IDE", "USB"], "CI/CD", "지속적 통합(CI)과 지속적 배포(CD)를 통해 개발 생산성을 획기적으로 높입니다.", "CI/CD", "6028"),
    ("인터넷 상의 위협(해킹, DDoS 등)으로부터 서버를 보호하기 위해 앞단에 두는 네트워크 보안 장치는?", ["Router", "Firewall (방화벽)", "Monitor", "Speaker", "Scanner"], "Firewall (방화벽)", "허용되지 않은 접근을 차단하여 소중한 데이터와 시스템을 지킵니다.", "방화벽", "6029"),
    ("배포된 서비스에 보안 연결(HTTPS)을 적용하기 위해 필요한 인증서는?", ["졸업 증명서", "SSL/TLS 인증서", "운전 면허증", "건강 진단서", "경력 증명서"], "SSL/TLS 인증서", "데이터 전송 구간을 암호화하여 중간에서 정보를 가로채지 못하게 보호합니다.", "SSL/TLS", "6030"),

    # 추가 70문제 (프런트/백/배포 응용)
    ("API 호출 횟수를 제한하여 특정 사용자가 서버 자원을 독점하지 못하게 하는 정책은?", ["Rate Limiting", "Open Access", "Free Pass", "Full Speed", "No Limit"], "Rate Limiting", "공정하고 안정적인 서비스 운영을 위해 필수적인 트래픽 제어 방식입니다.", "Rate Limiting", "6031"),
    ("프런트엔드에서 AI의 답변 길이를 시각적으로 제한하거나 '더보기' 버튼을 만드는 UI 설계의 목적은?", ["데이터 삭제", "답변이 너무 길어 화면을 가득 채우는 것을 막고 가독성을 유지하기 위해", "비용 청구", "영역 숨기기", "오타 유도"], "답변이 너무 길어 화면을 가득 채우는 것을 막고 가독성을 유지하기 위해", "깔끔한 인터페이스 유지를 위한 레이아웃 관리 전략입니다.", "UI 가독성", "6032"),
    ("백엔드에서 '로그(Log)'를 남기는 것이 중요한 이유는?", ["코드를 길게 하려고", "문제가 발생했을 때 원인을 추적하고 시스템 방문 기록을 분석하기 위해", "종이를 아끼려고", "모니터를 끄려고", "마우스를 던지려고"], "문제가 발생했을 때 원인을 추적하고 시스템 방문 기록을 분석하기 위해", "운영 중 발생하는 이슈를 해결하는 가장 강력한 단서가 됩니다.", "Logging", "6033"),
    ("배포 환경과 로컬 개발 환경의 설정을 분리하는 가장 좋은 방법은?", ["코드를 두 번 짜기", "환경 변수를 활용하여 주소나 키값을 동적으로 로드하기", "종이에 적어두기", "전부 다 지우기", "로그인 안 하기"], "환경 변수를 활용하여 주소나 키값을 동적으로 로드하기", "하나의 소스 코드로 여러 환경에서 안정적으로 동작하게 만드는 설계 방식입니다.", "환경 분리", "6034"),
    ("도커 컨테이너를 여러 개 관리하고 배포를 자동화해주는 '오케스트레이션' 도구는?", ["Kubernetes (쿠버네티스)", "Notepad", "Excel", "PowerPoint", "Paint"], "Kubernetes (쿠버네티스)", "대규모 서비스의 컨테이너 운영을 자동화하는 업계 표준 도구입니다.", "Kubernetes", "6035"),
    ("사용자가 채팅창에 대용량 파일을 업로드할 때 백엔드에서 고려해야 할 점은?", ["파일 이름", "파일 크기 제한(Body Size Limit) 및 안전한 저장소(S3 등) 확보", "파일의 색깔", "키보드 속도", "마우스 응답성"], "파일 크기 제한(Body Size Limit) 및 안전한 저장소(S3 등) 확보", "서버 자원 고갈을 막고 데이터를 안정적으로 관리하기 위한 설계입니다.", "파일 업로드 처리", "6036"),
    ("프런트엔드에서 '다크 모드'를 지원할 때 얻는 UX적 장점은?", ["전기세 폭탄", "사용자의 눈 피로도를 낮추고 세련된 디자인 감성을 제공함", "인터넷 속도 2배", "AI의 지능 향상", "자동 번역"], "사용자의 눈 피로도를 낮추고 세련된 디자인 감성을 제공함", "장시간 채팅을 이용하는 사용자에게 편리한 시각적 환경을 선사합니다.", "다크 모드", "6037"),
    ("백엔드 서버 배포 시 '무중단 배포'를 하는 이유는?", ["전기를 아끼려고", "새로운 버전 업데이트 중에도 사용자가 끊김 없이 서비스를 이용하게 하려고", "코드가 사라질까 봐", "속도가 너무 빨라서", "심심해서"], "새로운 버전 업데이트 중에도 사용자가 끊김 없이 서비스를 이용하게 하려고", "업데이트로 인한 서비스 중지 시간을 없애 신뢰도를 유지합니다.", "무중단 배포", "6038"),
    ("API 응답 시간을 측정할 때 사용하는 단위는?", ["미터(m)", "밀리초 (ms)", "킬로그램(kg)", "리터(L)", "온도(℃)"], "밀리초 (ms)", "1,000분의 1초 단위로 측정하여 서비스 반응성을 정교하게 관리합니다.", "Latency 단위", "6039"),
    ("배포 후 'Health Check' API를 만드는 주된 목적은?", ["건강 검진 기록", "서버가 현재 정상적으로 살아있는지 주기적으로 확인하기 위해", "이름 짓기", "사진 찍기", "로그아웃"], "서버가 현재 정상적으로 살아있는지 주기적으로 확인하기 위해", "모니터링 시스템이나 로드 밸런서가 서버의 생존 여부를 판단하는 척도가 됩니다.", "Health Check", "6040"),
    ("프런트엔드에서 '복사하기' 버튼을 구현하는 이유는?", ["종이가 없어서", "AI의 긴 답변이나 코드를 사용자가 간편하게 복사할 수 있도록 하여 편의성을 높이기 위해", "인터넷을 중단하려고", "화면을 끄려고", "파일을 지우려고"], "AI의 긴 답변이나 코드를 사용자가 간편하게 복사할 수 있도록 하여 편의성을 높이기 위해", "생산성 향상을 위한 작은 디테일이 사용자 경험을 크게 개선합니다.", "복사 기능", "6041"),
    ("백엔드에서 'CORS' 에러가 발생하는 상황은?", ["키보드가 고장 났을 때", "서로 다른 도메인(주소) 간에 리소스를 요청할 때 보안 정책으로 차단되는 경우", "인터넷이 끊겼을 때", "컴퓨터 전원이 나갔을 때", "마우스를 클릭했을 때"], "서로 다른 도메인(주소) 간에 리소스를 요청할 때 보안 정책으로 차단되는 경우", "보안을 위해 브라우저가 타 도메인으로의 요청을 제어하는 정책입니다.", "CORS", "6042"),
    ("서버 배포 시 '리전(Region)' 선택 시 가장 중요한 기준은?", ["리전 이름의 알파벳 순서", "사용자와 가장 가까운 지리적 위치(속도 향상 및 지연 감소)", "날씨가 좋은 곳", "유명 관광지 근처", "내가 가고 싶은 나라"], "사용자와 가장 가까운 지리적 위치(속도 향상 및 지연 감소)", "한국 사용자라면 서울 리전을 선택하는 것이 가장 빠른 성능을 냅니다.", "리전 선택", "6043"),
    ("백엔드에서 사용되는 '데이터베이스 인덱싱'의 효과는?", ["글자 크기 키우기", "데이터 검색 속도를 비약적으로 높여 응답 시간을 단축함", "용량 늘리기", "파일 삭제", "전원 끄기"], "데이터 검색 속도를 비약적으로 높여 응답 시간을 단축함", "수백만 건의 대화 기록 속에서 원하는 내용을 순식간에 찾아내게 합니다.", "DB 인덱스", "6044"),
    ("프런트엔드에서 'Toast 메시지'(짧게 떴다 사라지는 알림)의 용도는?", ["토스트 구워 먹기", "작업 완료나 에러 발생을 사용자에게 방해되지 않게 살짝 알려줌", "컴퓨터 부팅", "로그인 강제", "광고 노출"], "작업 완료나 에러 발생을 사용자에게 방해되지 않게 살짝 알려줌", "현재 작업 흐름을 깨지 않으면서 정보를 전달하는 유용한 UI 요소입니다.", "Toast UI", "6045"),
    ("백엔드 개발 시 '단위 테스트(Unit Test)'의 역할은?", ["배터리 수명 체크", "개별 기능(함수)이 의도대로 정확히 동작하는지 코드로 검증하여 버그를 방지함", "타이핑 속도 측정", "모니터 색상 보정", "키보드 배열 변경"], "개별 기능(함수)이 의도대로 정확히 동작하는지 코드로 검증하여 버그를 방지함", "코드를 신뢰할 수 있게 만들고 향후 수정 시 발생하는 사이드 이펙트를 막아줍니다.", "Unit Test", "6046"),
    ("배포 시 'Git'을 사용하는 근거 중 하나인 '버전 관리'란?", ["컴퓨터를 새로 사는 것", "코드의 수정 이력을 기록하고 필요할 때 과거 상태로 되돌리는 것", "이름을 멋지게 짓는 것", "파일을 다 합치는 것", "인터넷 쇼핑"], "코드의 수정 이력을 기록하고 필요할 때 과거 상태로 되돌리는 것", "여러 개발자가 협업하고 시스템을 안정적으로 업데이트하는 기반이 됩니다.", "Git 버전 관리", "6047"),
    ("프런트엔드에서 'State Management'(상태 관리)가 필요한 이유는?", ["기분이 안 좋아서", "채팅방 내용, 로그인 정보 등 실시간으로 변하는 데이터를 일관되게 관리하기 위해", "컴퓨터를 끄려고", "키보드를 누르려고", "파일을 지우려고"], "채팅방 내용, 로그인 정보 등 실시간으로 변하는 데이터를 일관되게 관리하기 위해", "복잡한 앱의 데이터 흐름을 꼬이지 않게 잡아주는 핵심 기술입니다.", "상태 관리", "6048"),
    ("클라우드 서비스 중 'Serverless'(서버리스)의 특징은?", ["서버가 아예 없는 것", "사용자가 서버 관리를 직접 하지 않고 실행된 만큼만 비용을 지불하는 방식", "사무실을 없애는 것", "인터넷이 안 되는 것", "모델을 안 쓰는 것"], "사용자가 서버 관리를 직접 하지 않고 실행된 만큼만 비용을 지불하는 방식", "관리가 편하고 초기 비용 부담이 적어 가벼운 AI 앱 배포에 좋습니다.", "서버리스", "6049"),
    ("백엔드 서버에서 '세션(Session)'과 '쿠키(Cookie)'의 역할은?", ["과자 먹기", "사용자의 로그인 상태나 방문 정보를 유지하여 개인화된 경험을 제공함", "컴퓨터 부품 이름", "인터넷 브라우저 이름", "사이트 주소"], "사용자의 로그인 상태나 방문 정보를 유지하여 개인화된 경험을 제공함", "사용자를 식별하여 '내 대화 내역'을 안전하게 보여주는 기반이 됩니다.", "세션과 쿠키", "6050"),
    ("프런트엔드에서 'Skeleton Screen'을 보여주는 의도는?", ["해골 그림 그리기", "데이터 로딩 중 빈 화면 대신 레이아웃 윤곽을 미리 보여줘 체감 속도를 높임", "사이트 끄기", "로그아웃", "광고 띄우기"], "데이터 로딩 중 빈 화면 대신 레이아웃 윤곽을 미리 보여줘 체감 속도를 높임", "사용자가 콘텐츠가 곧 나올 것임을 인지하게 하여 시각적 만족감을 줍니다.", "Skeleton UI", "6051"),
    ("API 서버의 'Versioning'(버전 관리)은 왜 하나?", ["숫자 공부하려고", "기존 사용자 기능을 유지하면서 새로운 기능을 안전하게 추가하고 업데이트하기 위해", "이름이 없어서", "순서를 정하려고", "비용을 늘리려고"], "기존 사용자 기능을 유지하면서 새로운 기능을 안전하게 추가하고 업데이트하기 위해", "예: /v1/chat과 /v2/chat을 구분하여 하위 호환성을 지키는 전문적인 개발 방식입니다.", "API 버전", "6052"),
    ("클라우드 인프라에서 'VPC'(가상 사설 클라우드)의 역할은?", ["가상 게임 공간", "사설 네트워크를 구축하여 독립적이고 안전한 리소스 환경을 제공함", "인터넷 카페", "파일 공유 폴더", "컴퓨터 부품"], "사설 네트워크를 구축하여 독립적이고 안전한 리소스 환경을 제공함", "기업의 데이터를 공용 인터넷과 격리하여 보안을 극대화하는 성벽 역할을 합니다.", "VPC", "6053"),
    ("백엔드 비즈니스 로직 중 'Validation'(검증)이란?", ["유통기한 확인", "입력 데이터가 형식에 맞는지, 위험한 코드가 섞여 있지 않은지 확인하는 절차", "인기 투표", "친구 찾기", "비밀번호 삭제"], "입력 데이터가 형식에 맞는지, 위험한 코드가 섞여 있지 않은지 확인하는 절차", "시스템 에러를 막고 악의적인 데이터 주입 공격을 원천 차단합니다.", "Validation", "6054"),
    ("배포 전략 중 'Blue-Green Deployment'의 특징은?", ["색깔 고르기", "기존 서버(Blue)와 새 서버(Green)를 동시에 띄워 교체하며 장애를 최소화함", "파란색 옷 입기", "초록색 옷 입기", "신호등 지키기"], "기존 서버(Blue)와 새 서버(Green)를 동시에 띄워 교체하며 장애를 최소화함", "리스크가 적고 실패 시 즉시 이전 버전으로 되돌릴 수 있는 안정적인 배포 기법입니다.", "Blue-Green", "6055"),
    ("프런트엔드 빌드(Build) 과정에서 하는 일은?", ["집 짓기", "소스 코드를 브라우저가 읽기 최적화된 파일로 압축하고 변환하는 과정", "파일 하나씩 읽기", "그림 그리기", "노래 듣기"], "소스 코드를 브라우저가 읽기 최적화된 파일로 압축하고 변환하는 과정", "용량을 줄이고 보안을 강화하여 실제 서비스 성능을 높이는 전처리입니다.", "Frontend Build", "6056"),
    ("API 서버의 'Rate Limit Exceeded' 에러를 받았을 때 프런트엔드의 대처는?", ["서버를 계속 공격함", "잠시 기다려달라는 메시지를 보여주고 재시도 버튼을 안내함", "로그아웃", "글자 다 지우기", "화면 끄기"], "잠시 기다려달라는 메시지를 보여주고 재시도 버튼을 안내함", "서버 정책을 사용자에게 친절하게 안내하여 서비스에 대한 긍정적 경험을 유지합니다.", "과부하 대응", "6057"),
    ("데이터베이스 서버를 '분리'해서 구축하는 장점은?", ["관리하기 귀찮음", "웹 서버와 데이터 저장 서버의 역할을 나누어 성능을 최적화하고 보안을 강화함", "컴퓨터 대수 줄이기", "전기세 절약", "인터넷 속도"], "웹 서버와 데이터 저장 서버의 역할을 나누어 성능을 최적화하고 보안을 강화함", "전문적인 인프라 구성을 통해 서비스의 안정성과 확장성을 확보합니다.", "DB 분리", "6058"),
    ("배포 시 '환경 설정 파일(.yml, .json 등)'을 사용하는 이유는?", ["그림 그리려고", "소소한 설정 변경 시 코드 수정 없이 파일만 갈아끼워 적용하기 위해", "글자 수 채우기", "멋있어 보이려고", "비밀번호 저장소"], "소소한 설정 변경 시 코드 수정 없이 파일만 갈아끼워 적용하기 위해", "유연하고 유지보수가 쉬운 환경 관리를 가능하게 합니다.", "Config File", "6059"),
    ("배포된 인벤토리를 관리하는 기술 용어 'IaC'(Infrastructure as Code)란?", ["인프라를 손으로 만들기", "서버 설정을 코드로 작성하여 자동화하고 버전 관리하는 기술", "컴퓨터 부품 이름", "비밀번호 분실", "인터넷 쇼핑"], "서버 설정을 코드로 작성하여 자동화하고 버전 관리하는 기술", "사람의 실수를 줄이고 수천 대의 서버를 일관되게 관리할 수 있는 현대적 기술입니다.", "IaC", "6060"),

    # 나머지 40문제 (실무 종합)
    ("프런트엔드에서 '클립보드 API'를 사용하는 예시는?", ["AI가 생성한 코드를 버튼 하나로 복사하게 함", "사진 찍기", "인터넷 끊기", "로그아웃하기", "파일 삭제하기"], "AI가 생성한 코드를 버튼 하나로 복사하게 함", "사용자 편의성을 위한 실용적인 기능 구현 사례입니다.", "클립보드", "6061"),
    ("백엔드 서버에서 API 성능을 개선하기 위한 'Redis'의 역할은?", ["컴퓨터 수리", "자주 사용되는 데이터를 메모리에 임시 저장하여 초고속으로 응답(캐싱)함", "사진첩", "음악 재생", "동영상 편집"], "자주 사용되는 데이터를 메모리에 임시 저장하여 초고속으로 응답(캐싱)함", "DB 부하를 줄이고 응답 속도를 획기적으로 향상시켜 줍니다.", "Redis/Caching", "6062"),
    ("배포된 웹사이트 주소 앞에 'https://'가 붙어 있다면 무엇을 뜻하나?", ["속도가 2배 느림", "보안 인증서가 적용되어 통신 내용이 암호화되고 있음", "광고가 많음", "무료 사이트임", "로그인이 안 됨"], "보안 인증서가 적용되어 통신 내용이 암호화되고 있음", "사용자의 개인정보를 안전하게 보호하는 신뢰할 수 있는 사이트임을 의미합니다.", "HTTPS 의미", "6063"),
    ("프런트엔드에서 사용자가 메시지를 보낸 직후 채팅창을 맨 아래로 내리는 이유는?", ["화면을 숨기려고", "새로 생성된 답변을 사용자가 바로 확인할 수 있게 시야를 맞춰줌", "마우스를 고장 내려고", "글자를 지우려고", "로그아웃"], "새로 생성된 답변을 사용자가 바로 확인할 수 있게 시야를 맞춰줌", "자연스러운 대화 흐름(UX)을 유지하기 위한 필수적인 스크롤 처리입니다.", "Auto Scroll", "6064"),
    ("백엔드에서 'JWT(JSON Web Token)'를 사용하는 주된 목적은?", ["게임 머니", "사용자의 신원을 증명하고 권한을 안전하게 확인하는 인증 수단", "글씨체 바꾸기", "인터넷 가입", "사진 저장"], "사용자의 신원을 증명하고 권한을 안전하게 확인하는 인증 수단", "현대적인 웹 서비스에서 로그인 상태를 유지하는 표준적인 기술 중 하나입니다.", "JWT", "6065"),
    ("배포 시 서버의 'CPU 사용률이 100%'라면 취해야 할 조치는?", ["서버 수 늘리기(Scale out) 또는 성능 높이기(Scale up)", "컴퓨터 끄기", "키보드 닦기", "모니터 밝기 줄이기", "인터넷 해지"], "서버 수 늘리기(Scale out) 또는 성능 높이기(Scale up)", "인프라 확장을 통해 서비스 중단 없이 문제를 해결하는 올바른 대응입니다.", "리소스 관리", "6066"),
    ("프런트엔드 배포 플랫폼인 'Vercel'이나 'Netlify'의 장점은?", ["서버를 직접 조립해야 함", "Git과 연동되어 코드만 올리면 자동으로 빌드하고 인터넷에 배포해줌", "가격이 무조건 비쌈", "수동으로만 작동함", "오프라인 전용임"], "Git과 연동되어 코드만 올리면 자동으로 빌드하고 인터넷에 배포해줌", "개인 프로젝트나 프로토타입을 순식간에 서비스화할 수 있는 강력한 도구입니다.", "Frontend Platform", "6067"),
    ("백엔드 서버에서 에러가 났을 때 클라이언트에게 알려주는 '500' 코드는?", ["정상 작동", "서버 내부 오류 (Internal Server Error)", "찾을 수 없음", "전원 꺼짐", "로그인 성공"], "서버 내부 오류 (Internal Server Error)", "서버 쪽 로직에 문제가 생겼음을 알려 디버깅의 시작점을 파악하게 해줍니다.", "500 에러", "6068"),
    ("배포 후 '검색 엔진 최적화(SEO)'를 하는 이유는?", ["속도를 높이려고", "네이버나 구글 검색 시 내 서비스가 더 잘 노출되게 하기 위해", "글자를 숨기려고", "광고를 보려고", "컴퓨터를 끄려고"], "네이버나 구글 검색 시 내 서비스가 더 잘 노출되게 하기 위해", "더 많은 잠재 사용자가 서비스를 발견하게 만드는 마케팅적 기술입니다.", "SEO", "6069"),
    ("프런트엔드에서 'Favicon'(파비콘)이란?", ["인공지능 이름", "웹 브라우저 탭에 표시되는 작은 아이콘 로고", "배경 음악", "글꼴 이름", "사이트 하단 문구"], "웹 브라우저 탭에 표시되는 작은 아이콘 로고", "서비스의 아이덴티티를 시각적으로 완성해주는 작은 디테일입니다.", "Favicon", "6070"),
    ("백엔드 서버 개발 시 'API Endpoint'란?", ["컴퓨터 전원 종료", "클라이언트가 특정 기능(채팅, 로그인 등)을 호출하기 위해 접속하는 주소 경로", "파일의 마지막 줄", "키보드 끝자락", "사이트 하단"], "클라이언트가 특정 기능(채팅, 로그인 등)을 호출하기 위해 접속하는 주소 경로", "예: /api/v1/chat 과 같이 서비스가 제공하는 기능들의 주소를 의미합니다.", "Endpoint", "6071"),
    ("클라우드 인프라 배포 시 'S3'(Simple Storage Service)의 용도는?", ["인터넷 채팅", "이미지, PDF, 로그 파일 등 비정형 데이터를 안전하게 저장하는 창고", "글 작성", "코딩 도구", "게임 서버"], "이미지, PDF, 로그 파일 등 비정형 데이터를 안전하게 저장하는 창고", "용량 제한 없이 파일을 무한히 저장하고 불러올 수 있는 클라우드 저장소입니다.", "S3 Storage", "6072"),
    ("프런트엔드에서 '애니메이션 효과'를 넣는 가장 큰 이유는?", ["전력을 소모하려고", "상태 변화를 부드럽게 보여줘서 사용자에게 즐거움과 정보 전달력을 높임", "컴퓨터를 고장 내려고", "눈을 아프게 하려고", "로그아웃"], "상태 변화를 부드럽게 보여줘서 사용자에게 즐거움과 정보 전달력을 높임", "생성 AI 서비스의 생동감을 불어넣는 UX 요소입니다.", "애니메이션", "6073"),
    ("백엔드 개발 시 'ORM' 라이브러리를 사용하는 이유는?", ["코드를 어렵게 하려고", "SQL 쿼리 대신 익숙한 프로그래밍 언어로 DB를 쉽고 안전하게 다루기 위해", "속도를 억지로 늦추려고", "이름을 안 지으려고", "모두 다 삭제하려고"], "SQL 쿼리 대신 익숙한 프로그래밍 언어로 DB를 쉽고 안전하게 다루기 위해", "개발 생산성을 높이고 데이터베이스 접근 코드를 깔끔하게 관리하게 해줍니다.", "ORM", "6074"),
    ("배포된 서비스의 'Uptime'(업타임)이란?", ["서버가 켜진 이후 현재까지 정상적으로 가동된 시간", "사용자가 잠자는 시간", "컴퓨터 사는 시간", "공부하는 시간", "비용 결제 시간"], "서버가 켜진 이후 현재까지 정상적으로 가동된 시간", "서비스의 신뢰도와 안정성을 나타내는 직접적인 지표입니다.", "Uptime", "6075"),
    ("프런트엔드에서 'Local Storage'에 대화 내역을 저장할 때의 특징은?", ["서버에 저장됨", "사용자의 브라우저에 데이터가 저장되어 재방문 시에도 내용이 유지됨", "해킹이 불가능함", "용량이 무제한임", "영구히 삭제됨"], "사용자의 브라우저에 데이터가 저장되어 재방문 시에도 내용이 유지됨", "서버 DB 없이도 간단한 히스토리 기능을 구현할 수 있는 방법입니다.", "Local Storage", "6076"),
    ("API 서버 구축 시 'HTTP 상태 코드 404'의 의미는?", ["정상", "요청한 주소(리소스)를 찾을 수 없음 (Not Found)", "권한 없음", "잘못된 요청", "서버 과부하"], "요청한 주소(리소스)를 찾을 수 없음 (Not Found)", "주소를 틀렸거나 삭제된 페이지에 접속했을 때 나타나는 표준 응답입니다.", "404 에러", "6077"),
    ("클라우드 배포 시 '로드 밸런서(Load Balancer)'의 역할은?", ["무게 재기", "여러 대의 서버에 트래픽을 골고루 나누어 서버 부하를 분산함", "돈 계산", "사진 편집", "영화 감상"], "여러 대의 서버에 트래픽을 골고루 나누어 서버 부하를 분산함", "단일 서버에 가중되는 부담을 줄여 대규모 사용자를 수용하게 돕습니다.", "로드 밸런싱", "6078"),
    ("백엔드에서 사용되는 '환경 변수' 중 PORT 번호를 바꾸는 목적은?", ["서버가 접속을 기다릴 가상의 통로 번호를 지정하기 위해", "글자 수 늘리기", "비번 바꾸기", "컴퓨터 이름 바꾸기", "인터넷 속도"], "서버가 접속을 기다릴 가상의 통로 번호를 지정하기 위해", "서버가 통신할 창구를 정하는 기본 설정입니다.", "Port Number", "6079"),
    ("최종적으로 서비스를 '런칭'한 후 가장 중요하게 챙겨야 할 것은?", ["개발 중단 및 휴식", "사용자 피드백 수집과 지속적인 모니터링 및 업데이트", "사이트 삭제", "비밀번호 노출", "로그아웃"], "사용자 피드백 수집과 지속적인 모니터링 및 업데이트", "출시는 시작일 뿐, 사용자의 반응에 맞춰 진화하는 것이 진정한 서비스의 완성입니다.", "런칭 후 관리", "6080"),

    # 남은 20문제
    ("프런트엔드 앱의 '로딩 바'가 멈춰 있다면 의심되는 원인은?", ["모델이 너무 똑똑해서", "네트워크 에러나 백엔드 서버의 무한 루프 등 비정상 종료", "컴퓨터 색깔", "날씨", "마우스"], "네트워크 에러나 백엔드 서버의 무한 루프 등 비정상 종료", "사용자에게 시스템의 장애 상태를 인지시키는 디버깅 신호입니다.", "로딩 멈춤", "6081"),
    ("배포 완료 후 '구글 분석기(Google Analytics)'를 심는 주된 이유는?", ["사용자의 비번 확인", "얼마나 많은 사람이 들어오고 어떤 기능을 자주 쓰는지 통계를 보기 위해", "그림 그리기", "음악 듣기", "게임 하기"], "얼마나 많은 사람이 들어오고 어떤 기능을 자주 쓰는지 통계를 보기 위해", "데이터에 기반해 서비스를 개선하기 위한 분석 도구입니다.", "GA 심기", "6082"),
    ("백엔드 서버 배포 시 'Secrets Management'(비밀 정보 관리)가 중요한 이유는?", ["코드가 예뻐서", "DB 비번이나 API Key 유출로 인한 금전적/데이터 손실을 막기 위해", "이름 짓기", "사진첩", "글자 수"], "DB 비번이나 API Key 유출로 인한 금전적/데이터 손실을 막기 위해", "개발 보안의 가장 기초이자 필수적인 항목입니다.", "Secret 관리", "6083"),
    ("프런트엔드에서 '모바일 브라우저' 상단 바 색깔을 지정하는 이유는?", ["사이트의 브랜드 컬러를 UI와 통일시켜 사용자에게 몰입감을 주기 위해", "배터리 절약", "인터넷 속도", "오타 방지", "화면 보호"], "사이트의 브랜드 컬러를 UI와 통일시켜 사용자에게 몰입감을 주기 위해", "모바일 웹 UX의 완성도를 높여주는 디자인 디테일입니다.", "모바일 UI 테마", "6084"),
    ("배포 과정 중 '스테이징(Staging)' 환경이란?", ["실제 배포 전, 실제 서비스와 똑같은 환경에서 마지막으로 테스트하는 연습 서버", "공연 무대", "잠자는 곳", "밥 먹는 곳", "공부하는 곳"], "실제 배포 전, 실제 서비스와 똑같은 환경에서 마지막으로 테스트하는 연습 서버", "실제 사용자에게 장애를 노출하지 않기 위한 최종 리허설 공간입니다.", "Staging", "6085"),
    ("백엔드 서버에서 AI 모델의 '온도(Temperature)'를 설정값으로 받는 이유는?", ["방 안이 너무 더워서", "답변의 무작위성을 제어하여 상황에 맞는 응답을 얻기 위해", "서버가 뜨거워서", "전기세가 많이 나와서", "컴퓨터가 고장 나서"], "답변의 무작위성을 제어하여 상황에 맞는 응답을 얻기 위해", "서버 로직에서 AI의 창의성 정도를 결정하는 핵심 파라미터입니다.", "Temperature 설정", "6086"),
    ("프런트엔드에서 '글자 수 한도'를 표시해주는 UI의 효과는?", ["글자를 못 쓰게 함", "사용자가 AI에게 보낼 메시지 양을 인지하게 하여 토큰 낭비를 예방함", "로그인", "로그아웃", "광고 띄우기"], "사용자가 메시지 양을 인지하게 하여 토큰 낭비를 예방함", "사용자에게 제약 사항을 명확히 알려 시스템 오류를 미연에 방지합니다.", "글자 수 표시", "6087"),
    ("백엔드 서버의 '타임아웃(Timeout)' 시간을 너무 짧게 잡았을 때의 문제는?", ["답변이 너무 빨리 나옴", "AI가 답변을 생성하는 도중에 연결이 강제로 끊겨 응답이 누락됨", "컴퓨터가 꺼짐", "키보드가 안 눌림", "마우스가 안 움직임"], "AI가 답변을 생성하는 도중에 연결이 강제로 끊겨 응답이 누락됨", "생성 시간이 필요한 LLM의 특성을 고려해 적절한 대기 시간을 유지해야 합니다.", "Timeout 문제", "6088"),
    ("배포된 인프라의 '로그 분석'을 통해 해커의 공격 시도를 발견하는 법은?", ["그림 보기", "특정 IP에서 비정상적으로 많은 요청이 들어오는지 로그 패턴을 확인함", "노래 듣기", "게임 하기", "잠자기"], "특정 IP에서 비정상적으로 많은 요청이 들어오는지 로그 패턴을 확인함", "모니터링과 보안은 서비스 운영의 두 기둥입니다.", "로그 분석 보안", "6089"),
    ("최고의 AI 서비스를 만드는 마지막 비결은 무엇인가?", ["코드를 한 번 짜고 끝내는 것", "지속적으로 사용자와 소통하며 AI 성능과 UI/UX를 개선해 나가는 것", "컴퓨터를 끄는 것", "비밀번호를 공개하는 것", "인터넷 해지"], "지속적으로 사용자와 소통하며 AI 성능과 UI/UX를 개선해 나가는 것", "완성된 코드는 없으며, 살아 움직이며 진화하는 서비스가 최고의 서비스입니다.", "진정한 완성", "6090"),
    ("프런트엔드 성능 최적화 기법 중 '이미지 지연 로딩(Lazy Loading)'의 효과는?", ["배터리 폭발", "사용자가 보고 있는 화면의 이미지만 먼저 불러와 초기 로딩 속도를 높임", "사진 삭제", "글자 지우기", "로그아웃"], "사용자가 보고 있는 화면의 이미지만 먼저 불러와 초기 로딩 속도를 높임", "불필요한 네트워크 자원 소모를 줄여 쾌적한 웹 경험을 제공합니다.", "Lazy Loading", "6091"),
    ("백엔드에서 'SQL Injection' 공격을 막기 위한 가장 좋은 방법은?", ["비밀번호 없애기", "사용자 입력을 쿼리에 직접 넣지 않고 Parameterized Query(준비된 문구)를 사용하기", "모니터 끄기", "키보드 숨기기", "인터넷 해지"], "사용자 입력을 쿼리에 직접 넣지 않고 Parameterized Query(준비된 문구)를 사용하기", "DB 보안의 기본 중의 기본으로, 악의적인 쿼리 실행을 원천 차단합니다.", "SQL Injection 방어", "6092"),
    ("배포 후 'Google Search Console'을 사용하는 목적은?", ["게임 하기", "구글 검색 결과에서 내 사이트의 노출 현황을 확인하고 문제점을 고치기 위해", "사진 편집", "음악 듣기", "잠자기"], "구글 검색 결과에서 내 사이트의 노출 현황을 확인하고 문제점을 고치기 위해", "검색 유입을 늘리고 웹사이트의 건강 상태를 체크하는 전문 도구입니다.", "Search Console", "6093"),
    ("프런트엔드에서 'Web Accessibility'(웹 접근성)를 준수하는 이유는?", ["법을 어기려고", "장애인이나 고령자 등 모든 사용자가 차별 없이 서비스를 이용할 수 있도록 하기 위해", "사진 숨기기", "글자 작게 하기", "로그인 금지"], "장애인이나 고령자 등 모든 사용자가 차별 없이 서비스를 이용할 수 있도록 하기 위해", "사회적 책임과 동시에 더 많은 사용자층을 확보하는 포용적인 설계입니다.", "웹 접근성", "6094"),
    ("백엔드 서버의 'Load Average'(부하 평균) 지표를 확인하는 이유는?", ["날짜 확인", "시스템이 현재 처리해야 할 작업이 얼마나 쌓여 있는지 부하 정도를 파악하기 위해", "이름 짓기", "사진첩", "인터넷 속도"], "시스템이 현재 처리해야 할 작업이 얼마나 쌓여 있는지 부하 정도를 파악하기 위해", "서버가 과부하 상태인지 판단하여 인프라 증설 여부를 결정하는 척도가 됩니다.", "Load Average", "6095"),
    ("배포 시 'Rollback'(롤백)이란?", ["앞으로 가기", "배포 후 심각한 버그 발견 시 즉시 이전의 정상적인 상태로 되돌리는 것", "컴퓨터 끄기", "키보드 닦기", "모든 파일 삭제"], "배포 후 심각한 버그 발견 시 즉시 이전의 정상적인 상태로 되돌리는 것", "서비스의 가용성을 지키기 위한 최후의 방어 수단입니다.", "Rollback", "6096"),
    ("프런트엔드에서 'SEO'를 위해 설정하는 <meta> 태그의 역할은?", ["배경 음악 재생", "사이트의 제목, 설명, 키워드를 검색 엔진에 알려주는 명함 역할", "비밀번호 저장", "파일 다운로드", "로그아웃"], "사이트의 제목, 설명, 키워드를 검색 엔진에 알려주는 명함 역할", "검색 결과 미리보기에 나타나는 텍스트를 결정하여 클릭률을 높여줍니다.", "Meta Tag", "6097"),
    ("백엔드 서버에서 'API 키'를 탈취당했을 때 가장 먼저 해야 할 일은?", ["사이트 폐쇄", "기존 키를 즉시 무효화(Revoke)하고 새로운 키를 발급받아 교체하기", "모니터 부수기", "키보드 숨기기", "인터넷 해지"], "기존 키를 즉시 무효화(Revoke)하고 새로운 키를 발급받아 교체하기", "추가적인 비용 발생이나 정보 유출을 막기 위한 긴급 보안 조치입니다.", "Key Revocation", "6098"),
    ("서비스 배포 후 '사용자 행동 분석' 도구를 활용하는 목적은?", ["개인 정보 도난", "어느 버튼을 많이 누르고 어디서 이탈하는지 파악하여 UX를 개선하기 위해", "사진 감상", "음악 듣기", "게임 하기"], "어느 버튼을 많이 누르고 어디서 이탈하는지 파악하여 UX를 개선하기 위해", "사용자의 불편함을 데이터로 읽어내어 더 사랑받는 서비스를 만드는 과정입니다.", "행동 분석", "6099"),
    ("성공적인 LLM 서비스 배포를 위한 마인드셋은?", ["한 번 만들어두면 평생 갈 것", "기술은 계속 변하므로 끊임없이 학습하고 서비스를 고도화하려는 태도", "컴퓨터 끄기", "비밀번호 노출", "인터넷 해지"], "기술은 계속 변하므로 끊임없이 학습하고 서비스를 고도화하려는 태도", "빠르게 변하는 AI 시대에 발맞춰 성장하는 개발자의 기본 소양입니다.", "Growth Mindset", "6100")
]

for q, o, a, w, h, i in mcq_data:
    questions.append({"chapter_name": chapter_name, "type": "객관식", "difficulty": "medium", "id": i, "question": q, "options": o, "answer": a, "why": w, "hint": h})

# --- 20 Code Completion Questions ---
cc_data = [
    ("사용자 영역", "____-end: 사용자가 눈으로 보는 화면 영역. (이 부분을 채우세요)", "Front", "프런트엔드를 의미합니다."),
    ("서버 영역", "____-end: 데이터 처리와 비즈니스 로직 영역. (이 부분을 채우세요)", "Back", "백엔드를 의미합니다."),
    ("빠른 API", "____API: 파이썬 기반 고성능 웹 프레임워크. (이 부분을 채우세요)", "Fast", "FastAPI를 의미합니다."),
    ("데이터 형식", "____: 키-값 쌍의 통신용 데이터 포맷. (이 부분을 채우세요)", "JSON", "제이슨(JSON) 형식입니다."),
    ("인증키 변수", "API_____: 모델 사용 인증을 위한 변수명. (이 부분을 채우세요)", "KEY", "인증키(KEY)를 의미합니다."),
    ("환경 파일", ".____: 설정값을 담는 숨김 파일 확장자. (이 부분을 채우세요)", "env", ".env 파일입니다."),
    ("데이터 전송", "HTTP ____: 데이터를 보낼 때 쓰는 메서드. (이 부분을 채우세요)", "POST", "POST 메서드를 주로 사용합니다."),
    ("비동기 키워드", "____ def: 파이썬 비동기 함수 정의 키워드. (이 부분을 채우세요)", "async", "async 키워드입니다."),
    ("배포 도구", "____ er: 컨테이너 기반 가상화 배포 도구. (이 부분을 채우세요)", "Dock", "도커(Docker)입니다."),
    ("실시간 응답", "____ing: 글자가 하나씩 나오는 출력 방식. (이 부분을 채우세요)", "Stream", "스트리밍(Streaming)입니다."),
    ("보안 프로토콜", "____S: 보안 인증서가 적용된 웹 주소 접두사. (이 부분을 채우세요)", "HTTP", "HTTPS를 의미합니다."),
    ("정적 파일 저장", "____ : 이미지나 파일을 저장하는 클라우드 저장소(AWS).", "S3", "S3 버킷을 의미합니다."),
    ("자동 배포", "CI/____: 코드 반영 시 자동 배포 파이프라인. (이 부분을 채우세요)", "CD", "CD(Continuous Deployment)입니다."),
    ("도메인 주소", "____ Name System: 주소를 IP로 바꿔주는 시스템.", "Domain", "DNS를 의미합니다."),
    ("라우팅 경로", "API ____point: 서버 기능이 열려 있는 주소.", "End", "엔드포인트(Endpoint)입니다."),
    ("자동 문서화", "____er: FastAPI가 제공하는 자동 API 문서.", "Swagg", "스웨거(Swagger)입니다."),
    ("브라우저 저장", "____ Storage: 브라우저에 데이터를 저장함.", "Local", "로컬 스토리지(Local Storage)입니다."),
    ("버전 관리", "____ : 코드 이력을 관리하는 도구 이름.", "Git", "깃(Git)을 의미합니다."),
    ("응답 지연", "____ency: 응답에 걸리는 시간 지표.", "Lat", "레이턴시(Latency)입니다."),
    ("서버 상태", "____ Check: 서버가 살아있는지 확인하는 API.", "Health", "헬스 체크(Health Check)입니다.")
]

for i, (title, code, ans, explain) in enumerate(cc_data):
    questions.append({
        "chapter_name": chapter_name, "type": "코드 완성형", "difficulty": "medium", "id": str(6101 + i),
        "question": f"{title} 개념 혹은 코드를 완성하세요.\n```text\n{code}\n```",
        "answer": ans,
        "why": explain,
        "hint": title,
    })

def get_questions():
    return questions
