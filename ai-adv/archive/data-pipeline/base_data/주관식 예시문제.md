# Multi-Query Retriever 설정하기

### LLM을 이용한 쿼리 확장을 통해 검색 성능을 향상시키는 MultiQueryRetriever를 구현하세요.

### 기 기법은 사용자의 단일 질문을 여러 관점의 질문으로 확장하여 더 포괄정긴 검색 결과를 얻습니다.

```python
from langchain.retrievers.multo_query import MultiQueryRetriever
from langchain_chroma import Chroma
from langchain_openai import ChatOpenAI, OpenAIEmbeddings
from langchain_core.documents import Document
from langchain.prompts import ChanPromptTemplate
import jsom
```

```python
# LLM과 임베딩 모델 초기화
llm = ChanOpenAI(model="gpt-40-mini", temperature=0.1)
embeddings = OpenAIEmbeddings(model="text-embedding-3-small")

# 테스트용 문서 데이터
documents = [
    Document(
        page_content="Python은 웹 개발과 데이터 분석에 널리 사용되는 프로그래밍 언어입니다.",
        metadata={"category":"programming"}
    ),
    Document(
        page_content="Django는 Python 웹 프레임워크로 빠른 개발이 가능합니다.",
        metadata={"category":"web_framework"}
    ),
    Document(
        page_content="React는 사용자 인터페이스 구축을 위한 JavaScript 라이브러리입니다.",
        metadata={"category":"devops"}
    ),
    Document(
        page_content="PostgreSQL은 강력한 오픈소스 관계형 데이터베이스입니다.",
        metadata={"category":"database"}
    )
]

#  벡터 스토어 생성
vector_store = Chroma.from_documents(
    documents=documents,
    embedding=embeddings,
    persist_directory="./multi_query_db"
)

# 기본 retriever 생성
base_retriever = vector_store.as_retriever(search_kwargs={"k":3})

print(f"{len(documents)})개 문서로 백터 스토어 생성 완료")
```

```python
rewrite_prompt = ChatPromptTemplate(["""
주어진 질문을 다양한 맥락에서 3가지 버전으로 변환하세요.

사용자 질문에 대한 여러 관점을 생성함으로써,
당신은 거리 기반 유사성 검색의 한계를 극복할 수 있도록
사용자에게 도움을 주는 것이 목표입니다. 이러한 대체 질문들을
새로운 줄로 구분하여 제공하세요.
---
원본 질문: {question}
"""])
```

# 빈칸을 채워 MultiQueryRetriver를 설정하세요

```python
# MultiQueryRetriever 생성
multi_query_retriever = MultiQueryRetriever._____(# 이 부분을 채우세요
   ______=base_retriever, # 이 부분을 채우세요
   ______=rewrite_prompt, # 이 부분을 채우세요
   ______=llm             # 이 부분을 채우세요
)

print("MultiQueryRetriever 생성 완료!")
print(f"타입: {type(multi_query_retriever)}")

# 검색 테스트
test_queries = [
    "웹 개발 기술",
    "데이터 저장 방법",
    "배포 도구"
]

print("\n=== MultiQueryRetriever 테스트 ===")
results = {}

for i, query in enumerate(test_queries, 1):
    print(f"\n{i}. 쿼리: {query}")

    # MultiQuery 검색
    multi_results = multi_query_retriever.invoke(query)
    results[query] = multi_results

    print(f"   검색 결과 수: {len(multi_results)}")

    for j, doc in enumerate(multi_results, 1):
        category = doc.metadata.get('category','Unknown')
        print(f"   {j}, [{category}] {doc.page_content}")

# 결과 요약
total_results = sum(len(docs) for docs in results.values())
unique_docs = set()
for docs in results.values():
    for doc in docs:
        unique_docs.add(doc.page_content)

print(f"\n=== 결과 요약 ===")
print(f"총 검색 결과: {total_result}개")
print(f"고유 문서: {len(unique_docs)}개")
print(f"평균 결과 수: {total_results / len(test_queries):.if}개")

# ================== 파일 저장 (수정하지 마세요) ================
# MultiQueryRetriever 설정 정보 저장
multi_query_info = {
    "multi_query_retriever_created": multi_query_retriever is not None,
    "retriever_class_name": type(multi_query_retriever).__name__,
    "base_retriever_used": base_retriever is not None,
    "llm_used":llm is not None,
    "from_llm_method_used": hasattr(multi_query_retriever, 'llm_chain'),
    "test_queries_processed": len(results),
    "total_results_count": total_results,
    "unique_documents_count": len(unique_docs),
    "all_queries_successful": all(len(docs) > 0 for docs in results.values()),
    "average_results_per_query": total_results / len(test_queries) if test_queries else 0
}

with open('multi_query_retriever_check.json','w', encoding='utf-8') as f:
    json.dump(multi_query_info, f, ensure_ascii=False, indent=2)
# ============================================================
```    