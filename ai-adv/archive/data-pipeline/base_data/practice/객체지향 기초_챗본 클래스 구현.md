# [실습] 객체지향 기초 - 챗봇 클래스 구현

## 학습목표
- 클래스와 객체의 개념을 이해할 수 있다
- 생성자와 메서드를 정의하고 사용할 수 있다
- 상속, 다형성의 기본 개념을 이해할 수 있다
- 실용적인 챗봇 클래스를 설계하고 구현할 수 있다

객체지향 프로그래밍(OOP)은 현실 세계의 사물을 모델링하여 프로그램을 작성하는 패러다임입니다.   
주로 클래스와 객체를 통해 구성합니다.

## 클래스와 객체 정의

간단한 클래스를 만들어 보겠습니다.
class Person:
    """사람을 나타내는 기본 클래스"""
    
    def __init__(self, name: str, age: int):
        """생성자 메서드"""
        # 생성자는 객체가 생성될 때 자동으로 호출되는 메서드입니다.
        # 이 메서드는 객체의 속성을 초기화하는 역할을 합니다.
        self.name = name
        self.age = age
    
    def introduce(self) -> str:
        """자기소개 메서드"""
        return f"안녕하세요, 저는 {self.name}이고 {self.age}세입니다."
    
    def get_older(self):
        """나이를 1살 증가시키는 메서드"""
        self.age += 1
        print(f"{self.name}의 나이가 {self.age}세가 되었습니다.")
클래스는 이름을 통해 간단하게 생성할 수 있습니다.   
이 때, 클래스의 생성자를 통해 값을 부여할 수 있습니다.
# 객체 생성과 사용
person1 = Person("김철수", 25)
person2 = Person("이영희", 30)
클래스에 저장된 메서드(method)를 호출합니다.
print(person1.introduce())
print(person2.introduce())
메서드에서 수정된 값은 클래스에 반영됩니다.
person1.get_older()
print(person1.introduce())
클래스에는 두 가지 방식으로 변수를 정의할 수 있습니다.   
전역적으로 설정하는 클래스 변수는 모든 인스턴스가 공유하는 변수이고,    
인스턴스 변수는 각 객체마다 고유한 변수입니다.
class Counter:
    """카운터 클래스 - 클래스 변수와 인스턴스 변수 예제"""
    
    total_count = 0  # 클래스 변수 - 모든 인스턴스가 공유
    
    def __init__(self, name: str):
        self.name = name  # 인스턴스 변수
        self.count = 0    # 인스턴스 변수
        Counter.total_count += 1  # 클래스 변수 증가
    
    def increment(self):
        """개별 카운터 증가"""
        self.count += 1
    
    def get_info(self) -> str:
        return f"{self.name}: {self.count}, 전체 카운터 수: {Counter.total_count}"

# 여러 카운터 생성
counter1 = Counter("첫번째 카운터")
counter2 = Counter("두번째 카운터")
print(counter1.get_info())
print(counter2.get_info())
# 각각의 카운터 증가
counter1.increment()
counter1.increment()
counter2.increment()

counter3 = Counter('세번째 카운터')

print("카운터 증가 후:")
print(counter1.get_info())
print(counter2.get_info())
## 메서드의 3가지 형태

- 인스턴스 메서드는 객체의 상태를 다룰 때 활용합니다.
- 클래스 메서드는 클래스 상태를 변경할 때 주로 활용하며, 대체 생성자 역할을 하기도 합니다.
- 정적 메서드는 클래스 메서드와 유사하나, 클래스 변수에 접근할 수 없는 독립적인 함수입니다.

파이썬에서는 세 가지 종류의 메서드를 사용할 수 있습니다.
class Book:
    def __init__(self, title: str, author: str, year: int):
        self.title = title
        self.author = author
        self.year = int(year)

    @classmethod
    def from_string(cls, book_str: str):
        """'제목-저자-년도' 형태의 문자열에서 Book 생성"""
        title, author, year = book_str.split("-")
        return cls(title, author, int(year))

    @classmethod
    def default(cls):
        """기본 책 생성"""
        return cls("제목 없음", "저자 미상", 0)

    def info(self):
        """포맷 맞춰서 문자열 변환"""
        return f"[{self.year}] {self.title} - {self.author}"
    
    # ✅ 정적 메서드 추가
    @staticmethod
    def is_classic(year: int) -> bool:
        """출판된 지 50년 이상이면 고전으로 판정"""
        from datetime import datetime
        current_year = datetime.now().year
        return (current_year - year) >= 50

    @staticmethod
    def validate_year(year: int) -> bool:
        """연도가 0보다 크고 현재 연도 이하인지 확인"""
        from datetime import datetime
        current_year = datetime.now().year
        return 0 < year <= current_year




b0 = Book(title='Large Language Models', author='Samsung SDS', year=2025)
b1 = Book.from_string("파이썬의정석-홍길동-2024")
b2 = Book.default()

print(b0.info())
print(b1.info())  
print(b2.info())

# 정적 메서드 사용
print(Book.is_classic(1960))   # True (출판된 지 50년 넘음 → 고전)
print(Book.is_classic(2010))   # False
print(Book.validate_year(2024)) # True
print(Book.validate_year(3024)) # False

이제 학습한 내용을 바탕으로 챗봇 클래스를 설계해 보겠습니다.


- Language를 설정할 수 있습니다.
- 채팅을 수행할 때마다 실행 이력과 시간을 메모리에 저장합니다.   

- 키워드 매칭 기반으로, 인사말은 답변하지만 그 외의 답변은 이해하지 못합니다.
- 여러 개의 문장 중 랜덤 샘플링하여 답변합니다.
from datetime import datetime
import random
import json

class BasicChatBot:
    """기본 챗봇 클래스"""
    
    def __init__(self, name: str, language: str = "ko"):
        """챗봇 초기화
        
        Args:
            name: 챗봇 이름
            language: 사용 언어 (기본값: 한국어)
        """
        self.name = name
        self.language = language
        self.conversation_history = []
        self.user_count = 0
        
        # 기본 응답 패턴
        self.default_responses = {
            "ko": [
                "죄송하지만 이해하지 못했습니다.",
                "다시 한번 말씀해 주시겠어요?",
                "좀 더 구체적으로 말씀해 주세요.",
                "잘 모르겠습니다. 다른 질문을 해보세요."
            ],
            "en": [
                "I'm sorry, I didn't understand that.",
                "Could you please rephrase that?",
                "I'm not sure what you mean.",
                "Can you ask something else?"
            ]
        }
        
        # 인사 패턴
        self.greetings = {
            "ko": ["안녕", "안녕하세요", "하이", "헬로", "반가워"],
            "en": ["hello", "hi", "hey", "good morning", "good afternoon"]
        }
        
        self.greeting_responses = {
            "ko": f"안녕하세요! 저는 {self.name}입니다. 무엇을 도와드릴까요?",
            "en": f"Hello! I'm {self.name}. How can I help you?"
        }
    
    def _add_to_history(self, user_input: str, bot_response: str):
        """대화 기록 추가"""
        self.conversation_history.append({
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'user': user_input,
            'bot': bot_response
        })
    
    def _is_greeting(self, text: str) -> bool:
        """인사말인지 확인"""
        text_lower = text.lower().strip()
        greetings = self.greetings.get(self.language, [])
        return any(greeting in text_lower for greeting in greetings)
    
    def _get_default_response(self):
        """기본 응답 반환"""
        responses = self.default_responses.get(self.language, self.default_responses["ko"])
        return random.choice(responses)
    
    def chat(self, user_input: str):
        """사용자 입력에 대한 응답 생성
        
        Args:
            user_input: 사용자 입력
        
        Returns:
            챗봇 응답
        """
        if not user_input.strip():
            response = "메시지를 입력해 주세요."
        elif self._is_greeting(user_input):
            response = self.greeting_responses.get(self.language, self.greeting_responses["ko"])
        else:
            response = self._get_default_response()
        
        # 대화 기록에 추가
        self._add_to_history(user_input, response)
        return response
    
    def get_stats(self):
        """챗봇 통계 정보 반환"""
        return {
            'name': self.name,
            'language': self.language,
            'total_conversations': len(self.conversation_history),
            'user_count': self.user_count
        }
    
    def get_conversation_history(self, last_n: int = None):
        """대화 기록 반환"""
        if last_n is None:
            return self.conversation_history
        return self.conversation_history[-last_n:]
    
    def clear_history(self):
        """대화 기록 초기화"""
        self.conversation_history = []
        print("대화 기록이 초기화되었습니다.")

# 기본 챗봇 테스트
bot = BasicChatBot("안녕로봇", "ko")

# 대화 테스트
test_inputs = ["안녕하세요", '하이', "오늘 날씨가 어때요?", "고마워요", ""]

for user_input in test_inputs:
    response = bot.chat(user_input)
    print(f"사용자: {user_input}")
    print(f"봇: {response}")
    print("-" * 40)

# # 통계 정보 출력
# print("\n챗봇 통계:")
# stats = bot.get_stats()
# for key, value in stats.items():
#     print(f"{key}: {value}")
bot.clear_history()
bot.conversation_history
## JSON 규칙 파일 활용하기

JSON 파일에서 챗봇 규칙을 로드하여 더 정교한 응답을 생성해보겠습니다.

해당 규칙의 내용은 아래와 같습니다.   

- 다양한 카테고리별 키워드를 바탕으로 질문을 매칭합니다.   
- 각 카테고리의 우선순위가 `priority`로 주어집니다.
- 결제(1), 배송(2), 계정(3), 상품(4)의 우선순위를 갖습니다.
- 문제에 따라 관련 responses를 전달합니다.

RULES_FILE = 'rules.json'

# 규칙 파일 내용 확인
try:
    with open(RULES_FILE, 'r', encoding='utf-8') as f:
        rules_data = json.load(f)
    
    print("규칙 파일 내용:")
    print(json.dumps(rules_data, ensure_ascii=False, indent=2))
    
except FileNotFoundError:
    print(f"규칙 파일을 찾을 수 없습니다: {RULES_FILE}")
    # 기본 규칙 생성
    rules_data = {
        "categories": {
            "인사": {
                "keywords": ["안녕", "하이", "hello", "hi"],
                "priority": 1,
                "responses": [
                    "안녕하세요! 무엇을 도와드릴까요?",
                    "반갑습니다! 궁금한 것이 있으시면 말씀하세요."
                ]
            },
            "날씨": {
                "keywords": ["날씨", "기온", "비", "맑음", "흐림"],
                "priority": 2,
                "responses": [
                    "죄송하지만 실시간 날씨 정보는 제공할 수 없습니다.",
                    "날씨 정보는 기상청 앱을 확인해 주세요."
                ]
            }
        }
    }
    print("기본 규칙을 사용합니다.")
### 상속과 다형성

클래스는 기존의 클래스를 상속할 수 있습니다.  
이 때, 두 클래스 사이의 관계를 Parent-Child로 표현합니다.  


Child는 메서드를 정의하지 않아도 Parent 클래스의 메서드를 그대로 사용할 수 있습니다. 
- 같은 이름의 메서드를 불러오면 오버라이딩(Override)이 되어 새로 정의하게 됩니다.
- 부모 메서드의 기능을 호출할 때에는 `super()`를 사용합니다.
- 부모 클래스의 생성자를 정의할 때에는 `super().__init__()`를 사용합니다.  

RuleBasedChatBot은 기존 클래스의 값들을 모두 가져옵니다.   

기존의 인사말 패턴과 메모리 등의 기능을 그대로 상속하나,  
새로운 규칙을 반영하기 위해 Chat 메서드를 Override 하겠습니다.
class RuleBasedChatBot(BasicChatBot):
    """규칙 기반 챗봇 클래스 - BasicChatBot을 상속"""
    # 부모 클래스의 기능을 그대로 포함
    
    def __init__(self, name: str, rules_file: str = None, language: str = "ko"):
        """규칙 기반 챗봇 초기화
        
        Args:
            name: 챗봇 이름
            rules_file: 규칙 파일 경로
            language: 사용 언어
        """
        super().__init__(name, language)  # 부모 클래스 초기화
        # name, language, conversation_history, user_count 값 등 포함

        
        self.rules = {}
        self.categories = {}
        
        if rules_file:
            self.load_rules(rules_file)
    
    def load_rules(self, rules_file: str):
        """규칙 파일 로드
        
        Args:
            rules_file: 규칙 파일 경로
        """
        try:
            with open(rules_file, 'r', encoding='utf-8') as f:
                self.rules = json.load(f)
            
            # 카테고리별 정보 추출
            self.categories = self.rules.get('categories', {})
            
            print(f"규칙 파일 로드 완료: {len(self.categories)}개 카테고리")
            
        except FileNotFoundError:
            print(f"규칙 파일을 찾을 수 없습니다: {rules_file}")
        except json.JSONDecodeError as e:
            print(f"JSON 파일 형식 오류: {e}")
        except Exception as e:
            print(f"규칙 파일 로드 중 오류 발생: {e}")
    
    def _find_matching_category(self, user_input: str):
        """사용자 입력에 매칭되는 카테고리 찾기
        
        Args:
            user_input: 사용자 입력
        
        Returns:
            매칭된 카테고리명 또는 None
        """
        
        # 카테고리를 우선순위에 따라 정렬
        sorted_categories = sorted(
            self.categories.items(),
            key=lambda x: x[1].get('priority')
        )
        
        for category_name, category_data in sorted_categories:
            keywords = category_data.get('keywords')
            # 각 카테고리별 키워드 매칭 검사
            for keyword in keywords:
                if keyword in user_input:
                    return category_name
        
        return None
    
    def _get_category_response(self, category_name: str) -> str:
        """카테고리에 해당하는 응답 반환
        
        Args:
            category_name: 카테고리명
        
        Returns:
            해당 카테고리의 응답
        """
        category_data = self.categories.get(category_name, {})
        responses = category_data.get('responses', [])
        
        if responses:
            return random.choice(responses)
        else:
            return self._get_default_response()
    
    def chat(self, user_input: str) -> str:
        """사용자 입력에 대한 응답 생성 (오버라이드)
        
        Args:
            user_input: 사용자 입력
        
        Returns:
            챗봇 응답
        """
        if not user_input.strip():
            response = "메시지를 입력해 주세요."
        else:
            # 규칙 기반 매칭 시도
            matching_category = self._find_matching_category(user_input)
            
            if matching_category:
                response = self._get_category_response(matching_category)
                # 매칭된 카테고리 정보를 응답에 포함 (디버그용)
                response += f" [카테고리: {matching_category}]"
            else:
                # 규칙에서 찾지 못한 경우
                # 부모 클래스의 기본 로직 사용 (인사말 등)
                if self._is_greeting(user_input):
                    response = self.greeting_responses.get(self.language, self.greeting_responses["ko"])
                else:
                    response = self._get_default_response()
        
        # 대화 기록에 추가
        self._add_to_history(user_input, response)
        return response
    
    def list_categories(self) -> list[str]:
        """사용 가능한 카테고리 목록 반환"""
        return list(self.categories.keys())
    
    def get_category_info(self, category: str):
        """특정 카테고리 정보 반환"""
        return self.categories.get(category, {})



# 규칙 기반 챗봇 생성 및 테스트
rule_bot = RuleBasedChatBot("규칙봇", RULES_FILE, "ko")

print(f"사용 가능한 카테고리: {rule_bot.list_categories()}")
print("\n" + "="*50)

test_cases = [
    "안녕하세요!",
    "결제가 안돼요",
    "카드 승인이 거부됐어요",
    "환불 요청드려요",
    "오늘 날씨가 어때요?",
    "뭐하고 있어?"
]

for test_input in test_cases:
    response = rule_bot.chat(test_input)
    print(f"사용자: {test_input}")
    print(f"봇: {response}")
    print("-" * 40)
test_cases = [
    "계정 로그인이 안돼.",
    "불량 계정이래.",
    "상품에 치명적인 불량이 있어요."

]

for test_input in test_cases:
    response = rule_bot.chat(test_input)
    print(f"사용자: {test_input}")
    print(f"봇: {response}")
    print("-" * 40)
다음 차시부터는 파이썬을 이용한 다양한 데이터 처리 방법에 대해 알아보도록 하겠습니다.
