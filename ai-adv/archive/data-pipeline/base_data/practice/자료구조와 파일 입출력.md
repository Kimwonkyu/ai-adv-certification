# [실습] 자료구조와 파일 입출력

## 학습목표
- 리스트 컴프리헨션 코드를 이해하고 사용할 수 있다.
- 파일 입출력을 안전하게 처리할 수 있다
- 예외 처리를 통해 견고한 프로그램을 작성할 수 있다
- JSON 데이터를 읽고 쓰고 조작할 수 있다

# 리스트 활용 심화 기능 알아보기

리스트 컴프리헨션은 파이썬의 대표 기능으로, for문 등의 코드를 간결하게 표현합니다.
# 1. 리스트 컴프리헨션 활용
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
texts = ["Python", "java", "JAVASCRIPT", "go", "Rust"]

uct = [text.upper() for text in texts]



# 기본 리스트 컴프리헨션
even_numbers = [x for x in numbers if x % 2 == 0]
squared = [x**2 for x in numbers]
uppercase_texts = [text.upper() for text in texts]

print(f"짝수: {even_numbers}")
print(f"제곱수: {squared}")
print(f"대문자 변환: {uppercase_texts}")
조건문을 추가하거나, 중첩된 리스트를 평면화(Flatten)할 수도 있습니다.

# 조건부 표현식과 함께
processed_texts = [text.upper() if len(text) > 4 else text.lower() for text in texts]
print(f"조건부 처리: {processed_texts}")

# 중첩 리스트 컴프리헨션
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flattened = [item for row in matrix for item in row]
print(f"평면화: {flattened}")
단일 인덱스를 선택하는 인덱싱과, 특정 범위를 전달하는 슬라이싱을 활용할 수 있습니다.
data = ["apple", "banana", "cherry", "date", "elderberry"]

# 슬라이싱 고급 활용
print(f"원본: {data}")
print(f"첫 번째 원소: {data[0]}")
print(f"마지막 원소: {data[-1]}")



print(f"역순: {data[::-1]}")
# 시작점:끝점:간격
# 각 위치를 생략하면 알아서 넣어줌
print(f"홀수 인덱스: {data[1::2]}")
print(f"뒤에서 3개: {data[-3:]}")
키워드 기반 분류 예시 코드를 보겠습니다.
# 뉴스 제목 데이터 시뮬레이션
news_titles = [
    "AI 기술 발전으로 일자리 변화 예상",
    "새로운 전기차 모델 출시 발표", 
    "블록체인 기술의 금융업 적용 확산",
    "기후 변화 대응을 위한 국제 협력 강화",
    "AI 챗봇 서비스 이용자 급증",
    "전기차 충전 인프라 확충 계획 발표"
]

# 키워드별 뉴스 분류
ai_news = [title for title in news_titles if 'ai' in title.lower()]
ev_news = [title for title in news_titles if '전기차' in title]
tech_keywords = ['AI', '블록체인', '기술']
tech_news = [title for title in news_titles 
             if any(keyword in title for keyword in tech_keywords)]

print(f"AI 관련 뉴스 ({len(ai_news)}개):")
for news in ai_news:
    print(f"  - {news}")

print(f"\n전기차 관련 뉴스 ({len(ev_news)}개):")
for news in ev_news:
    print(f"  - {news}")

print(f"\n기술 관련 뉴스 ({len(tech_news)}개):")
for news in tech_news:
    print(f"  - {news}")

# 뉴스 제목 길이 분석
title_lengths = [len(title) for title in news_titles]


# 리스트 연산
avg_length = sum(title_lengths) / len(title_lengths)
max_length = max(title_lengths)
min_length = min(title_lengths)

print(f"\n뉴스 제목 길이 분석:")
print(f"  평균: {avg_length:.1f}자")
print(f"  최대: {max_length}자")
print(f"  최소: {min_length}자")
print(f"  분포: {title_lengths}")
Dictionary에서도 유사한 기능을 활용할 수 있습니다.
words = ['python', 'java', 'javascript', 'go', 'rust']
scores = [95, 88, 92, 85, 90]


word_scores = {word: score for word, score in zip(words, scores)}
word_lengths = {word: len(word) for word in words}
high_scores = {word: score for word, score in word_scores.items() if score >= 90}

print(f"단어별 점수: {word_scores}")
print(f"단어별 길이: {word_lengths}")
print(f"고득점 언어: {high_scores}")

print(f"\n점수 평균: {sum(word_scores.values()) / len(word_scores)}")
print(f"최고점 언어: {max(word_scores.items(), key=lambda x: x[1])}")
print(f"모든 언어명: {list(word_scores.keys())}")
Counter는 시퀀스나 문자열에서 빈도를 세기 위한 클래스입니다.
from collections import Counter

# 예시: 단어 리스트에서 빈도수 세기
fruits = ['사과', '바나나', '사과', '오렌지', '바나나', '사과']
fruit_counter = Counter(fruits)
print(f"과일별 개수: {fruit_counter}")


# 새로운 과일 추가
fruit_counter['포도'] += 1
print(f"포도 추가 후: {fruit_counter}")

# 기존 과일 개수 증가
fruit_counter['사과'] += 2
print(f"사과 2개 추가 후: {fruit_counter}")

# update() 메서드로 여러 개 한 번에 추가
fruit_counter.update(['바나나', '포도', '포도'])
print(f"여러 과일 추가 후: {fruit_counter}")

# subtract()로 개수 감소
fruit_counter.subtract(['사과', '오렌지'])
print(f"사과, 오렌지 1개씩 감소 후: {fruit_counter}")
# 글자 빈도수 세기
text = "데이터 전처리는 데이터 분석에서 매우 중요하다."
char_counter = Counter(text)
print(f"문자별 빈도수: {char_counter}")
# 글자 빈도수 세기(' '로 분리)
text = "데이터 전처리는 데이터 분석에서 매우 중요하다."
char_counter = Counter(text.split(' '))
print(f"단어별 빈도수: {char_counter}")
## 파일 입출력 처리  

파이썬의 파일 입출력 과정에 대해 알아보겠습니다.   

open을 통해 파일을 로드하며, 'r' argument를 입력합니다.

filepath = 'stopwords_ko.txt'
with open(filepath, 'r', encoding='utf-8') as f:
    stopwords = f.read()

print(f"총 {len(stopwords)}글자 로드")
print(f"처음 10개: {stopwords[:10]}")
print(stopwords)
f.close()
filepath = 'stopwords_ko.txt'
with open(filepath, 'r', encoding='utf-8') as f:
    stopwords = f.readlines()
    # 한 줄씩 불러오기

print(f"총 {len(stopwords)} 문장 로드")
print(f"처음 10개: {stopwords[:10]}")
stopwords_by_comma = ','.join(stopwords).replace('\n','')
stopwords_by_comma
파일 모드를 'w'나 'a'로 변경하면, 파일 쓰기 모드가 됩니다.
import json

def write_file(content, filepath):
    """JSON 파일 쓰기"""
    with open(filepath, 'w', encoding='utf-8') as f:
        f.write(content + '\n')

def append_to_file(content, filepath):
    """파일에 내용 추가"""
    with open(filepath, 'a', encoding='utf-8') as f:
        f.write(content + '\n')

write_file('한국어 Stop Words 모음','stopwords.txt')
append_to_file(stopwords_by_comma, 'stopwords.txt')

## JSON 데이터 기초

데이터 분석에서 주로 사용하는 JSON 형식의 데이터는 파이썬의 Dict와 연동됩니다.   
JSON 형식의 데이터를 읽고 쓰고 조작하는 방법을 배워보겠습니다.
# JSON 기본 조작
import json
import os

# Python 객체를 JSON으로 변환
user_data = {
    "name": "김개발",
    "age": 30,
    "department": "LLM개발팀",
    "skills": ["Prompt Engineering", "Fine Tuning", "RAG"],
    "is_manager": False,
    "projects": {
        "current": "멀티모달 RAG 개발",
        "completed": ["벡터 데이터베이스 구축", "데이터 전처리 파이프라인 최적화화"]
    }
}
# JSON 문자열로 변환
json_string = json.dumps(user_data, ensure_ascii=False, indent=2)
# 한글 깨짐 방지, 2칸 들여쓰기
print("JSON 문자열:")
print(json_string)
# JSON 문자열을 Python 객체로 변환
parsed_data = json.loads(json_string)
print(f"\n파싱된 데이터 타입: {type(parsed_data)}")
print(f"이름: {parsed_data['name']}")
print(f"스킬 수: {len(parsed_data['skills'])}")

temp_json_file = 'temp_user.json'

# 파일에 쓰기
with open(temp_json_file, 'w', encoding='utf-8') as f:
    json.dump(user_data, f, ensure_ascii=False, indent=2)

print(f"\nJSON 파일 생성: {os.path.abspath(temp_json_file)}")
# 파일에서 읽기
with open(temp_json_file, 'r', encoding='utf-8') as f:
    loaded_data = json.load(f)

print(f"파일에서 로드한 데이터: {loaded_data['name']}")

# 임시 파일 정리
os.remove(temp_json_file)
print("임시 파일 삭제 완료")
## 예외 처리 로직   

파일이 없는 경우에, 파일을 불러오려고 하면 어떻게 될까요?
with open('test_log.json', 'r', encoding='utf-8') as f:
    loaded_data = json.load(f)

print(f"파일에서 로드한 데이터: {loaded_data['name']}")

안전하게 작동하는 프로그램을 만들기 위해서는 다양한 예외를 고려한 코드 구성이 필요합니다.   

조건문을 통해서도 만들 수 있지만, 보다 간결하고 좋은 성능의 코드를 위해서는 `try-except`의 예외 처리 구문을 쓰는 것이 좋습니다.
def load_data(json_file_path:str):
    """
    json_file_path의 데이터를 불러오는 코드
    로드 중 에러 발생 시, 에러 메시지를 전달
    """
    try:
        with open(json_file_path, 'r', encoding='utf-8') as f:
            loaded_data = json.load(f)

        print(f"파일에서 로드한 데이터: {loaded_data['name']}")
        return loaded_data
    except Exception as e:
        print("파일을 불러오는 중 오류가 발생했습니다.")
        print(e)

load_data('test_data.json')

조건문의 다양한 패턴과 함께 사용할 수 있습니다.
# 기본 예외 처리
def safe_divide(a, b):
    """안전한 나눗셈"""
    try:
        result = a / b
    except ZeroDivisionError:
        print("0으로 나눌 수 없습니다")
        return None
    except TypeError:
        print("숫자가 아닌 값이 입력되었습니다")
        return None
    else:
        return result
    finally:
        # finally: 항상 실행
        print("나눗셈 연산 완료")

# 테스트
print(safe_divide(10, 2))
print(safe_divide(10, 0))
print(safe_divide('10', 2))
이제, json 로그 데이터를 처리하는 코드를 알아보겠습니다.
# 파일에서 읽기
with open('api_response.json', 'r', encoding='utf-8') as f:
    api_response = json.load(f)

print(f"파일에서 로드한 데이터: {api_response}")

type(api_response)
api_response
# 중첩 Dictionary 구조
def process_user_data(api_response):
    """API 응답에서 사용자 정보를 처리하여 요약 리포트 생성"""
    
    users = api_response.get('data', {}).get('users', [])
    
    # 1. 부서별 사용자 수 구하기
    # department 값을 찾아서 dept_counts에 저장
    dept_counts = {}
    for user in users:
        dept = user.get('profile', {}).get('department')  
        if dept:
            if dept in dept_counts:
                dept_counts[dept] += 1
            else:
                dept_counts[dept] = 1
    
    # 2. 모든 스킬 목록과 빈도 
    # Counter 사용하기
    all_skills = []
    for user in users:
        skills = user.get('profile', {}).get('skills', [])
        all_skills.extend(skills)
    skill_counts = Counter(all_skills)
     # 빈도순 정렬
    skill_counts_sorted = dict(sorted(skill_counts.items(), key=lambda x: x[1], reverse=True))
    

    # 3. 프로젝트 진행률 통계
    # 프로젝트별 status와 progress 값 활용하기
    project_stats = {
        'total_projects': 0,
        'completed_projects': 0,
        'in_progress_projects': 0,
        'average_progress': 0
    }
    
    all_progress = []
    for user in users:
        projects = user.get('projects', [])
        project_stats['total_projects'] += len(projects)
        
        for project in projects:
            status = project.get('status')
            progress = project.get('progress', 0)
            all_progress.append(progress)
            
            if status == '완료':
                project_stats['completed_projects'] += 1
            elif status == '진행중':
                project_stats['in_progress_projects'] += 1
    
    if all_progress:
        project_stats['average_progress'] = sum(all_progress) / len(all_progress)
    
    # 4. 사용자별 요약 정보
    user_summaries = []
    for user in users:
        profile = user.get('profile', {})
        projects = user.get('projects', [])
        
        # 사용자의 평균 프로젝트 진행률 계산
        user_progress = [p.get('progress', 0) for p in projects]
        avg_progress = sum(user_progress) / len(user_progress) if user_progress else 0
        
        summary = {
            'name': user.get('name'),
            'department': profile.get('department'),
            'position': profile.get('position'),
            'skill_count': len(profile.get('skills', [])),
            'project_count': len(projects),
            'avg_project_progress': avg_progress
        }
        user_summaries.append(summary)
    
    return {
        'department_counts': dept_counts,
        'skill_distribution': skill_counts_sorted,
        'project_statistics': project_stats,
        'user_summaries': user_summaries,
        'total_users': len(users)
    }

processed = process_user_data(api_response)

print("처리 결과:")
for key, value in processed.items():
    if key == 'user_summaries':
        print(f"{key}:")
        for summary in value:
            print(f"  {summary}")
    else:
        print(f"{key}: {value}")

print(processed)
with open('processed_result.json', 'w', encoding='utf-8') as f:
    json.dump(processed, f, ensure_ascii=False, indent=2)
print("최종 결과가 'processed_result.json' 파일에 저장되었습니다.")

