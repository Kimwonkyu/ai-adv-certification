
chapter_name = "Python 기초"

questions = []

# --- 100 MCQs ---
# Unique conceptual and practical questions based on 1.md

mcq_data = [
    # 1. Python 개발 환경과 특징 (1-10)
    ("파이썬이 '인터프리터 언어'라는 특징에 대한 설명으로 옳은 것은?", ["소스 코드를 한 줄씩 읽어 즉시 실행한다.", "전체 코드를 기계어로 먼저 변환한 후 실행한다.", "C++보다 실행 속도가 월등히 빠르다.", "컴파일 시점에 모든 문법 오류를 잡아낸다.", "웹 브라우저에서만 동작하는 전용 언어이다."], "소스 코드를 한 줄씩 읽어 즉시 실행한다.", "인터프리터 언어는 컴파일 단계 없이 소스 코드를 한 줄씩 해석하며 즉시 실행하는 특징이 있습니다. 반면 C/C++는 실행 전 전체를 컴파일합니다.", "한 줄씩 실행", "1001", "easy"),
    ("파이썬의 '동적 타이핑(Dynamic Typing)'에 대한 설명으로 올바른 것은?", ["변수 선언 시 자료형(int, str 등)을 명시하지 않아도 된다.", "변수 선언 후에 자료형을 절대 바꿀 수 없다.", "Java나 C 언어와 동일하게 변수 타입을 고정한다.", "프로그램 실행 전에 변수 타입을 모두 확정한다.", "메모리를 수동으로 할당하고 해제해야 한다."], "변수 선언 시 자료형(int, str 등)을 명시하지 않아도 된다.", "파이썬은 실행 중에 할당되는 값에 따라 변수의 타입이 결정되는 동적 타이핑을 지원합니다. Java처럼 int x = 5라고 선언하지 않아도 됩니다.", "자료형 선언 유무", "1002", "easy"),
    ("파이썬의 장점으로 보기 어려운 것은?", ["간결하고 가독성이 높은 문법을 제공한다.", "AI, 데이터 분석 등 방대한 라이브러리를 보유하고 있다.", "기계어에 가까워 저수준 시스템 제어에 최적화되어 있다.", "다양한 운영체제에서 동일한 코드를 실행할 수 있다.", "커뮤니티가 활성화되어 있어 정보를 얻기 쉽다."], "기계어에 가까워 저수준 시스템 제어에 최적화되어 있다.", "파이썬은 고수준 언어로 생산성이 높지만, 하드웨어 제어와 같은 저수준 제어에는 C/C++가 더 적합합니다. AI/데이터 분야 1위 언어입니다.", "고수준 vs 저수준", "1003", "medium"),
    ("VS Code(Visual Studio Code)를 파이썬 개발에 사용할 때의 특징으로 적절한 것은?", ["파이썬 전용으로만 개발된 도구이다.", "확장 기능(Extension)을 통해 파이썬 개발 편의성을 높일 수 있다.", "유료 결제를 해야만 정상적인 사용이 가능하다.", "코드 편집 기능만 있고 디버깅 기능은 지원하지 않는다.", "반드시 관리자 권한으로만 실행해야 코드가 작성된다."], "확장 기능(Extension)을 통해 파이썬 개발 편의성을 높일 수 있다.", "VS Code는 다양한 확장 프로그램을 설치하여 파이썬 린팅, 디버깅, 포맷팅 기능을 강화할 수 있습니다. Python Extension이 가장 필수적입니다.", "확장성", "1004", "easy"),
    ("Jupyter Notebook(.ipynb) 파일의 주요 특징이 아닌 것은?", ["코드와 실행 결과, 텍스트(Markdown)를 한 서류에 담을 수 있다.", "데이터 분석 및 학습 기록용으로 널리 쓰인다.", "전체 코드를 한꺼번에 컴파일해야만 결과를 볼 수 있다.", "셀(Cell) 단위로 코드를 실행할 수 있다.", "웹 브라우저 환경에서 시각적으로 편리하게 사용 가능하다."], "전체 코드를 한꺼번에 컴파일해야만 결과를 볼 수 있다.", "쥬피터 노트북은 인터랙티브한 환경으로, 코드를 셀 단위로 나누어 부분 실행이 가능합니다. 데이터 분석과 시각화에 특히 널리 쓰입니다.", "셀 단위 실행", "1005", "medium"),
    ("파이썬의 '강력한 생태계'와 관련된 라이브러리 연결이 틀린 것은?", ["데이터 분석 - Pandas", "AI/딥러닝 - PyTorch", "웹 개발 - Django", "시각화 - Matplotlib", "운영체제 커널 개발 - TensorFlow"], "운영체제 커널 개발 - TensorFlow", "TensorFlow는 딥러닝 라이브러리입니다. 커널 개발은 주로 C나 Assembly가 쓰입니다. 파이썬은 scikit-learn, pandas 등 데이터 생태계가 풍부합니다.", "라이브러리 용도", "1006", "medium"),
    ("파이썬 코드를 실행하는 가장 기본적인 방식은?", ["터미널에서 python 파일명.py 명령어를 입력한다.", "반드시 웹 서버에 파일을 업로드해야 실행된다.", "메모장에서 작성하고 .txt로 저장하면 자동 실행된다.", "클라우드 환경이 아니면 일반 PC에서는 실행이 불가능하다.", "컴파일러를 통해 .exe 파일을 먼저 생성해야 한다."], "터미널에서 python 파일명.py 명령어를 입력한다.", "파이썬 인터프리터를 통해 직접 소스 파일을 실행하는 것이 가장 기본적인 방법입니다. 터미널에서 python3 script.py로 실행합니다.", "실행 방법", "1007", "easy"),
    ("다음 중 파이썬 설치와 관련하여 '환경 변수(Path) 추가'를 하는 주된 이유는?", ["어느 경로에서든 python 명령어를 사용할 수 있게 하기 위해", "파이썬의 실행 속도를 2배 이상 높이기 위해", "파이썬 설치 용량을 줄여 하드디스크 공간을 확보하기 위해", "파이썬 코드를 암호화하여 보안을 강화하기 위해", "파이썬의 기본 배경 테마를 다크 모드로 설정하기 위해"], "어느 경로에서든 python 명령어를 사용할 수 있게 하기 위해", "Path 설정은 운영체제가 실행 파일 위치를 탐색할 경로를 지정하는 작업입니다. 설정 없이는 특정 디렉토리에서만 python 명령이 동작합니다.", "환경 변수 설정", "1008", "medium"),
    ("파이썬 개발 시 가상 환경을 사용하는 주된 목적은?", ["프로젝트마다 독립적인 라이브러리 버전을 관리하기 위해", "인터넷 연결 없이도 코드가 실행되도록 하기 위해", "컴퓨터의 메모리(RAM) 용량을 확장하기 위해", "파이썬 버전 업그레이드를 아예 막기 위해", "동동 실행되는 멀웨어(Malware)를 잡기 위해"], "프로젝트마다 독립적인 라이브러리 버전을 관리하기 위해", "가상 환경은 프로젝트별로 필요한 패키지의 의존성을 독립적으로 구성하게 해주어 충돌을 방지합니다. python -m venv venv로 생성합니다.", "가상 환경의 의의", "1009", "medium"),
    ("파이썬의 철학(The Zen of Python) 중 하나인 'Beautiful is better than ugly'가 강조하는 가치는?", ["성능 최적화", "코드의 가독성과 명료함", "화려한 UI 디자인", "최신 기술의 도입", "네트워크 통신 보안"], "코드의 가독성과 명료함", "파이썬 철학은 코드가 사람이 읽기 좋고 명확하게 작성되어야 함을 강조합니다. 이는 유지보수성에도 직결됩니다.", "파이썬 철학", "1010", "easy"),

    # 2. 변수와 자료형 (11-30)
    ("다음 중 파이썬의 수치형(Numeric) 자료형에 대한 설명으로 옳은 것은?", ["int는 정수, float는 실수를 의미한다.", "실수형 데이터는 뒤에 반드시 f를 붙여야 한다.", "10.0은 int 자료형으로 처리된다.", "정수형 데이터는 최대 64비트까지만 저장 가능하다.", "파이썬에는 수치형 자료형이 단 하나(number)만 존재한다."], "int는 정수, float는 실수를 의미한다.", "파이썬은 정수는 int, 소수점이 포함된 실수는 float로 구분하여 관리합니다. 10.0은 float 타입입니다.", "정수와 실수의 구분", "1011", "easy"),
    ("문자열(str) 자료형을 정의하는 올바른 방법이 아닌 것은?", ["'Hello'", "\"Python\"", "\"\"\"Triple Quotes\"\"\"", "'Start with quote or double quote'", "[List Style String]"], "[List Style String]", "문자열은 작은따옴표, 큰따옴표 또는 삼중 따옴표로 감싸야 하며, []는 리스트를 의미합니다. 따옴표 없이 쓰면 변수명으로 인식됩니다.", "문자열 선언", "1012", "easy"),
    ("불리언(bool) 자료형의 두 가지 값으로 옳은 것은?", ["True, False", "T, F", "yes, no", "1, 0 (자료형 이름 기준)", "Real, Fake"], "True, False", "파이썬의 불리언 값은 반드시 첫 글자가 대문자인 True와 False를 사용합니다. true나 false는 오류를 유발합니다.", "Boolean 값", "1013", "easy"),
    ("리스트(List)의 특징으로 볼 수 없는 것은?", ["대괄호([])를 사용하여 정의한다.", "순서가 있으며, 인덱스를 통해 값에 접근할 수 있다.", "한번 생성되면 요소를 추가하거나 삭제할 수 없다.", "다양한 자료형의 데이터를 한 리스트에 담을 수 있다.", "수정 가능한(Mutable) 자료형이다."], "한번 생성되면 요소를 추가하거나 삭제할 수 없다.", "리스트는 가변(Mutable) 객체로, append, remove 등의 메서드를 통해 요소를 자유롭게 변경할 수 있습니다.", "리스트 특성", "1014", "medium"),
    ("튜플(Tuple)과 리스트(List)의 가장 큰 차이점은?", ["튜플은 소괄호(())를 사용하고 수정이 불가능(Immutable)하다.", "리스트는 중복된 값을 허용하지 않는다.", "튜플은 오직 숫자형 데이터만 담을 수 있다.", "리스트는 인덱싱이 불가능하다.", "튜플은 요소를 추가하는 append() 메서드가 있다."], "튜플은 소괄호(())를 사용하고 수정이 불가능(Immutable)하다.", "튜플은 생성 후 값을 변경할 수 없는 불변 성질을 가지며, 이는 데이터 안전성을 보장합니다. 딕셔너리의 키로도 사용할 수 있습니다.", "튜플 vs 리스트", "1015", "medium"),
    ("딕셔너리(Dictionary) 자료형의 핵심 구조는?", ["Value들의 나열", "Index(번호)와 Value의 쌍", "Key와 Value의 쌍", "오직 문자열만 저장하는 행렬", "순서가 고정된 튜플들의 합"], "Key와 Value의 쌍", "딕셔너리는 {Key: Value} 형태의 구조를 갖는 해시 맵 자료형으로, 키를 통해 값에 빠르게 접근합니다.", "딕셔너리 구조", "1016", "easy"),
    ("딕셔너리에서 특정 값을 조회할 때의 시간 복잡도(평균)는?", ["O(1)", "O(n)", "O(log n)", "O(n^2)", "순서에 따라 다르다"], "O(1)", "딕셔너리는 내부적으로 해시 테이블 구조를 사용하여 키에 해당하는 값을 평균 O(1) 상수 시간에 조회합니다.", "딕셔너리 성능", "1017", "hard"),
    ("리스트 `a = [10, 20, 30]`에서 `20`을 꺼내기 위한 인덱싱은?", ["a[0]", "a[1]", "a[2]", "a[3]", "a[-0]"], "a[1]", "파이썬 인덱스는 0부터 시작하므로 두 번째 요소는 인덱스 1로 접근합니다. 음수 인덱스(-1)로 맨 마지막 요소에 접근할 수도 있습니다.", "인덱싱", "1018", "easy"),
    ("리스트 `arr = [1, 2, 3]`의 맨 끝에 '4'를 추가하는 명령어는?", ["arr.add(4)", "arr.insert(4)", "arr.push(4)", "arr.append(4)", "arr.extend(4)"], "arr.append(4)", "append() 메서드는 리스트의 마지막 위치에 인자로 전달된 요소를 추가합니다. 여러 요소를 한 번에 추가할 때는 extend()를 씁니다.", "리스트 추가", "1019", "medium"),
    ("`s = 'Python'` 일 때, `s[0:2]`의 결과는?", ["'Py'", "'Pyt'", "'yht'", "'Python'", "'o'"], "'Py'", "슬라이싱 [start:end]에서 end 인덱스는 포함되지 않으므로 s[0:2]는 인덱스 0, 1인 'P', 'y'를 반환합니다.", "슬라이싱", "1020", "medium"),
    ("집합(Set) 자료형의 가장 두드러진 특징은?", ["순서가 보장되며 인덱스 조회가 가능하다.", "중복된 요소를 허용하지 않는다.", "반드시 정수 데이터만 포함해야 한다.", "값의 수정이 절대 불가능하다.", "대괄호([])로 생성한다."], "중복된 요소를 허용하지 않는다.", "Set은 중복을 자동으로 제거하는 것이 핵심 특징이며, 순서가 없어 인덱싱은 불가능합니다. 교집합(&), 합집합(|) 등 집합 연산도 지원합니다.", "Set 특징", "1021", "easy"),
    ("다음 중 불변(Immutable) 자료형이 아닌 것은?", ["정수(int)", "문자열(str)", "튜플(tuple)", "리스트(list)", "불리언(bool)"], "리스트(list)", "리스트, 딕셔너리, 집합은 가변(Mutable)이며, int/str/tuple/bool은 불변(Immutable) 자료형입니다.", "가변/불변", "1022", "medium"),
    ("변수 이름 규칙으로 올바르지 않은 것은?", ["숫자로 시작할 수 없다.", "특수문자는 언더바(_)만 사용 가능하다.", "예약어(if, for, def 등)는 변수명으로 쓸 수 없다.", "공백(Space)을 포함할 수 있다.", "대소문자를 구분한다."], "공백(Space)을 포함할 수 있다.", "변수명 내부에는 공백을 넣을 수 없으며, 공백 대신 언더바(_)를 사용하는 snake_case 방식이 일반적입니다.", "명명 규칙", "1023", "easy"),
    ("`3 ** 2` 의 실행 결과는?", ["6", "9", "5", "1", "1/9"], "9", "** 연산자는 거듭제곱을 의미합니다. 3 ** 2는 3의 2제곱인 9를 반환합니다. 분수 지수(0.5)를 쓰면 제곱근 계산도 가능합니다.", "산술 연산자", "1024", "easy"),
    ("`10 // 3` 의 실행 결과는?", ["3.333...", "3", "1", "0.333...", "9"], "3", "// 연산자는 나눗셈의 소수점 이하를 버리고 '몫'만 반환하는 정수 나눗셈 연산자입니다. 7 // 2는 3.5가 아닌 3입니다.", "몫 연산", "1025", "easy"),
    ("`10 % 3` 의 실행 결과는?", ["3", "1", "0", "1.5", "10"], "1", "% 연산자는 나눗셈 후의 '나머지'를 반환합니다. 10을 3으로 나누면 몫 3, 나머지 1이 됩니다. 짝수 판별(n%2==0)에 자주 씁니다.", "나머지 연산", "1026", "easy"),
    ("문자열 '100'을 숫자 100으로 바꾸는 형변환 함수는?", ["str()", "float()", "int()", "bool()", "list()"], "int()", "int() 함수는 숫자 형태의 문자열이나 실수를 정수로 변환합니다. '100'을 넣으면 100이 반환됩니다.", "형변환", "1027", "easy"),
    ("리스트를 정렬하는 메서드는?", ["sort()", "order()", "arrange()", "align()", "shuffle()"], "sort()", "sort() 메서드는 원본 리스트의 요소를 오름차순으로 정렬하며, reverse=True를 주면 내림차순이 됩니다.", "정렬", "1028", "easy"),
    ("딕셔너리 `d = {'a': 1}` 에서 1을 가져오기 위한 코드는?", ["d[0]", "d.get(0)", "d['a']", "d.values()", "d.a"], "d['a']", "딕셔너리는 숫자 인덱스가 아닌 Key를 사용하여 값을 조회합니다. d['a']는 키 'a'에 대응하는 1을 반환합니다.", "Key 조회", "1029", "easy"),
    ("`len([1, 2, 3, 4, 5])` 의 결과값은?", ["4", "5", "6", "0", "15"], "5", "len() 함수는 리스트, 문자열 등 컨테이너 내부 요소의 개수를 반환합니다. 요소가 5개이므로 5를 반환합니다.", "길이 확인", "1030", "easy"),

    # 3. 제어문 (31-50)
    ("파이썬의 if문에서 조건절 뒤에 반드시 붙여야 하는 문자는?", ["; (세미콜론)", ": (콜론)", "{ (중괄호)", ") (닫는 소괄호)", ", (컴마)"], ": (콜론)", "파이썬에서 if, for, while, def 등 제어 구문 뒤에는 항상 콜론(:)이 와야 블록이 시작됩니다.", "문법 규칙", "1031", "easy"),
    ("if-else 구조에서 중간에 다른 조건을 추가할 때 쓰는 키워드는?", ["else if", "elseif", "elif", "case", "when"], "elif", "파이썬은 else if를 elif로 줄여서 사용합니다. 다른 언어의 else if, elsif와 동일한 역할입니다.", "다중 조건", "1032", "easy"),
    ("반복문 루프를 즉시 완전히 빠져나가게 하는 키워드는?", ["pass", "continue", "break", "return", "stop"], "break", "break 문은 현재 실행 중인 가장 가까운 루프를 즉시 종료하고 루프 밖의 다음 코드를 실행합니다. 중첩 루프에서는 안쪽 루프만 탈출합니다.", "루프 탈출", "1033", "easy"),
    ("현재 반복을 중단하고 다음 반복 차례로 바로 넘어가는 키워드는?", ["pass", "continue", "break", "jump", "skip"], "continue", "continue 문은 루프 본문의 나머지 코드를 건너뛰고 즉시 다음 반복 조건 검사로 진행합니다. break와 달리 루프 자체는 유지됩니다.", "반복 건너뛰기", "1034", "medium"),
    ("아무 일도 하지 않고 문법적 위치만 채우고 싶을 때 쓰는 키워드는?", ["null", "none", "empty", "pass", "void"], "pass", "pass 문은 구조적으로 문장이 필요하지만 수행할 코드가 없을 때 빈 자리를 채우는 데 사용합니다. 미완성 함수나 클래스 선언 시 자주 씁니다.", "pass 의도", "1035", "medium"),
    ("`range(5)` 함수가 생성하는 숫자의 범위는?", ["1, 2, 3, 4, 5", "0, 1, 2, 3, 4", "0, 1, 2, 3, 4, 5", "1, 2, 3, 4", "기본으로 생성되지 않고 에러가 난다"], "0, 1, 2, 3, 4", "range(n)은 0부터 n-1까지의 정수를 생성합니다. range(5)는 0, 1, 2, 3, 4를 만들어냅니다.", "range 범위", "1036", "easy"),
    ("`range(1, 10, 2)` 에 의해 생성되는 홀수 리스트는?", ["[1, 3, 5, 7, 9]", "[1, 2, 3, 4, 5, 6, 7, 8, 9]", "[2, 4, 6, 8]", "[1, 3, 5, 7, 9, 10]", "[3, 5, 7, 9]"], "[1, 3, 5, 7, 9]", "range(start, end, step)에서 start=1, end=10(미포함), step=2로 2씩 증가하여 홀수를 생성합니다.", "range 간격", "1037", "medium"),
    ("데이터가 비어있을 때 ([], '', 0 등) 불리언 판정 결과는?", ["True", "False", "None", "Error", "0 (자료형 유지)"], "False", "파이썬에서 빈 컨테이너([], {}, set()), 빈 문자열(''), 숫자 0, None은 모두 False로 간주됩니다.", "암시적 불리언", "1038", "hard"),
    ("`for x in [1, 2, 3]:` 에서 `x`는 무엇을 의미하는가?", ["리스트의 인덱스 번호", "리스트 내부의 개별 요소 값", "리스트 전체 데이터", "리스트의 메모리 주소", "반복 횟수"], "리스트 내부의 개별 요소 값", "for in 구문에서 앞의 변수는 순회 대상의 각 요소를 하나씩 전달받습니다. 리스트, 튜플, 문자열, range 등 모든 이터러블에 사용 가능합니다.", "for 루프 원리", "1039", "medium"),
    ("중첩 루프(Nested Loop)에 대한 설명으로 옳은 것은?", ["반복문 안에 또 다른 반복문이 들어있는 구조이다.", "파이썬에서는 성능상의 이유로 금지되어 있다.", "반드시 i, j, k 알파벳 순서로 변수명을 지어야 한다.", "무조건 infinite loop(무한 루프)가 된다.", "외부 루프보다 내부 루프가 먼저 종료되면 에러다."], "반복문 안에 또 다른 반복문이 들어있는 구조이다.", "다차원 리스트 처리나 행렬 연산 등에서 루프를 겹쳐 사용할 수 있습니다. 중첩이 깊어질수록 성능이 저하되므로 적절히 활용해야 합니다.", "중첩 구조", "1040", "medium"),
    ("다음을 한 줄로 표현하는 List Comprehension으로 옳은 것은?\n`res = []; for x in range(5): res.append(x**2)`", ["[x for x in range(5)]", "[x**2 for x in range(5)]", "[for x in range(5): x**2]", "[x in range(5) if x**2]", "[append(x**2) for x in range(5)]"], "[x**2 for x in range(5)]", "[표현식 for 변수 in 반복가능객체] 형태가 기본 구조이며, x**2가 표현식에 해당합니다. if 조건을 추가해 필터링도 한 줄로 가능합니다.", "리스트 컴프리헨션", "1041", "medium"),
    ("List Comprehension에서 필터링을 위한 if문은 어디에 위치하는가?", ["for문 맨 앞", "for문 직후(뒤쪽)", "대괄호 밖", "in 키워드 앞", "위치는 상관없다"], "for문 직후(뒤쪽)", "[expr for var in iter if condition] 형태로, if 조건이 for문 뒤에 위치하여 필터링을 수행합니다.", "조건부 컴프리헨션", "1042", "hard"),
    ("while문이 무한 루프에 빠지는 대표적인 상황은?", ["반복 조건문이 항상 True인 경우", "break 문을 너무 많이 쓴 경우", "함수 내부에서 while을 쓴 경우", "조건문에 0이 들어간 경우", "리스트의 길이가 너무 긴 경우"], "반복 조건문이 항상 True인 경우", "while 조건이 거짓(False)이 되지 않으면 루프는 종료되지 않고 영원히 실행됩니다. 반드시 탈출 조건(break 또는 조건 변경)을 설계해야 합니다.", "무한 루프", "1043", "hard"),
    ("다음 중 '논리 연산자'가 아닌 것은?", ["and", "or", "not", "is", "None of above (all are logic)"], "is", "is는 두 객체가 동일한 메모리 객체인지 비교하는 동일성 연산자이며, 논리 연산자는 and, or, not입니다.", "논리 연산자", "1044", "hard"),
    ("`(3 > 1) and (5 < 2)` 의 최종 결과는?", ["True", "False", "None", "3", "5"], "False", "and 연산은 양쪽 조건이 모두 참일 때만 True를 반환합니다. 5 < 2가 False이므로 전체 결과도 False입니다.", "논리 판정", "1045", "medium"),
    ("`(3 > 1) or (5 < 2)` 의 최종 결과는?", ["True", "False", "None", "1", "2"], "True", "or 연산은 두 조건 중 하나라도 참이면 True를 반환합니다. 3 > 1이 True이므로 전체 결과는 True입니다.", "논리 판정 or", "1046", "medium"),
    ("리스트 `['a', 'b', 'c']`에서 값 'a'가 있는지 확인하는 코드?", ["'a' in list", "'a' has list", "list.contains('a')", "list == 'a'", "'a' or list"], "'a' in list", "in 연산자는 컨테이너 내에 해당 값이 포함되어 있는지 멤버십 테스트를 수행합니다. 리스트보다 Set이나 Dict 키 검색이 훨씬 빠릅니다.", "in 연산자", "1047", "medium"),
    ("`not True` 의 결과는?", ["True", "False", "0", "1", "Error"], "False", "not 연산자는 불리언 값을 반대로 뒤집습니다. not True는 False를 반환합니다. not in, not None 같은 복합 표현식에도 자주 활용됩니다.", "not 연산", "1048", "medium"),
    ("리스트 슬라이싱 `arr[::2]` 의 의미는?", ["처음부터 끝까지 2칸씩 건너뛰며 가져옴", "인덱스 2번까지만 가져옴", "끝에서 2개만 가져옴", "2번째 요소만 가져옴", "에러가 난다"], "처음부터 끝까지 2칸씩 건너뛰며 가져옴", "[start:end:step]에서 start와 end 생략 시 전체 범위를 의미하고, step=2이므로 인덱스 0, 2, 4... 순서로 가져옵니다.", "슬라이싱 간격", "1049", "hard"),
    ("`for i, v in enumerate(['A', 'B']):` 구문에서 `i`에 담기는 것은?", ["문자열 'A', 'B'", "인덱스 번호 0, 1", "리스트 전체", "데이터 타입", "사용자 입력"], "인덱스 번호 0, 1", "enumerate는 순회 요소와 그 인덱스를 (인덱스, 값) 형태의 튜플로 동시에 반환합니다. 시작 인덱스를 enumerate(list, start=1)로 지정할 수도 있습니다.", "enumerate", "1050", "medium"),

    # 4. 함수와 모듈 (51-70)
    ("파이썬에서 함수를 정의할 때 사용하는 키워드는?", ["function", "func", "def", "define", "method"], "def", "Function Definition의 약자인 def 키워드를 사용하여 함수를 선언하고 이름을 부여합니다. 함수는 코드 재사용과 모듈화의 핵심 단위입니다.", "함수 정의", "1051", "easy"),
    ("함수 내부에서 계산된 값을 함수 밖으로 전달할 때 쓰는 키워드는?", ["give", "send", "return", "output", "exit"], "return", "return 키워드는 함수의 결과값을 호출자에게 반환하고 함수 실행을 즉시 종료합니다. return 없으면 None을 암묵적으로 반환합니다.", "return", "1052", "medium"),
    ("함수 호출 시 인자의 개수가 가변적일 때(튜플로 받음) 사용하는 기호는?", ["*args", "**kwargs", "&args", "?args", "!args"], "*args", "* 별표 하나는 위치 인자들을 가변적으로 받아 튜플 형태로 묶어서 처리합니다. 인자 개수가 유동적일 때 사용합니다.", "가변 인자", "1053", "hard"),
    ("키워드 인자들을 딕셔너리 형태로 가변적으로 받을 때 사용하는 기호는?", ["*args", "**kwargs", "$kwargs", "##kwargs", "+kwargs"], "**kwargs", "** 별표 두 개는 이름=값 형태의 키워드 인자들을 딕셔너리로 묶어서 받는 매개변수 표기법입니다. *args는 위치 인자를 튜플로 받습니다.", "키워드 가변 인자", "1054", "hard"),
    ("함수 정의 시 매개변수에 미리 기본값을 지정하는 기능의 명칭은?", ["Default Parameter", "Fixed Variable", "Initial Value", "Secret Parameter", "Global Parameter"], "Default Parameter", "기본 매개변수는 호출 시 인자가 전달되지 않았을 때 자동으로 사용할 값을 미리 설정해두는 기능입니다. 반드시 일반 매개변수 뒤에 위치해야 합니다.", "기본 매개변수", "1055", "hard"),
    ("외부 라이브러리나 모듈의 기능을 현재 코드로 가져오는 키워드는?", ["get", "bring", "import", "include", "load"], "import", "import 문을 통해 다른 파일이나 설치된 패키지의 함수, 클래스, 변수를 현재 파일에서 사용할 수 있습니다.", "임포트", "1056", "medium"),
    ("`from math import sqrt` 문법의 장점은?", ["math 모듈 전체를 다 안 가져오고 sqrt만 직접 사용 가능하다.", "실행 속도가 10배 빨라진다.", "sqrt 함수를 수정할 수 있게 된다.", "보안이 강화된다.", "가독성이 나빠지지만 코드는 짧아진다."], "math 모듈 전체를 다 안 가져오고 sqrt만 직접 사용 가능하다.", "특정 함수만 가져오면 math.sqrt() 대신 sqrt()로 바로 호출할 수 있어 코드가 간결해집니다. as로 별칭도 지정할 수 있습니다.", "from import", "1057", "medium"),
    ("모듈의 이름을 별칭(Alias)으로 줄여서 가져올 때 쓰는 키워드는?", ["with", "as", "like", "to", "rename"], "as", "`import pandas as pd` 처럼 as를 사용하면 긴 모듈명을 짧은 별칭으로 사용할 수 있어 편리합니다.", "as 별칭", "1058", "medium"),
    ("함수 내부에서 전역 변수(Global Variable)의 값을 수정하고자 할 때 쓰는 선언은?", ["local", "public", "global", "common", "private"], "global", "전역 변수를 함수 내에서 수정하려면 반드시 global 선언이 필요합니다. 없으면 UnboundLocalError가 발생합니다.", "global 선언", "1059", "hard"),
    ("이름이 없는 한 줄짜리 익명 함수를 무엇이라 하는가?", ["arrow function", "express function", "lambda function", "ghost function", "short function"], "lambda function", "lambda 키워드를 사용하여 간단한 로직의 익명 함수를 한 줄로 정의합니다. map, filter, sort의 key 인자에 자주 활용됩니다.", "람다", "1060", "hard"),
    ("작성된 소스 코드 파일(.py) 하나를 의미하는 단위는?", ["Package", "Module", "Library", "Framework", "Script"], "Module", "파이썬에서 하나의 .py 파일은 개별 모듈로 간주됩니다. import를 통해 다른 파일에서 사용할 수 있습니다.", "모듈 정의", "1061", "medium"),
    ("여러 개의 모듈이 모인 폴더 구조(보통 __init__.py 포함)의 단위는?", ["Package", "Snippet", "Repository", "Archive", "Source"], "Package", "패키지는 점(.) 연산자로 모듈을 계층적으로 관리하는 폴더입니다. 예: numpy, pandas 등이 패키지입니다.", "패키지 정의", "1062", "hard"),
    ("함수 상단에 `\"\"\" ... \"\"\"` 로 작성하는 도움말 주석의 명칭은?", ["Help-string", "Instruction", "Docstring", "Comment-block", "Metadata"], "Docstring", "Documentation String의 약자로, 함수나 클래스의 역할, 매개변수, 반환값을 설명하는 공식 주석입니다.", "독스트링", "1063", "hard"),
    ("함수 호출 시 `f(name='Kim', age=20)` 처럼 이름을 지정해주는 방식은?", ["Positional Argument", "Keyword Argument", "Named Variable", "Direct Mapping", "Explicit Call"], "Keyword Argument", "키워드 인자를 사용하면 인자의 순서가 바뀌어도 정확한 매개변수에 전달되어 안전합니다. 특히 매개변수가 많은 함수 호출에 유용합니다.", "키워드 인자", "1064", "medium"),
    ("`map(len, ['abc', 'de'])` 의 결과로 생성되는 숫자들은?", ["3, 2", "2, 3", "0, 1", "5", "abc, de"], "3, 2", "map은 각 요소에 len을 적용하여 'abc'의 길이 3과 'de'의 길이 2를 순서대로 반환합니다. list()로 감싸야 결과를 리스트로 얻을 수 있습니다.", "map 함수", "1065", "hard"),
    ("`filter(None, [1, 0, 2, False])` 처럼 사용했을 때 남는 값은?", ["1, 2", "1, 0, 2", "False", "0, False", "모두 삭제됨"], "1, 2", "filter에 None을 전달하면 각 요소 자체의 참/거짓으로 필터링합니다. 0과 False는 거짓이므로 제거됩니다.", "filter 함수", "1066", "hard"),
    ("특정 모듈을 현재 파일에서 직접 실행할 때만 동작하게 하는 조건문은?", ["if __name__ == \"__main__\":", "if script.run() == True:", "if is_main():", "if this == main:", "if __run__ == \"start\":"], "if __name__ == \"__main__\":", "__name__ 변수는 직접 실행 시 '__main__'이 되고, import될 때는 모듈 이름이 됩니다. 이를 이용해 실행 맥락을 구분합니다.", "메인 조건절", "1067", "hard"),
    ("파이썬의 표준 라이브러리 중 운영체제와 상호작용(폴더 생성, 파일 경로 등)하는 모듈은?", ["math", "sys", "os", "datetime", "random"], "os", "os 모듈은 디렉토리 생성/삭제, 환경 변수 접근, 경로 조작 등 OS 기능을 파이썬에서 제어할 수 있게 합니다.", "os 모듈", "1068", "medium"),
    ("파이썬의 설치 경로, 아규먼트(argv) 등 시스템 정보를 확인하는 모듈은?", ["os", "sys", "io", "json", "pysys"], "sys", "sys 모듈은 파이썬 인터프리터와 관련된 시스템 설정, 명령행 인수(argv), 경로(path) 등을 다룹니다.", "sys 모듈", "1069", "medium"),
    ("재귀 함수(Recursive Function)의 정의로 옳은 것은?", ["함수 내부에서 자기 자신을 다시 호출하는 함수", "한꺼번에 여러 번 실행되는 함수", "에러가 나면 자동으로 다시 시작하는 함수", "반드시 loop 문을 포함해야 하는 함수", "외부 API를 호출하는 함수"], "함수 내부에서 자기 자신을 다시 호출하는 함수", "재귀 함수는 자기 자신을 호출하며 문제를 더 작은 단위로 쪼개어 해결합니다. 반드시 기저 조건(base case)이 필요합니다.", "재귀", "1070", "hard"),

    # 5. 객체지향 프로그래밍 (71-85)
    ("객체를 만들기 위한 설계도에 해당하는 용어는?", ["Object", "Instance", "Class", "Module", "Blueprint"], "Class", "클래스는 객체의 속성(변수)과 동작(메서드)을 정의한 틀입니다. 이 틀을 기반으로 인스턴스를 생성합니다. class 키워드로 선언합니다.", "클래스 정의", "1071", "medium"),
    ("클래스로부터 실제로 생성된 실체를 의미하는 용어는?", ["Code", "Logic", "Instance", "Factory", "Unit"], "Instance", "인스턴스는 클래스라는 설계도를 바탕으로 메모리에 실제로 생성된 객체를 의미합니다. 하나의 클래스로 수많은 인스턴스를 만들 수 있습니다.", "인스턴스", "1072", "medium"),
    ("클래스 내부의 함수를 부르는 명칭은?", ["Global Function", "Method", "Action", "Attribute", "Feature"], "Method", "클래스에 속해 객체의 동작을 담당하는 함수를 메서드라고 합니다. 일반 함수와 달리 self 매개변수를 가집니다.", "메서드", "1073", "medium"),
    ("객체 내부에 저장된 데이터를 부르는 명칭은?", ["Method", "Variable", "Attribute (속성)", "Param", "Constant"], "Attribute (속성)", "객체의 상태나 데이터를 저장하는 변수를 속성 또는 필드라고 합니다. self.변수명 형태로 정의됩니다. __init__에서 초기화하는 것이 일반적입니다.", "속성", "1074", "medium"),
    ("객체 생성 시 자동으로 호출되어 값을 초기화하는 메서드명은?", ["__start__", "__main__", "__init__", "__new__", "__construct__"], "__init__", "__init__은 파이썬 클래스의 생성자(Constructor) 역할을 하며, 객체 생성 직후 자동으로 호출됩니다.", "생성자", "1075", "medium"),
    ("메서드 정의 시 첫 번째 인자로 반드시 인스턴스 자신을 가리키는 변수명?", ["this", "that", "self", "me", "it"], "self", "관례적으로 self를 사용하여 인스턴스 자신을 참조하며, 속성 접근(self.name)에 사용됩니다. 다른 이름을 써도 되지만 self가 강력히 권장됩니다.", "self", "1076", "medium"),
    ("기존 클래스의 기능을 물려받아 새로운 클래스를 만드는 기법은?", ["Packaging", "Inheritance (상속)", "Mapping", "Copying", "Merging"], "Inheritance (상속)", "상속을 통해 부모 클래스의 속성과 메서드를 자식 클래스가 물려받아 코드 재사용성을 높입니다. class 자식(부모): 형태로 선언합니다.", "상속", "1077", "medium"),
    ("부모 클래스로부터 물려받은 메서드를 자식 클래스에서 재정의하는 것은?", ["Overloading", "Overriding", "Overwriting", "Overlapping", "Resetting"], "Overriding", "오버라이딩은 부모의 메서드를 자식에서 다시 정의하여 자식 클래스만의 특화된 동작을 구현하는 기법입니다. super()로 부모 메서드를 재활용할 수 있습니다.", "오버라이딩", "1078", "hard"),
    ("자식 클래스에서 부모 클래스의 메서드나 생성자를 호출할 때 쓰는 키워드?", ["parent", "super()", "base", "root", "upper"], "super()", "super()를 사용하면 부모 클래스의 메서드를 명시적으로 호출할 수 있으며, 다중 상속 상황에서도 안전하게 동작합니다.", "super", "1079", "hard"),
    ("파이썬의 '모든 것이 객체이다'라는 말의 의미가 아닌 것은?", ["숫자 10도 객체이다.", "문자열 'hi'도 객체이다.", "함수 그 자체도 객체로 취급되어 인자로 전달 가능하다.", "클래스는 객체가 아니므로 조작이 불가능하다.", "리스트나 딕셔너리도 객체이다."], "클래스는 객체가 아니므로 조작이 불가능하다.", "파이썬에서는 클래스 자체도 type 메타클래스의 인스턴스이며 객체로 다루어질 수 있습니다. '모든 것이 객체'라는 파이썬 철학의 핵심입니다.", "객체 철학", "1080", "hard"),
    ("비슷한 기능을 하는 객체들이 동일한 인터페이스(메서드명)를 가지는 성질?", ["Encapsulation", "Polymorphism (다형성)", "Abstraction", "Separation", "Binding"], "Polymorphism (다형성)", "다형성을 통해 서로 다른 타입의 객체를 동일한 인터페이스로 일관되게 다룰 수 있습니다. 예: Dog와 Cat 모두 .speak() 메서드를 가질 수 있습니다.", "다형성", "1081", "medium"),
    ("내부 구현을 숨기고 필요한 부분만 외부에 공개하는 객체지향의 원칙?", ["Encapsulation (캡슐화)", "Exposure", "Simplification", "Integration", "Modularization"], "Encapsulation (캡슐화)", "캡슐화는 데이터와 메서드를 묶어 내부 구현을 숨기고 필요한 인터페이스만 외부에 공개하는 원칙입니다. 언더스코어(_)로 비공개 속성을 표현합니다.", "캡슐화", "1082", "medium"),
    ("추상 클래스(Abstract Class)를 사용하는 가장 큰 이유는?", ["코드의 실행 속도를 높이기 위해", "자식 클래스가 특정 메서드를 반드시 구현하도록 강제하기 위해", "데이터를 암호화하기 위해", "다중 상속을 막기 위해", "메모리 사용량을 줄이기 위해"], "자식 클래스가 특정 메서드를 반드시 구현하도록 강제하기 위해", "추상 메서드를 통해 인터페이스 틀을 제공하고, 하위 클래스가 반드시 구현해야 하는 명세를 정의합니다. abc 모듈의 ABC와 @abstractmethod를 사용합니다.", "추상 클래스", "1083", "hard"),
    ("클래스 변수(Class Variable)의 상징적인 특징은?", ["인스턴스마다 모두 다른 값을 가진다.", "해당 클래스로 만든 모든 인스턴스가 값을 공유한다.", "함수 안에서만 사용 가능하다.", "프로그램 종료 시까지 파일에 저장된다.", "숫자로만 구성되어야 한다."], "해당 클래스로 만든 모든 인스턴스가 값을 공유한다.", "클래스 변수는 인스턴스가 아닌 클래스 레벨에 저장되어 모든 인스턴스가 동일한 값을 공유합니다. 인스턴스 변수는 self.변수로 개별 관리됩니다.", "클래스 변수", "1084", "hard"),
    ("`isinstance(obj, MyClass)` 함수가 하는 역할은?", ["obj 객체가 MyClass의 인스턴스인지를 확인하여 불리언으로 반환한다.", "obj 객체를 MyClass 타입으로 억지로 변환한다.", "MyClass의 모든 속성을 obj로 복사한다.", "obj가 가진 메모리 주소를 숫자로 반환한다.", "새로운 객체 obj를 생성한다."], "obj 객체가 MyClass의 인스턴스인지를 확인하여 불리언으로 반환한다.", "isinstance는 상속 관계도 고려하여 객체의 타입을 안전하게 확인합니다. type() == 비교보다 권장됩니다.", "isinstance", "1085", "hard"),

    # 6. 예외 처리와 파일 입출력 (86-100)
    ("프로그램 실행 중 발생하는 에러를 무엇이라 부르는가?", ["Bug", "Exception (예외)", "Fault", "Warning", "Miss"], "Exception (예외)", "동적으로 발생하는 런타임 에러를 예외라고 합니다. 파이썬은 예외 처리를 통해 프로그램 비정상 종료를 방지합니다.", "예외 정의", "1086", "easy"),
    ("예외를 시도하고 감지하기 위한 기본 구문은?", ["check-catch", "try-except", "try-catch", "if-error", "begin-fail"], "try-except", "파이썬은 Java의 try-catch 대신 try-except 구문을 사용합니다. try 블록에서 예외 발생 시 except가 실행됩니다.", "try-except", "1087", "medium"),
    ("에러 발생 여부와 상관없이 마지막에 무조건 실행하고 싶은 블록?", ["next", "then", "finally", "last", "always"], "finally", "finally 블록은 예외 발생 여부와 관계없이 항상 실행됩니다. 주로 파일 닫기나 자원 해제 코드를 작성합니다.", "finally", "1088", "medium"),
    ("특정 상황에서 강제로 에러를 발생시키고 싶을 때 사용하는 키워드?", ["make", "push", "raise", "error", "alarm"], "raise", "raise 문을 통해 사용자 정의 예외나 기존 예외를 직접 발생시킬 수 있습니다. 입력 검증 등에 자주 활용됩니다.", "raise", "1089", "medium"),
    ("파일을 열 때 `open('file.txt', 'w')`의 'w' 모드가 의미하는 것은?", ["Read (읽기 전용)", "Write (덮어쓰기)", "Append (이어쓰기)", "Web (온라인 체크)", "Wait (대기)"], "Write (덮어쓰기)", "w 모드는 기존 파일 내용을 모두 삭제하고 새로 씁니다. 파일이 없으면 새로 생성합니다. 기존 데이터를 보존하려면 a 모드를 사용해야 합니다.", "파일 모드 w", "1090", "medium"),
    ("파일의 기존 내용을 유지하며 뒤에 덧붙이고 싶을 때 사용하는 모드는?", ["r", "w", "a", "x", "r+"], "a", "Append의 약자인 a 모드를 사용하면 기존 파일 내용은 유지되고 새 내용이 파일 끝에 추가됩니다. 로그 파일 작성 시 가장 많이 쓰이는 모드입니다.", "파일 모드 a", "1091", "medium"),
    ("파일 객체의 `read()` 메서드 호출 시 결과값의 자료형은?", ["List", "Dictionary", "String (문자열)", "Tuple", "None"], "String (문자열)", "read()는 파일의 전체 내용을 하나의 큰 문자열로 읽어옵니다. 줄 단위로 읽으려면 readlines()를 씁니다.", "read 결과", "1092", "medium"),
    ("파일을 줄 단위로 쪼개어 리스트 형태로 반환하는 메서드는?", ["read()", "readline()", "readlines()", "split()", "line_list()"], "readlines()", "readlines()는 파일의 각 줄을 요소로 가지는 리스트를 반환합니다. 각 줄 끝에 '\\n'이 포함됩니다.", "readlines", "1093", "medium"),
    ("파일 입출력 시 `with` 문 사용을 권장하는 가장 큰 이유는?", ["파일을 더 빠르게 읽을 수 있어서", "사용 후 파일 객체를 자동으로 닫아(close)주기 때문에", "파일의 크기를 압축해주기 때문에", "한글 깨짐 현상을 100% 방지해주기 때문에", "파일을 자동으로 웹에 동기화해주기 때문에"], "사용 후 파일 객체를 자동으로 닫아(close)주기 때문에", "with 문을 사용하면 블록 종료 시 파일이 자동으로 닫혀 자원 누수를 방지합니다. 예외 발생 시에도 닫기가 보장됩니다.", "with-open", "1094", "hard"),
    ("문자열의 양 끝에 있는 공백이나 줄바꿈을 제거하는 메서드는?", ["clean()", "strip()", "cut()", "trim()", "remove_space()"], "strip()", "strip() 메서드는 문자열 양쪽의 공백 문자와 개행문자(\\n, \\t 등)를 제거합니다. 데이터 전처리 시 자주 씁니다.", "strip", "1095", "medium"),
    ("텍스트 파일 인코딩 문제로 한글이 깨질 때 `open()`에 추가할 옵션은?", ["unicode='yes'", "encoding='utf-8'", "lang='ko'", "style='korean'", "text='plain'"], "encoding='utf-8'", "encoding='utf-8'을 명시하면 UTF-8 인코딩으로 파일을 읽고 써서 한글 처리가 올바르게 됩니다.", "인코딩", "1096", "medium"),
    ("`f.write()` 메서드의 인자로 주어야 하는 자료형은?", ["정수", "실수", "문자열", "리스트", "딕셔너리"], "문자열", "파일에 텍스트를 쓸 때는 반드시 문자열 타입을 전달해야 합니다. 숫자라면 str()로 변환 후 전달해야 합니다.", "파일 쓰기 타입", "1097", "medium"),
    ("JSON 형태의 텍스트를 파이썬 딕셔너리로 변환해주는 모듈은?", ["csv", "txt_parser", "json", "pandas", "dict_maker"], "json", "json 모듈의 loads()는 JSON 문자열을, load()는 JSON 파일을 파이썬 딕셔너리/리스트로 변환합니다.", "json 모듈", "1098", "hard"),
    ("`1 / 0` 을 시도했을 때 발생하는 구체적인 예외 이름은?", ["NullError", "ZeroDivisionError", "MathError", "DividedByZero", "CalculationError"], "ZeroDivisionError", "0으로 나누기를 시도하면 ZeroDivisionError가 발생합니다. except ZeroDivisionError로 구체적으로 잡을 수 있습니다.", "나눗셈 예외", "1099", "medium"),
    ("파일 경로 존재 여부를 확인할 때 쓰는 함수는?", ["os.path.exists()", "os.file_check()", "os.look()", "os_find()", "os.path.is_there()"], "os.path.exists()", "os.path.exists() 함수는 주어진 경로에 파일이나 디렉토리가 실제로 존재하는지 True/False로 반환합니다.", "파일 체크", "1100", "medium")
]

for q, o, a, w, h, i, d in mcq_data:
    questions.append({"chapter_name": chapter_name, "type": "객관식", "difficulty": d, "id": i, "question": q, "options": o, "answer": a, "why": w, "hint": h})

# --- 20 Code Completion Questions ---
cc_data = [
    ("리스트 컴프리헨션으로 짝수 필터링",
     "numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nevens = [x for x in numbers if _____ % 2 == 0]\nprint(evens)  # [2, 4, 6, 8, 10]",
     "x",
     "리스트 컴프리헨션의 조건절 if 뒤에 필터링할 변수를 넣어야 합니다. x % 2 == 0 은 짝수 조건이며, x가 빈칸에 들어갑니다."),

    ("람다 함수로 정렬 키 지정",
     "students = [(\"Alice\", 85), (\"Bob\", 92), (\"Charlie\", 78)]\nstudents.sort(key=_____ x: x[1])\nprint(students)  # 점수 기준 오름차순",
     "lambda",
     "sort()의 key 인자에 람다 함수를 전달하면 정렬 기준을 커스터마이즈할 수 있습니다. lambda x: x[1]은 튜플의 두 번째 요소인 점수를 기준으로 정렬합니다."),

    ("try-except로 ZeroDivisionError 처리",
     "def safe_divide(a, b):\n    try:\n        return a / b\n    except _____ as e:\n        return f\"오류 발생: {e}\"\n\nprint(safe_divide(10, 0))  # 오류 발생: division by zero",
     "ZeroDivisionError",
     "except 뒤에 잡고자 하는 예외 클래스를 명시합니다. ZeroDivisionError는 0으로 나눌 때 발생하며, 일반 Exception보다 구체적으로 지정하는 것이 좋습니다."),

    ("딕셔너리 컴프리헨션",
     "words = [\"hello\", \"world\", \"python\"]\nlengths = {word: _____(word) for word in words}\nprint(lengths)  # {'hello': 5, 'world': 5, 'python': 6}",
     "len",
     "딕셔너리 컴프리헨션 {key: value for item in iterable} 구조에서, 각 단어의 길이를 value로 저장하려면 len() 함수를 사용합니다."),

    ("enumerate로 인덱스-값 딕셔너리 생성",
     "fruits = [\"apple\", \"banana\", \"cherry\"]\nresult = {i: fruit for i, fruit in _____(fruits)}\nprint(result)  # {0: 'apple', 1: 'banana', 2: 'cherry'}",
     "enumerate",
     "enumerate()는 iterable의 각 요소와 인덱스를 (index, value) 튜플로 반환합니다. 딕셔너리 컴프리헨션과 결합하면 인덱스를 키로 하는 딕셔너리를 한 줄에 만들 수 있습니다."),

    ("클래스 상속과 super() 활용",
     "class Animal:\n    def __init__(self, name):\n        self.name = name\n\nclass Dog(Animal):\n    def __init__(self, name, breed):\n        _____.__init__(name)\n        self.breed = breed\n\nd = Dog(\"바둑이\", \"진도\")\nprint(d.name, d.breed)",
     "super()",
     "자식 클래스에서 부모 클래스의 __init__을 호출할 때 super()를 사용합니다. super().__init__(name)은 Animal.__init__(self, name)과 동일하게 동작하며, 다중 상속 시에도 안전하게 작동합니다."),

    ("with 문으로 파일 읽기",
     "with open(\"data.txt\", \"r\", encoding=\"utf-8\") as f:\n    lines = f.readlines()\n\ncleaned = [line._____ () for line in lines]\nprint(cleaned)",
     "strip",
     "readlines()로 읽으면 각 줄 끝에 '\\n'이 포함됩니다. strip() 메서드는 문자열 양쪽의 공백과 개행문자를 제거하여 깔끔한 데이터를 만들어줍니다."),

    ("*args를 활용한 가변 인자 합산",
     "def calculate_sum(*numbers):\n    return _____(numbers)\n\nprint(calculate_sum(1, 2, 3, 4, 5))  # 15\nprint(calculate_sum(10, 20))  # 30",
     "sum",
     "*numbers로 받은 가변 인자는 튜플로 전달됩니다. sum()은 iterable의 모든 숫자를 더하며, 리스트나 튜플 모두 인자로 받을 수 있습니다."),

    ("**kwargs로 키워드 인자 처리",
     "def display_info(**kwargs):\n    for key, value in kwargs._____():\n        print(f\"{key}: {value}\")\n\ndisplay_info(name=\"김철수\", age=25, city=\"서울\")",
     "items",
     "딕셔너리의 items() 메서드는 (key, value) 쌍을 반환합니다. **kwargs로 받은 가변 키워드 인자도 딕셔너리처럼 items()를 호출할 수 있습니다."),

    ("재귀 함수로 팩토리얼 계산",
     "def factorial(n):\n    if n <= 1:\n        return 1\n    return n * _____(n - 1)\n\nprint(factorial(5))  # 120",
     "factorial",
     "재귀 함수는 함수 내부에서 자기 자신을 호출합니다. factorial(n) = n * factorial(n-1)이라는 점화식이 핵심이며, n<=1인 기저 조건(base case)이 반드시 있어야 무한 루프를 방지합니다."),

    ("set을 활용한 중복 제거",
     "numbers = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\nunique = list(_____(numbers))\nunique.sort()\nprint(unique)  # [1, 2, 3, 4]",
     "set",
     "set()은 중복을 허용하지 않는 자료구조입니다. 리스트를 set()으로 변환하면 중복이 제거되고, 다시 list()로 변환하면 리스트로 쓸 수 있습니다."),

    ("zip으로 두 리스트 병합",
     "names = [\"Alice\", \"Bob\", \"Charlie\"]\nscores = [85, 92, 78]\npaired = list(_____(names, scores))\nprint(paired)  # [('Alice', 85), ('Bob', 92), ('Charlie', 78)]",
     "zip",
     "zip()은 두 iterable을 같은 인덱스끼리 묶어 튜플의 이터레이터를 만듭니다. list()로 감싸면 결과를 즉시 확인할 수 있으며, 서로 다른 길이면 짧은 쪽 기준으로 잘립니다."),

    ("json 모듈로 파일 저장",
     "import json\n\ndata = {\"name\": \"김철수\", \"score\": 95}\nwith open(\"result.json\", \"w\", encoding=\"utf-8\") as f:\n    json._____(data, f, ensure_ascii=False, indent=2)",
     "dump",
     "json.dump()는 파이썬 객체를 JSON 형식으로 파일에 저장합니다. ensure_ascii=False 옵션을 주면 한글이 \\uXXXX 형태로 깨지지 않고 그대로 저장됩니다."),

    ("map과 list로 일괄 변환",
     "str_numbers = [\"1\", \"2\", \"3\", \"4\", \"5\"]\nint_numbers = list(_____(int, str_numbers))\nprint(int_numbers)  # [1, 2, 3, 4, 5]\nprint(sum(int_numbers))  # 15",
     "map",
     "map(함수, iterable)은 iterable의 모든 요소에 함수를 적용합니다. 여기서 int 함수를 각 문자열에 적용하면 정수 리스트가 됩니다. map 객체는 list()로 변환해야 합니다."),

    ("슬라이싱으로 역순 정렬",
     "text = \"Python\"\nreversed_text = text[_____ : _____ : -1]\nprint(reversed_text)  # nohtyP",
     "::",
     "슬라이싱 [start:end:step]에서 step=-1이면 역순으로 순회합니다. start와 end를 생략하면 처음부터 끝까지를 의미하므로 [::-1]은 문자열 전체를 뒤집습니다."),

    ("조건부 표현식 (삼항 연산자)",
     "score = 85\ngrade = \"합격\" _____ score >= 60 else \"불합격\"\nprint(grade)  # 합격",
     "if",
     "파이썬의 조건부 표현식(삼항 연산자) 구조는 '참값 if 조건 else 거짓값'입니다. C언어의 (조건 ? 참 : 거짓)과 달리 if/else 키워드를 사용합니다."),

    ("global 변수 수정",
     "count = 0\n\ndef increment():\n    _____ count\n    count += 1\n\nincrement()\nincrement()\nprint(count)  # 2",
     "global",
     "함수 내부에서 전역 변수를 '수정'하려면 global 선언이 필요합니다. 선언 없이 count += 1을 하면 UnboundLocalError가 발생합니다. 조회만 할 때는 global 선언이 불필요합니다."),

    ("클래스 변수와 인스턴스 변수",
     "class Counter:\n    total = 0  # 클래스 변수\n    \n    def __init__(self):\n        Counter._____ += 1\n        self.id = Counter.total\n\nc1, c2, c3 = Counter(), Counter(), Counter()\nprint(Counter.total)  # 3",
     "total",
     "클래스 변수는 Counter.변수명으로 접근하며 모든 인스턴스가 공유합니다. self.total이 아닌 Counter.total로 접근해야 클래스 변수를 수정할 수 있습니다."),

    ("filter로 조건 필터링",
     "numbers = [1, -2, 3, -4, 5, -6]\npositive = list(_____(lambda x: x > 0, numbers))\nprint(positive)  # [1, 3, 5]",
     "filter",
     "filter(함수, iterable)은 함수의 결과가 True인 요소만 남깁니다. lambda x: x > 0은 양수 조건이며, filter 객체를 list()로 변환해 결과를 확인합니다."),

    ("isinstance로 타입 체크 후 처리",
     "def process(value):\n    if _____(value, int):\n        return value * 2\n    elif isinstance(value, str):\n        return value.upper()\n    return None\n\nprint(process(5))   # 10\nprint(process(\"hi\"))  # HI",
     "isinstance",
     "isinstance(객체, 타입)은 객체가 해당 타입의 인스턴스인지 확인합니다. type(value) == int 보다 isinstance가 권장되는 이유는 상속 관계도 고려하기 때문입니다.")
]

for i, (title, code, ans, explain) in enumerate(cc_data):
    questions.append({
        "chapter_name": chapter_name, "type": "코드 완성형", "difficulty": "medium", "id": str(1101 + i),
        "question": f"{title} 코드를 완성하세요.\n```python\n{code}\n```",
        "answer": ans,
        "why": explain,
        "hint": title,
    })

def get_questions():
    return questions
